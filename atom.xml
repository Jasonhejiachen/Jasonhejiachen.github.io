<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>何嘉晨的个人博客</title>
  
  <subtitle>Quality matters more than quantity.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-24T16:15:32.669Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>何嘉晨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>寻找峰值_162</title>
    <link href="http://yoursite.com/posts/solution-162/"/>
    <id>http://yoursite.com/posts/solution-162/</id>
    <published>2019-04-24T15:58:01.000Z</published>
    <updated>2019-04-24T16:15:32.669Z</updated>
    
    <content type="html"><![CDATA[<p><strong>难度：</strong><font color="e1e1">中等</font></p><p>这是该题的地址：<a href="https://leetcode-cn.com/problems/find-peak-element/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-peak-element/</a></p><p>峰值元素是指其值大于左右相邻值的元素。</p><p>给定一个输入数组 <code>nums</code>，其中 <code>nums[i] ≠ nums[i+1]</code>，找到峰值元素并返回其索引。</p><p>数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。</p><p>你可以假设 <code>nums[-1] = nums[n] = -∞</code>。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,2,3,1]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 3 是峰值元素，你的函数应该返回其索引 2。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,2,1,3,5,6,4]</span><br><span class="line">输出: 1 或 5 </span><br><span class="line">解释: 你的函数可以返回索引 1，其峰值元素为 2；</span><br><span class="line">     或者返回索引 5， 其峰值元素为 6。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><p>你的解法应该是 <em>O</em>(<em>logN</em>) 时间复杂度的。</p><a id="more"></a><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>这题一眼看过去 不是很简单嘛？直接遍历 找 nums[i-1]&lt;nums[i]&gt;nums[i+1] 这个关系式不就好了嘛？但是突然发现时间复杂度应该式logN 那么很显然应该要使用到二分查找法来做这一道题吧。</p><h3 id="二分搜索A（虚假的二分）"><a href="#二分搜索A（虚假的二分）" class="headerlink" title="二分搜索A（虚假的二分）"></a>二分搜索A（虚假的二分）</h3><p>然而我还是想错了，想着用二分搜索，将哪个nums[i-1]&lt;nums[i]&gt;nums[i+1]  的点搜出来直接返回就好了，也就是说我直接对数组二分，查找左半边和右半边第一个符合条件的点。最差的情况下时间复杂度是接近O（n） 比较优的情况下才是O(logN) 虽然AC了题目，但是我觉得这样其实也是不对的答案。我的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nums[<span class="number">0</span>]&gt;nums[<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nums[nums.length-<span class="number">1</span>]&gt;nums[nums.length-<span class="number">2</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> nums.length-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">1</span>,right = nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> getPeak(nums,left,right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPeak</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&lt;right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; nums[mid - <span class="number">1</span>] &amp;&amp; nums[mid] &gt; nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftpart = getPeak(nums, left, mid);</span><br><span class="line">        <span class="keyword">if</span> (leftpart != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> leftpart;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rightpart = getPeak(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">if</span> (rightpart != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> rightpart;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二分搜索B（真正的二分）"><a href="#二分搜索B（真正的二分）" class="headerlink" title="二分搜索B（真正的二分）"></a>二分搜索B（真正的二分）</h3><p>通过题目我们可以得知，当一个点比他的后一个点大时，那么前面一定有峰值，那么就选择前面的一半继续进行二分，当他比后一个点小的时候，后面一定有峰值，那么就选择后面的那一半进行二分。那么我们可以通过这个关系来进行二分。当left==right时，那个点就是峰值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left =<span class="number">0</span>,right = nums.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]&gt;nums[mid+<span class="number">1</span>])&#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;难度：&lt;/strong&gt;&lt;font color=&quot;e1e1&quot;&gt;中等&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;这是该题的地址：&lt;a href=&quot;https://leetcode-cn.com/problems/find-peak-element/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/find-peak-element/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;峰值元素是指其值大于左右相邻值的元素。&lt;/p&gt;
&lt;p&gt;给定一个输入数组 &lt;code&gt;nums&lt;/code&gt;，其中 &lt;code&gt;nums[i] ≠ nums[i+1]&lt;/code&gt;，找到峰值元素并返回其索引。&lt;/p&gt;
&lt;p&gt;数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。&lt;/p&gt;
&lt;p&gt;你可以假设 &lt;code&gt;nums[-1] = nums[n] = -∞&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: nums = [1,2,3,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 3 是峰值元素，你的函数应该返回其索引 2。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: nums = [1,2,1,3,5,6,4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 1 或 5 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 你的函数可以返回索引 1，其峰值元素为 2；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     或者返回索引 5， 其峰值元素为 6。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你的解法应该是 &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;logN&lt;/em&gt;) 时间复杂度的。&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="二分查找" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>零钱兑换_322</title>
    <link href="http://yoursite.com/posts/solution-322/"/>
    <id>http://yoursite.com/posts/solution-322/</id>
    <published>2019-04-20T07:18:37.000Z</published>
    <updated>2019-04-24T16:16:35.885Z</updated>
    
    <content type="html"><![CDATA[<p><strong>难度：</strong><font color="e1e1">中等</font></p><p>这是该题的地址：<a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/coin-change/</a></p><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code>。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: coins = [1, 2, 5], amount = 11</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 11 = 5 + 5 + 1</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: coins = [2], amount = 3</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure><p><strong>说明</strong>:<br>你可以认为每种硬币的数量是无限的。</p><a id="more"></a><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><h3 id="按金额动态规划"><a href="#按金额动态规划" class="headerlink" title="按金额动态规划"></a>按金额动态规划</h3><p>该题我的思路是这样的，首先遍历到amount金额的每个金钱，然后对每个金钱动态规划求最优金额。时间复杂度应该是O(n*m); 我们可以根据这样得出下列推到式：i是当前的金币额度。</p><ol><li>当金钱比硬币大的时候  min[i] = 1+ ｛min[i-coinsA,i-coinsB,i-coinsC…….]｝</li><li>当金钱和硬币相等时 min[i] = 1;</li><li>当这个金钱无法被硬币代表时，值是Integer.MAX_VALUE，后续的操作对它进行判断。</li></ol><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">从1开始 </span><br><span class="line">一块钱的最优解是多少 是1。那么min[1] = 1;</span><br><span class="line">两块的最优解 min[2] = min[2 - 1] + 1 = 2;</span><br><span class="line">三块的最优解 1、min[3 - 1] + 1 = 2  2、min[3] = 1  得出：1&lt;2; </span><br><span class="line">---&gt;min[3] = 1;</span><br><span class="line">四块钱的最优解 1、min[4-1] +1 =2   2、min[4-3] + 1 = 2 </span><br><span class="line">--—&gt; min[4] = 2;</span><br><span class="line">五块钱的最优解 1、min[5-1] + 1 = 3 2、min[5-3] + 1 = 3 得出1&lt;3</span><br><span class="line">---&gt;min[5]= 1;</span><br><span class="line">以此类推 ......  min[11] 进行三次操作 min[11 - 1]+1  min[11 - 3] + 1  min[11-5] + 1 在三个值之中取最小值。min[11] = 3</span><br></pre></td></tr></table></figure><p>代码：</p><p>最后假如这个数是没有硬币对应的 要返回-1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] min = <span class="keyword">new</span> <span class="keyword">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=amount;i++)&#123;</span><br><span class="line">        min[i] = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;coins.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i-coins[j]&gt;<span class="number">0</span> &amp;&amp; min[i-coins[j]]!=Integer.MAX_VALUE)&#123;</span><br><span class="line">                min[i] = min[i-coins[j]] + <span class="number">1</span>&lt; min[i]?min[i-coins[j]]+<span class="number">1</span>:min[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i-coins[j]==<span class="number">0</span>)&#123;</span><br><span class="line">                min[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min[amount]==Integer.MAX_VALUE?-<span class="number">1</span>:min[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;难度：&lt;/strong&gt;&lt;font color=&quot;e1e1&quot;&gt;中等&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;这是该题的地址：&lt;a href=&quot;https://leetcode-cn.com/problems/coin-change/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/coin-change/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 &lt;code&gt;-1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: coins = [1, 2, 5], amount = 11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 3 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 11 = 5 + 5 + 1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: coins = [2], amount = 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: -1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;:&lt;br&gt;你可以认为每种硬币的数量是无限的。&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>最长上升子序列_300</title>
    <link href="http://yoursite.com/posts/solution-300/"/>
    <id>http://yoursite.com/posts/solution-300/</id>
    <published>2019-04-18T13:07:47.000Z</published>
    <updated>2019-04-18T13:49:07.555Z</updated>
    
    <content type="html"><![CDATA[<p><strong>难度：</strong><font color="e1e1">中等</font></p><p>这是本题的地址：<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-increasing-subsequence/</a></p><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [10,9,2,5,3,7,101,18]</span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。</li><li>你算法的时间复杂度应该为 O(<em>n2</em>) 。</li></ul><p><strong>进阶:</strong> 你能将算法的时间复杂度降低到 O(<em>n</em> log <em>n</em>) 吗?</p><a id="more"></a><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>这题一开始看到觉得 是不是可以用双指针，但是发现好像不是很行，因为这个最长上升子序列的值是可以跳跃的，而不是说都是连续的。这样感觉双指针就不好对长度进行划分，从而不是一个好想法</p><h3 id="冒泡遍历"><a href="#冒泡遍历" class="headerlink" title="冒泡遍历"></a>冒泡遍历</h3><p>然后我就按照题目的特性，速度是O(n^2) 则可以使用冒泡这种简单的双重遍历，从动态规划的角度看这个问题，我的想法如下：</p><ol><li>从数组第一个点开始遍历、将当前结点与后续结点进行对比，如果后续结点的值比当前结点的大，则比较后续结点和当前结点的最长子序列哪个更大，保留更大的值。</li><li>最长的子序列不一定在数组的尾部。在每个结点遍历完之后和max值比较，获取最长的子序列。</li><li>因为数组的值是从0开始 而子序的长度是从1开始 所以在最后返回时 值要加1</li></ol><p>如下解例子：</p><p>判断子序列的做法</p><ol><li>i 结点的值要小于 j 结点</li><li>当前点（i）子序列长度+1 和 后续结点（j）子序列长度 进行比较  保留更长的子序列长度</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">数组：[10,9,2,5,3,7,101,18]  当前结点的子序列长度：[0,0,0,0,0,0,0,0]</span><br><span class="line">抛出一个点 10。通过判断子序列的长度 后续的子序列长度为:  [0,0,0,0,0,0,1,1]</span><br><span class="line">抛出一个点9 [0,0,0,0,0,0,1,1]</span><br><span class="line">抛出一个点2 [0,0,0,1,1,1,1,1]</span><br><span class="line">抛出一个点5 [0,0,0,1,1,2,2,2]  特殊点：7比5大 但是5的长度是1+1=2 并没有比原本7的值大 所以长度不变</span><br><span class="line">抛出一个点3 [0,0,0,1,1,2,2,2]</span><br><span class="line">抛出一个点7 [0,0,0,1,1,2,3,3]</span><br><span class="line">抛出一个点101 [0,0,0,1,1,2,3,3]</span><br><span class="line">那么返回的值就是3+1=4.</span><br></pre></td></tr></table></figure><p>下面是代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] max = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    max[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> themax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[i]) &#123;</span><br><span class="line">                max[j] = max[j] &gt; max[i] + <span class="number">1</span> ? max[j] : max[i] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        themax = themax&gt;max[i]?themax:max[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> themax + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="进阶解法"><a href="#进阶解法" class="headerlink" title="进阶解法"></a>进阶解法</h2><p>进阶解法nlogn 感觉一看就要二分呀… 暂时还没想出来，先挖个坑。</p><p>这个结束之后则获取最优解：</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;难度：&lt;/strong&gt;&lt;font color=&quot;e1e1&quot;&gt;中等&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;这是本题的地址：&lt;a href=&quot;https://leetcode-cn.com/problems/longest-increasing-subsequence/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/longest-increasing-subsequence/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一个无序的整数数组，找到其中最长上升子序列的长度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [10,9,2,5,3,7,101,18]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 4 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。&lt;/li&gt;
&lt;li&gt;你算法的时间复杂度应该为 O(&lt;em&gt;n2&lt;/em&gt;) 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;进阶:&lt;/strong&gt; 你能将算法的时间复杂度降低到 O(&lt;em&gt;n&lt;/em&gt; log &lt;em&gt;n&lt;/em&gt;) 吗?&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>最大值_179</title>
    <link href="http://yoursite.com/posts/solution-179/"/>
    <id>http://yoursite.com/posts/solution-179/</id>
    <published>2019-04-17T01:23:08.000Z</published>
    <updated>2019-04-17T02:15:46.247Z</updated>
    
    <content type="html"><![CDATA[<p><strong>难度：</strong><font color="e1e1">中等</font></p><p>这是本题的地址：<a href="https://leetcode-cn.com/problems/largest-number/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/largest-number/submissions/</a></p><p>给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [10,2]</span><br><span class="line">输出: 210</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,30,34,5,9]</span><br><span class="line">输出: 9534330</span><br></pre></td></tr></table></figure><p><strong>说明:</strong> 输出结果可能非常大，所以你需要返回一个字符串而不是整数。</p><a id="more"></a><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>根据题目，可以知道 这题大概的做法是： 按照一定的排序规则然后用排序算法进行排序。</p><p>首先我们先梳理一下比较规则：先把left right 两个值都转为string（因为题目中提示了字符串，所以用int类型进行比较应该是不合适的） ，这时候两个值的长度可能不相等，这时候我们将他们相加 left+right 和 right+left 这时候两个字符串的长度是相等的，这时候奖left+right 和 right+left 从第一个字符处开始比较，这时候来比较left 和right 哪个值在数组前更好，然后进行位置交换。</p><p>那么在有了比较规则之后，我们可以通过排序算法来让这个值和别的值再进行比较，最后就可以得出一个从大到小的数组，将数组转为string 然后判断第一个字符是否为’0’ （因为如果整个数组都是0的话，他的第一个字符肯定是零，那么返回的string就是’0’而不是”000”）最后返回string。</p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>我用的是比较好理解，但是效率不高的冒泡排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">largestNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = nums[i], right = nums[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (!BiggerStr(<span class="string">""</span> + left + right, <span class="string">""</span> + right + left)) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">            nums[i] = nums[i + <span class="number">1</span>];</span><br><span class="line">            nums[i + <span class="number">1</span>] = temp;</span><br><span class="line">            BubbleSort(nums, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">        str.append(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (str.charAt(<span class="number">0</span>) == <span class="string">'0'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进行冒泡</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = num; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = nums[i], right = nums[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (BiggerStr(<span class="string">""</span> + left + right, <span class="string">""</span> + right + left)) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">            nums[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">            nums[i - <span class="number">1</span>] = temp;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//比较规则</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">BiggerStr</span><span class="params">(String left, String right)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left.charAt(<span class="number">0</span>) &gt; right.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left.charAt(<span class="number">0</span>) == right.charAt(<span class="number">0</span>) &amp;&amp; left.length() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> BiggerStr(left.substring(<span class="number">1</span>), right.substring(<span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;难度：&lt;/strong&gt;&lt;font color=&quot;e1e1&quot;&gt;中等&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;这是本题的地址：&lt;a href=&quot;https://leetcode-cn.com/problems/largest-number/submissions/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/largest-number/submissions/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [10,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 210&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [3,30,34,5,9]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 9534330&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt; 输出结果可能非常大，所以你需要返回一个字符串而不是整数。&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="最大值" scheme="http://yoursite.com/tags/%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>集成Netty框架的生产者消费者模式</title>
    <link href="http://yoursite.com/posts/%E9%9B%86%E6%88%90Netty%E6%A1%86%E6%9E%B6%E7%9A%84%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/posts/集成Netty框架的生产者消费者模式/</id>
    <published>2019-04-15T05:49:55.000Z</published>
    <updated>2019-04-17T02:33:33.869Z</updated>
    
    <content type="html"><![CDATA[<p>我相信作为一名程序员，每个人都是想要把自己的项目做的越来越好，这是毋庸置疑的。在一次项目中我实现了生产者消费者模式，现在在博客中和大家说说我的做法。</p><h2 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h2><p>下面是生产者模式和消费者模式原型图吧：</p><p><img src="/posts/集成Netty框架的生产者消费者模式/picutre1.png" alt=""></p><p>生产者向缓冲区放入数据，消费者向缓冲区获取数据，如果缓冲区中没有消费者要的数据，消费者就会阻塞。</p><a id="more"></a><h2 id="项目中的应用"><a href="#项目中的应用" class="headerlink" title="项目中的应用"></a>项目中的应用</h2><h3 id="数据流程图"><a href="#数据流程图" class="headerlink" title="数据流程图"></a>数据流程图</h3><p>下面是我在项目中使用阻塞队列实现生产者消费者模式的数据流程图</p><p><img src="/posts/集成Netty框架的生产者消费者模式/picture2.png" alt=""></p><p>在这个图中，当数据推送出去之后 发送数据的方法就成了消费者。而第三方系统则成了生产者，将数据推回本系统中。当消费者从阻塞队列中获取到了数据，就不会继续阻塞。</p><h3 id="关于代码"><a href="#关于代码" class="headerlink" title="关于代码"></a>关于代码</h3><p>在本文就不详细的聊netty框架了（虽然我也是刚接触~），主要是聊项目中的设计模式思想。但是我还是列举一些关键代码。</p><p>这个是ChannelHandler的read方法代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">    String body = (String) msg;</span><br><span class="line">    String newBody = body.substring(body.indexOf(<span class="string">"&#123;"</span>));</span><br><span class="line">    JSONObject object = JSONObject.fromObject(newBody);</span><br><span class="line">    String cmd = object.getString(<span class="string">"cmd"</span>).trim();</span><br><span class="line">    <span class="keyword">if</span> (NETTY_LOGIN.equals(cmd)) &#123;</span><br><span class="line">        <span class="comment">//客户端登陆时将通道保存下来</span></span><br><span class="line">        NettyChannelUtil.setClientCtx(ctx);</span><br><span class="line">        ...忽略</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (NETTY_PING.equals(cmd)) &#123;</span><br><span class="line">        ...忽略</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//将生产者的数据写入阻塞队列中</span></span><br><span class="line">        String SEQ = object.getString(<span class="string">"SEQ"</span>);</span><br><span class="line">        BlockingQueue blockingQueue = NettyChannelUtil.getResultMap().get(SEQ);</span><br><span class="line">        <span class="keyword">if</span> (blockingQueue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            blockingQueue.add(object);</span><br><span class="line">            NettyChannelUtil.getResultMap().put(SEQ, blockingQueue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是发送数据的方法 代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> JSONObject <span class="title">sendMessage</span><span class="params">(String mapkey, String msg)</span> </span>&#123;</span><br><span class="line">       ...省略</span><br><span class="line">    <span class="comment">//创建新的阻塞队列</span></span><br><span class="line">    NettyChannelUtil.getResultMap().put(mapkey, <span class="keyword">new</span> LinkedBlockingQueue(<span class="number">1</span>));</span><br><span class="line">    <span class="comment">//获取通道，将数据写入。</span></span><br><span class="line">    NettyChannelUtil.getClientCtx().channel().writeAndFlush(msg);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//通过阻塞队列获取数据</span></span><br><span class="line">        JSONObject result = NettyChannelUtil.getResultMap().get(mapkey).poll(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">        NettyChannelUtil.getResultMap().remove(mapkey);</span><br><span class="line">        ...省略</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        ...省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么阻塞队列具体是怎么做的呢？</p><p>通过ConcurrentHashMap，Key是传输过去的包编码，value是一个长度为1的阻塞队列。因为ConcurrenHashMap的特征，voliate关键字保证了value是最新的值，而且具备并发的线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyChannelUtil</span> </span>&#123;</span><br><span class="line"><span class="comment">//存储客户端的通道</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ChannelHandlerContext CLIENT_CTX = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//阻塞队列---生产者消费者模式中的缓冲区。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, BlockingQueue&lt;JSONObject&gt;&gt; RESULT_MAP = <span class="keyword">new</span> ConcurrentHashMap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ConcurrentHashMap&lt;String, BlockingQueue&lt;JSONObject&gt;&gt; getResultMap() &#123;</span><br><span class="line">        <span class="keyword">return</span> RESULT_MAP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ChannelHandlerContext <span class="title">getClientCtx</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CLIENT_CTX;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setClientCtx</span><span class="params">(ChannelHandlerContext clientCtx)</span> </span>&#123;</span><br><span class="line">        CLIENT_CTX = clientCtx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我相信作为一名程序员，每个人都是想要把自己的项目做的越来越好，这是毋庸置疑的。在一次项目中我实现了生产者消费者模式，现在在博客中和大家说说我的做法。&lt;/p&gt;
&lt;h2 id=&quot;生产者消费者模式&quot;&gt;&lt;a href=&quot;#生产者消费者模式&quot; class=&quot;headerlink&quot; title=&quot;生产者消费者模式&quot;&gt;&lt;/a&gt;生产者消费者模式&lt;/h2&gt;&lt;p&gt;下面是生产者模式和消费者模式原型图吧：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/集成Netty框架的生产者消费者模式/picutre1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;生产者向缓冲区放入数据，消费者向缓冲区获取数据，如果缓冲区中没有消费者要的数据，消费者就会阻塞。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="生产者消费者模式" scheme="http://yoursite.com/tags/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>链表排序_148</title>
    <link href="http://yoursite.com/posts/solution-148/"/>
    <id>http://yoursite.com/posts/solution-148/</id>
    <published>2019-04-10T14:42:10.000Z</published>
    <updated>2019-04-17T06:26:55.541Z</updated>
    
    <content type="html"><![CDATA[<p><strong>难度：</strong><font color="e1e1">中等</font></p><p>这是本题的地址：<a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sort-list/</a></p><p>在 <em>O</em>(<em>n</em> log <em>n</em>) 时间复杂度和常数级空间复杂度下，对链表进行排序。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 4-&gt;2-&gt;1-&gt;3</span><br><span class="line">输出: 1-&gt;2-&gt;3-&gt;4</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: -1-&gt;5-&gt;3-&gt;4-&gt;0</span><br><span class="line">输出: -1-&gt;0-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>我觉得这题不仅考查了链表还考查了排序的知识，是一道非常好的题目吧~</p><p>看到题目中的时间复杂度O(nlogn) ，就可以知道我们要使用一些比较搞笑的排序算法，比如快速排序、归并排序等等。像冒泡排序等时间复杂度为n^2的排序算法肯定是不适用的~</p><h3 id="1、归并排序"><a href="#1、归并排序" class="headerlink" title="1、归并排序"></a>1、归并排序</h3><p>归并排序有分治的思想，所以他的排序速度会更快。</p><p>在链表里使用归并排序有下列几个注意点：</p><p>1、分治法获取中点使用快慢指针，这样慢指针就肯定在中点处了</p><p>2、分治之后，左链表的尾部是中点，而右链表则是从中点开始往后。这样不断分治，最小的链表只有1个节点。</p><p>3、将左右链表合并进行排序，首先记录下合并的链表的头结点，然后再将后续节点进行对比，最后返回头结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode fast = head, slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    fast = slow.next;</span><br><span class="line">    slow.next = <span class="keyword">null</span>;</span><br><span class="line">    slow = head;</span><br><span class="line">    slow = sortList(slow);</span><br><span class="line">    fast = sortList(fast);</span><br><span class="line">    <span class="keyword">return</span> sort(fast, slow);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sort</span><span class="params">(ListNode left, ListNode right)</span> </span>&#123;</span><br><span class="line">    ListNode firstNode, otherNode;</span><br><span class="line">    <span class="keyword">if</span> (left.val &lt; right.val) &#123;</span><br><span class="line">        firstNode = left;</span><br><span class="line">        left = left.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        firstNode = right;</span><br><span class="line">        right = right.next;</span><br><span class="line">    &#125;</span><br><span class="line">    otherNode = firstNode;</span><br><span class="line">    <span class="keyword">while</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left.val &lt; right.val) &#123;</span><br><span class="line">            otherNode.next = left;</span><br><span class="line">            left = left.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            otherNode.next = right;</span><br><span class="line">            right = right.next;</span><br><span class="line">        &#125;</span><br><span class="line">        otherNode = otherNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        otherNode.next = left;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        otherNode.next = right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> firstNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、快速排序"><a href="#2、快速排序" class="headerlink" title="2、快速排序"></a>2、快速排序</h3><p>….之后更新！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;难度：&lt;/strong&gt;&lt;font color=&quot;e1e1&quot;&gt;中等&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;这是本题的地址：&lt;a href=&quot;https://leetcode-cn.com/problems/sort-list/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/sort-list/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在 &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt; log &lt;em&gt;n&lt;/em&gt;) 时间复杂度和常数级空间复杂度下，对链表进行排序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: 4-&amp;gt;2-&amp;gt;1-&amp;gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: -1-&amp;gt;5-&amp;gt;3-&amp;gt;4-&amp;gt;0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: -1-&amp;gt;0-&amp;gt;3-&amp;gt;4-&amp;gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="归并排序" scheme="http://yoursite.com/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>移动零_283</title>
    <link href="http://yoursite.com/posts/solution-283/"/>
    <id>http://yoursite.com/posts/solution-283/</id>
    <published>2019-04-09T08:11:39.000Z</published>
    <updated>2019-04-17T06:26:33.859Z</updated>
    
    <content type="html"><![CDATA[<p><strong>难度：</strong><font color="green">简单</font></p><p>真是该题的地址：<a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/move-zeroes/</a></p><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure><p><strong>说明</strong>:</p><ol><li>必须在原数组上操作，不能拷贝额外的数组。</li><li>尽量减少操作次数。</li></ol><a id="more"></a><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>这题主要是让我对交换这个概念有了新的看法吧，所以我就把他记录了下来。</p><p>通过题干我们可以发现，0要到数据的末尾，那么我们刚开始学习java的时候，交换数组两个元素的位置，通常用的是下面这种操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> temp = nums[i];</span><br><span class="line">nums[i] = nums[i+<span class="number">1</span>];</span><br><span class="line">nums[i+<span class="number">1</span>] = temp;</span><br></pre></td></tr></table></figure><p>那么假如我们使用冒泡的话。要把第一个位的0换到最后一个位置上，需要n次的操作。那么把第二个位置的0换到倒数第二个位置上，需要n-2次操作… 以此类推的话我们的算法效率十分的低…</p><h3 id="1、-接近一次遍历。"><a href="#1、-接近一次遍历。" class="headerlink" title="1、 接近一次遍历。"></a>1、 接近一次遍历。</h3><p>这是我一开始的想法，都不知道为啥自己总往复杂的想：当1个0遇到第2个0时，跳过它并和下一个非零进行交换，并且记录遇到了几个0，因为0和0之间相靠的，在找下一个非0点的时候就要跳过前面的0。缺点：我觉得这里最终遍历的点还是多于n了，还是不够好。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> zeronum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + zeronum; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">                    nums[i] = nums[j];</span><br><span class="line">                    nums[j] = temp;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    zeronum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、-一次遍历"><a href="#2、-一次遍历" class="headerlink" title="2、 一次遍历"></a>2、 一次遍历</h3><p>很巧妙的做法，通过两个指针i 和 j，当指针i为0的时候，将nums[i] 赋值给nums[j] 这样就能在保证顺序的同时去掉0，然后将j到数组末尾的赋值为0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">            nums[j++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;nums.length)&#123;</span><br><span class="line">        nums[j++] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;难度：&lt;/strong&gt;&lt;font color=&quot;green&quot;&gt;简单&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;真是该题的地址：&lt;a href=&quot;https://leetcode-cn.com/problems/move-zeroes/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/move-zeroes/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一个数组 &lt;code&gt;nums&lt;/code&gt;，编写一个函数将所有 &lt;code&gt;0&lt;/code&gt; 移动到数组的末尾，同时保持非零元素的相对顺序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [0,1,0,3,12]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [1,3,12,0,0]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;必须在原数组上操作，不能拷贝额外的数组。&lt;/li&gt;
&lt;li&gt;尽量减少操作次数。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>课程表_207</title>
    <link href="http://yoursite.com/posts/solution-207/"/>
    <id>http://yoursite.com/posts/solution-207/</id>
    <published>2019-04-05T13:08:09.000Z</published>
    <updated>2019-04-17T06:26:12.134Z</updated>
    
    <content type="html"><![CDATA[<p><strong>难度：</strong><font color="e1e1">中等</font></p><p>这是该题的地址：<a href="https://leetcode-cn.com/problems/course-schedule/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/course-schedule/</a></p><p>现在你总共有 <em>n</em> 门课需要选，记为 <code>0</code> 到 <code>n-1</code>。</p><p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: <code>[0,1]</code></p><p>给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2, [[1,0]] </span><br><span class="line">输出: true</span><br><span class="line">解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2, [[1,0],[0,1]]</span><br><span class="line">输出: false</span><br><span class="line">解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>这道题其实题目中给出了拓补排序的提示，其实我认为就是判断您当前的图中，是否存在循环，如果有循环肯定不能进行拓补排序，那么就返回失败，如果没有循环，则继续进行拓补排序，最后返回成功。</p><p>拓补排序：简单的说就是把没有入度的结点一个个拿走。代码中可以将要去除的元素给与特定标记来标识。</p><p>在做这道题的时候发现有很多细节可以抠，以下是我的几种方案。</p><p>先贴它们的运行时间，用例是leetcode的测试用例，数组长度是1000：</p><p><img src="/posts/solution-207/picture1.png" alt=""></p><h3 id="1、用set存储以遍历过的数据（严重超时）"><a href="#1、用set存储以遍历过的数据（严重超时）" class="headerlink" title="1、用set存储以遍历过的数据（严重超时）"></a>1、用set存储以遍历过的数据（严重超时）</h3><p>这是我一开始的思路：通过一个set bighs存已遍历过的结点，通过一个set hs 存当前的点所经过的结点，通过这两个set来判断是否存在环的情况，很显然，因为有一个hs.clone操作在for循环里面，这里面的时间复杂度会高的不得了。。。。。而且这个方案确实太麻烦了太笨了。。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">HashSet bighs = <span class="keyword">new</span> HashSet();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (numCourses == <span class="number">0</span> || prerequisites == <span class="keyword">null</span> || prerequisites.length == <span class="number">0</span> || prerequisites[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!bighs.contains(prerequisites[i][<span class="number">0</span>]))&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dfs(prerequisites[i][<span class="number">0</span>],prerequisites,<span class="keyword">new</span> HashSet()))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> key,<span class="keyword">int</span>[][] prerequisites,HashSet hs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(bighs.contains(key))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    hs.add(key);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prerequisites.length;i++)&#123;</span><br><span class="line">        HashSet hs1 = (HashSet) hs.clone();</span><br><span class="line">        <span class="keyword">int</span> nums1 = prerequisites[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(nums1==key)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hs.contains(prerequisites[i][<span class="number">1</span>]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!dfs(prerequisites[i][<span class="number">1</span>],prerequisites,hs1))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    bighs.add(key);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、使用一个数组-nums-来代表当前课程的状态。"><a href="#2、使用一个数组-nums-来代表当前课程的状态。" class="headerlink" title="2、使用一个数组 nums 来代表当前课程的状态。"></a>2、使用一个数组 nums 来代表当前课程的状态。</h3><p>nums的长度是n，数组nums有3个值 0代表未访问 1代表访问中 2代表访问过，每次遍历结点，假如是0就往下进行拓补排序，假如是1就返回false，假如是2就返回true。往下搜索时，对下一个结点继续拓补排序。通过nums这个数组，减少了很多不必要的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish2</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prerequisites.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[prerequisites[i][<span class="number">0</span>]]!=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dfs(prerequisites,nums,prerequisites[i][<span class="number">0</span>]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] prerequisites, <span class="keyword">int</span>[] nums , <span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums[key]==<span class="number">0</span>)&#123;</span><br><span class="line">        nums[key] = <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[key]==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[key]==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prerequisites.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(prerequisites[i][<span class="number">0</span>]==key)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dfs(prerequisites,nums,prerequisites[i][<span class="number">1</span>]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nums[key] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、Arraylist储存数组数据"><a href="#3、Arraylist储存数组数据" class="headerlink" title="3、Arraylist储存数组数据"></a>3、Arraylist储存数组数据</h3><p>将数据从二维数组中存放到arraylist中，这样在深搜递归时，arraylist的随机访问获取元素比遍历数组快。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish3</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; arrayLists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">        arrayLists.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prerequisites.length;i++)&#123;</span><br><span class="line">        arrayLists.get(prerequisites[i][<span class="number">0</span>]).add(prerequisites[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prerequisites.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[prerequisites[i][<span class="number">0</span>]]!=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dfs(arrayLists,nums,prerequisites[i][<span class="number">0</span>]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; arrayList,<span class="keyword">int</span>[] nums,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums[key]==<span class="number">0</span>)&#123;</span><br><span class="line">        nums[key] = <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[key]==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[key]==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> ls:arrayList.get(key))&#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfs(arrayList,nums,ls))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nums[key]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;难度：&lt;/strong&gt;&lt;font color=&quot;e1e1&quot;&gt;中等&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;这是该题的地址：&lt;a href=&quot;https://leetcode-cn.com/problems/course-schedule/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/course-schedule/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;现在你总共有 &lt;em&gt;n&lt;/em&gt; 门课需要选，记为 &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;n-1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: &lt;code&gt;[0,1]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: 2, [[1,0]] &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: 2, [[1,0],[0,1]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>岛屿的个数_200</title>
    <link href="http://yoursite.com/posts/numIslands%E5%B2%9B%E5%B1%BF%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>http://yoursite.com/posts/numIslands岛屿的个数/</id>
    <published>2019-04-01T13:32:38.000Z</published>
    <updated>2019-04-01T14:36:46.180Z</updated>
    
    <content type="html"><![CDATA[<p><strong>难度：</strong><font color="e1e1">中等</font></p><p>这是该题的地址：<a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-islands/</a></p><p>给定一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">11110</span><br><span class="line">11010</span><br><span class="line">11000</span><br><span class="line">00000</span><br><span class="line"></span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">11000</span><br><span class="line">11000</span><br><span class="line">00100</span><br><span class="line">00011</span><br><span class="line"></span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>这题其实是一套简单的图的遍历的题目，建立一个新的数组用于代表当前的点有无被访问过，然后对数组进行遍历，当是陆地是进行深搜，将每一块陆地都找出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (grid.length == <span class="number">0</span> || grid == <span class="keyword">null</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[][] init = <span class="keyword">new</span> <span class="keyword">int</span>[grid.length][grid[<span class="number">0</span>].length];</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; init.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; init[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (init[i][j] != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">'\u0001'</span>) &#123;</span><br><span class="line">                    num ++;</span><br><span class="line">                    nextLand(grid, i, j + <span class="number">1</span>, init);</span><br><span class="line">                    nextLand(grid, i + <span class="number">1</span>, j, init);</span><br><span class="line">                    nextLand(grid, i, j - <span class="number">1</span>, init);</span><br><span class="line">                    nextLand(grid, i - <span class="number">1</span>, j, init);</span><br><span class="line">                &#125;</span><br><span class="line">                init[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nextLand</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>[][] init)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> flag = left &gt;= <span class="number">0</span> &amp;&amp; right &gt;= <span class="number">0</span> &amp;&amp; left &lt; grid.length &amp;&amp; right &lt; grid[<span class="number">0</span>].length</span><br><span class="line">            &amp;&amp; grid[left][right] == <span class="string">'\u0001'</span> &amp;&amp; init[left][right] != <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        init[left][right] = <span class="number">1</span>;</span><br><span class="line">        nextLand(grid, left, right + <span class="number">1</span>, init);</span><br><span class="line">        nextLand(grid, left + <span class="number">1</span>, right, init);</span><br><span class="line">        nextLand(grid, left, right - <span class="number">1</span>, init);</span><br><span class="line">        nextLand(grid, left - <span class="number">1</span>, right, init);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;难度：&lt;/strong&gt;&lt;font color=&quot;e1e1&quot;&gt;中等&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;这是该题的地址：&lt;a href=&quot;https://leetcode-cn.com/problems/number-of-islands/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/number-of-islands/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一个由 &lt;code&gt;&amp;#39;1&amp;#39;&lt;/code&gt;（陆地）和 &lt;code&gt;&amp;#39;0&amp;#39;&lt;/code&gt;（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11110&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11010&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;00000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;00100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;00011&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>至少有K个重复字符的最长子串_395</title>
    <link href="http://yoursite.com/posts/solution-395/"/>
    <id>http://yoursite.com/posts/solution-395/</id>
    <published>2019-03-26T15:20:33.000Z</published>
    <updated>2019-03-27T08:09:18.199Z</updated>
    
    <content type="html"><![CDATA[<p><strong>难度：</strong><font color="e1e1">中等</font></p><p>这是本题的地址：<a href="https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/</a></p><p>找到给定字符串（由小写字符组成）中的最长子串 <strong>T</strong> ， 要求 <strong>T</strong> 中的每一字符出现次数都不少于 <em>k</em> 。输出 <strong>T</strong> 的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aaabb&quot;, k = 3</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">最长子串为 &quot;aaa&quot; ，其中 &apos;a&apos; 重复了 3 次。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;ababbc&quot;, k = 2</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">最长子串为 &quot;ababb&quot; ，其中 &apos;a&apos; 重复了 2 次， &apos;b&apos; 重复了 3 次。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>这题有一个思路点，使用长度为26的数组（代表26个小写字母）用于保存每个字符在字符串中出现了几次，如果有出现数小于k的字符，说明这个字符一定不能在字符串里。</p><p>这样就会出现就好像图里的这种情况。</p><p><img src="/posts/solution-395/picture.jpg" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestSubstring</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.length()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    HashMap&lt;Character,Integer&gt; hashMap = <span class="keyword">new</span> HashMap(<span class="number">26</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span>(hashMap.containsKey(c))&#123;</span><br><span class="line">            hashMap.put(c,hashMap.get(c)+<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            hashMap.put(c,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span>(hashMap.get(c)&lt;k)&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(longestSubstring(s.substring(<span class="number">0</span>,i),k),</span><br><span class="line">                    longestSubstring(s.substring(i+<span class="number">1</span>,s.length()),k));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码，第一遍历计算字符串的字符出现了几次，第二遍历计算当出现&lt;k的字符时，将字符串分开并重新计算字符串满足k最长字串，最后返回。看起来好像没什么问题，但是这段代码超时了。。。感觉也符合之前的思想，让我很不解。我感觉可能是出现了重复子问题的原因，如图的示例，找到最长子串aa 反而遍历了3次aa字符串 感觉有点麻烦？</p><p><img src="/posts/solution-395/picture2.jpg" alt=""></p><p>那么既然超时了，我们就应该优化一下代码。前面的不需要优化，就优化后面字符串的处理把。网上有这样的一种处理方法：通过两个指针begin和 end 来处理结点，每当遇到&lt;k的字符时，计算begin-》end的长度。和当前的长度比大小。但是我觉得和我之前的想法基本没差。。都是一样的想法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestSubstring2</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.length()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    HashMap&lt;Character,Integer&gt; hashMap = <span class="keyword">new</span> HashMap(<span class="number">26</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span>(hashMap.containsKey(c))&#123;</span><br><span class="line">            hashMap.put(c,hashMap.get(c)+<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            hashMap.put(c,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> fullString = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(Integer i:hashMap.values())&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;k)&#123;</span><br><span class="line">            fullString = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fullString)&#123;</span><br><span class="line">        <span class="keyword">return</span> s.length();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> result=<span class="number">0</span>,begin=<span class="number">0</span>,end;</span><br><span class="line">    <span class="keyword">for</span>(end=<span class="number">0</span>;end&lt;s.length();end++)&#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(end);</span><br><span class="line">        <span class="keyword">if</span>(hashMap.get(c)&lt;k)&#123;</span><br><span class="line">            result = Math.max(result,longestSubstring(s.substring(begin,end),k));</span><br><span class="line">            begin = end +<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(begin&lt;end)&#123;</span><br><span class="line">        result = Math.max(result,longestSubstring(s.substring(begin,end),k));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>没搞懂为什么这样会快很多，我觉得我们的方式都差不多，是我之前的代码遇到了重复子问题嘛。。。感觉也没有，难道是我的代码subStirng过多耗了性能？这是一个需要记录的问题。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;难度：&lt;/strong&gt;&lt;font color=&quot;e1e1&quot;&gt;中等&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;这是本题的地址：&lt;a href=&quot;https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;找到给定字符串（由小写字符组成）中的最长子串 &lt;strong&gt;T&lt;/strong&gt; ， 要求 &lt;strong&gt;T&lt;/strong&gt; 中的每一字符出现次数都不少于 &lt;em&gt;k&lt;/em&gt; 。输出 &lt;strong&gt;T&lt;/strong&gt; 的长度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;s = &amp;quot;aaabb&amp;quot;, k = 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;最长子串为 &amp;quot;aaa&amp;quot; ，其中 &amp;apos;a&amp;apos; 重复了 3 次。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;s = &amp;quot;ababbc&amp;quot;, k = 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;最长子串为 &amp;quot;ababb&amp;quot; ，其中 &amp;apos;a&amp;apos; 重复了 2 次， &amp;apos;b&amp;apos; 重复了 3 次。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>单词接龙_127</title>
    <link href="http://yoursite.com/posts/Solution-127/"/>
    <id>http://yoursite.com/posts/Solution-127/</id>
    <published>2019-03-25T14:08:57.000Z</published>
    <updated>2019-04-17T06:25:11.956Z</updated>
    
    <content type="html"><![CDATA[<p><strong>难度：</strong><font color="e1e1">中等</font></p><p>这是本题的地址：<a href="https://leetcode-cn.com/problems/word-ladder/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/word-ladder/</a></p><p>给定两个单词（<em>beginWord</em> 和 <em>endWord</em>）和一个字典，找到从 <em>beginWord</em> 到 <em>endWord</em> 的最短转换序列的长度。转换需遵循如下规则：</p><ol><li>每次转换只能改变一个字母。</li><li>转换过程中的中间单词必须是字典中的单词。</li></ol><p><strong>说明:</strong></p><ul><li>如果不存在这样的转换序列，返回 0。</li><li>所有单词具有相同的长度。</li><li>所有单词只由小写字母组成。</li><li>字典中不存在重复的单词。</li><li>你可以假设 <em>beginWord</em> 和 <em>endWord</em> 是非空的，且二者不相同。</li></ul><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">beginWord = &quot;hit&quot;,</span><br><span class="line">endWord = &quot;cog&quot;,</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line"></span><br><span class="line">输出: 5</span><br><span class="line"></span><br><span class="line">解释: 一个最短转换序列是 &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;,</span><br><span class="line">     返回它的长度 5。</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">beginWord = &quot;hit&quot;</span><br><span class="line">endWord = &quot;cog&quot;</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line"></span><br><span class="line">输出: 0</span><br><span class="line"></span><br><span class="line">解释: endWord &quot;cog&quot; 不在字典中，所以无法进行转换。</span><br></pre></td></tr></table></figure><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><h3 id="1、BFS"><a href="#1、BFS" class="headerlink" title="1、BFS"></a>1、BFS</h3><p>这题我本来的思路是这样的，使用BFS广度优先搜索，通过一个队列先保存beginword值，然后通过单个字母变化26次，遍历当前的字符串，匹配到wordlist中相应的项，然后把这些项加入队列，并将它们从list中remove。最终找到endword，通过这样广搜肯定能搜索到最短的路径。但值得一提的是，我超时了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//用一个hashSet代替list进行遍历，这样就不会超时了，真坑。</span></span><br><span class="line">    HashSet hashSet = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line">    <span class="keyword">if</span>(!hashSet.contains(endWord))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    ((LinkedList) queue).add(beginWord);</span><br><span class="line">    <span class="keyword">int</span> lengthA =<span class="number">0</span>,lengthB=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(queue.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">        String str = queue.poll();</span><br><span class="line">        <span class="keyword">if</span>(str.equals(endWord))&#123;</span><br><span class="line">            <span class="keyword">return</span> lengthA+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">            <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> j=<span class="string">'a'</span>;j&lt;=<span class="string">'z'</span>;j++)&#123;</span><br><span class="line">                chars[i] = j;</span><br><span class="line">                <span class="keyword">if</span>(hashSet.contains(<span class="keyword">new</span> String(chars)))&#123;</span><br><span class="line">                    queue.add(<span class="keyword">new</span> String(chars));</span><br><span class="line">                    hashSet.remove(<span class="keyword">new</span> String(chars));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lengthB--;</span><br><span class="line">        <span class="keyword">if</span>(lengthB==<span class="number">0</span>)&#123;</span><br><span class="line">            lengthB=queue.size();</span><br><span class="line">            lengthA++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n*26^str.length())</p><h3 id="2、双重BFS"><a href="#2、双重BFS" class="headerlink" title="2、双重BFS"></a>2、双重BFS</h3><p>通过看B站Up主的视频：<a href="https://www.bilibili.com/video/av38705526?from=search&amp;seid=16479832968747750696" target="_blank" rel="noopener">https://www.bilibili.com/video/av38705526?from=search&amp;seid=16479832968747750696</a></p><p>可以使用双重BFS这种更好的解法，就是通过两个队列，一个从beginword开始广搜，另一个从endword开始广搜，当他们相遇时，就是最短的路径，没有相遇就是0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength2</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">    HashSet hashSet = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line">    <span class="keyword">if</span>(!hashSet.contains(endWord))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    Queue&lt;String&gt; queue2 = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    queue.add(beginWord);</span><br><span class="line">    queue2.add(endWord);</span><br><span class="line">    <span class="keyword">int</span> step=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(queue.size()!=<span class="number">0</span>&amp;&amp;queue2.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">        step++;</span><br><span class="line">        <span class="keyword">if</span>(queue.size()&gt;queue2.size())&#123;</span><br><span class="line">            Queue q3 = <span class="keyword">new</span> LinkedList(queue);</span><br><span class="line">            queue = queue2;</span><br><span class="line">            queue2 =q3;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue queue1 = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        <span class="keyword">for</span>(String str:queue)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">                <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">char</span> j=<span class="string">'a'</span>;j&lt;=<span class="string">'z'</span>;j++)&#123;</span><br><span class="line">                    chars[i] = j;</span><br><span class="line">                    <span class="keyword">if</span>(queue2.contains(<span class="keyword">new</span> String(chars)))&#123;</span><br><span class="line">                        <span class="keyword">return</span> step+<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(hashSet.contains(<span class="keyword">new</span> String(chars)))&#123;</span><br><span class="line">                        queue1.add(<span class="keyword">new</span> String(chars));</span><br><span class="line">                        hashSet.remove(<span class="keyword">new</span> String(chars));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        queue = queue1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n*26^(str.lenght()/2))</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然因为直接就用list做操作导致了BFS的超时,但是通过这个我回忆了一下，arraylist的remove确实很耗时，每次删除都会把后面的往前复制一遍。</p><p>没有想到双BFS的操作，以后要善用这些操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;难度：&lt;/strong&gt;&lt;font color=&quot;e1e1&quot;&gt;中等&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;这是本题的地址：&lt;a href=&quot;https://leetcode-cn.com/problems/word-ladder/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/word-ladder/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定两个单词（&lt;em&gt;beginWord&lt;/em&gt; 和 &lt;em&gt;endWord&lt;/em&gt;）和一个字典，找到从 &lt;em&gt;beginWord&lt;/em&gt; 到 &lt;em&gt;endWord&lt;/em&gt; 的最短转换序列的长度。转换需遵循如下规则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每次转换只能改变一个字母。&lt;/li&gt;
&lt;li&gt;转换过程中的中间单词必须是字典中的单词。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果不存在这样的转换序列，返回 0。&lt;/li&gt;
&lt;li&gt;所有单词具有相同的长度。&lt;/li&gt;
&lt;li&gt;所有单词只由小写字母组成。&lt;/li&gt;
&lt;li&gt;字典中不存在重复的单词。&lt;/li&gt;
&lt;li&gt;你可以假设 &lt;em&gt;beginWord&lt;/em&gt; 和 &lt;em&gt;endWord&lt;/em&gt; 是非空的，且二者不相同。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;beginWord = &amp;quot;hit&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;endWord = &amp;quot;cog&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;wordList = [&amp;quot;hot&amp;quot;,&amp;quot;dot&amp;quot;,&amp;quot;dog&amp;quot;,&amp;quot;lot&amp;quot;,&amp;quot;log&amp;quot;,&amp;quot;cog&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 一个最短转换序列是 &amp;quot;hit&amp;quot; -&amp;gt; &amp;quot;hot&amp;quot; -&amp;gt; &amp;quot;dot&amp;quot; -&amp;gt; &amp;quot;dog&amp;quot; -&amp;gt; &amp;quot;cog&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     返回它的长度 5。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="双向BFS" scheme="http://yoursite.com/tags/%E5%8F%8C%E5%90%91BFS/"/>
    
  </entry>
  
  <entry>
    <title>乘积最大子序列_152</title>
    <link href="http://yoursite.com/posts/Solution-152/"/>
    <id>http://yoursite.com/posts/Solution-152/</id>
    <published>2019-03-21T14:06:44.000Z</published>
    <updated>2019-04-17T06:27:07.506Z</updated>
    
    <content type="html"><![CDATA[<p><strong>难度：</strong><font color="e1e1">中等</font></p><p>这是该题的地址：<a href="https://leetcode-cn.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-product-subarray/</a></p><p>给定一个整数数组 <code>nums</code> ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,3,-2,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 子数组 [2,3] 有最大乘积 6。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [-2,0,-1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>有想到用动态规划来做，但是没想到使用这种方式。。。保留到前个字符的最大正数和最小负数。这样无论当前数是正数或是负数都能求到最大的乘积。通过动态规划就能得到最大的值了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> max = nums[<span class="number">0</span>], min = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            max = nums[i] &gt; nums[i] * max ? nums[i] : nums[i] * max;</span><br><span class="line">            min = nums[i] &lt; nums[i] * min ? nums[i] : nums[i] * min;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = max;</span><br><span class="line">            max = nums[i] &gt; min * nums[i] ? nums[i] : min * nums[i];</span><br><span class="line">            min = nums[i] &lt; temp * nums[i] ? nums[i] : temp * nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] = max &gt; dp[i - <span class="number">1</span>] ? max : dp[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[nums.length-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;难度：&lt;/strong&gt;&lt;font color=&quot;e1e1&quot;&gt;中等&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;这是该题的地址：&lt;a href=&quot;https://leetcode-cn.com/problems/maximum-product-subarray/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/maximum-product-subarray/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [2,3,-2,4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 子数组 [2,3] 有最大乘积 6。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [-2,0,-1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>盛最多水的容器_11</title>
    <link href="http://yoursite.com/posts/solution-11/"/>
    <id>http://yoursite.com/posts/solution-11/</id>
    <published>2019-03-18T13:02:28.000Z</published>
    <updated>2019-04-17T06:23:53.982Z</updated>
    
    <content type="html"><![CDATA[<p><strong>难度：</strong><font color="e1e1">中等</font>（感觉没有中等难度啊）</p><p>这是该题的地址：<a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/container-with-most-water/</a></p><p>给定 <em>n</em> 个非负整数 <em>a</em>1，<em>a</em>2，…，<em>a</em>n，每个数代表坐标中的一个点 (<em>i</em>, <em>ai</em>) 。在坐标内画 <em>n</em> 条垂直线，垂直线 <em>i</em> 的两个端点分别为 (<em>i</em>, <em>ai</em>) 和 (<em>i</em>, 0)。找出其中的两条线，使得它们与 <em>x</em> 轴共同构成的容器可以容纳最多的水。</p><p><strong>说明：</strong>你不能倾斜容器，且 <em>n</em> 的值至少为 2。</p><p><img src="/posts/solution-11/question_11.jpg" alt=""></p><p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p> <a id="more"></a><p><strong>示例:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">7</span>]</span><br><span class="line">输出: <span class="number">49</span></span><br></pre></td></tr></table></figure><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>这个感觉没有中等难度呀。使用双指针的做法，头尾两个指针，得出当前的区域大小，因为区域的大小取决于更小的那一个指针，这时候就要把我们的底线抬高。所以当左指针比右指针小的时候，左指针往右移，右指针同理。相遇的时候就跳出循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left =<span class="number">0</span>,right =height.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> max =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">int</span> min = height[right]&gt;height[left]?height[left]:height[right];</span><br><span class="line">        <span class="keyword">int</span> area = (right-left) * min;</span><br><span class="line">        max = max&gt;area?max:area;</span><br><span class="line">        <span class="keyword">if</span>(height[left]==min)&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;难度：&lt;/strong&gt;&lt;font color=&quot;e1e1&quot;&gt;中等&lt;/font&gt;（感觉没有中等难度啊）&lt;/p&gt;
&lt;p&gt;这是该题的地址：&lt;a href=&quot;https://leetcode-cn.com/problems/container-with-most-water/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/container-with-most-water/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定 &lt;em&gt;n&lt;/em&gt; 个非负整数 &lt;em&gt;a&lt;/em&gt;1，&lt;em&gt;a&lt;/em&gt;2，…，&lt;em&gt;a&lt;/em&gt;n，每个数代表坐标中的一个点 (&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;ai&lt;/em&gt;) 。在坐标内画 &lt;em&gt;n&lt;/em&gt; 条垂直线，垂直线 &lt;em&gt;i&lt;/em&gt; 的两个端点分别为 (&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;ai&lt;/em&gt;) 和 (&lt;em&gt;i&lt;/em&gt;, 0)。找出其中的两条线，使得它们与 &lt;em&gt;x&lt;/em&gt; 轴共同构成的容器可以容纳最多的水。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;你不能倾斜容器，且 &lt;em&gt;n&lt;/em&gt; 的值至少为 2。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/solution-11/question_11.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="双指针" scheme="http://yoursite.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>字母大小写全排列_784</title>
    <link href="http://yoursite.com/posts/letterCasePermutation-784/"/>
    <id>http://yoursite.com/posts/letterCasePermutation-784/</id>
    <published>2019-03-15T09:44:53.000Z</published>
    <updated>2019-04-09T09:09:13.873Z</updated>
    
    <content type="html"><![CDATA[<p><strong>难度：</strong><font color="green">简单</font></p><p>给定一个字符串<code>S</code>，通过将字符串<code>S</code>中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line">输入: S = &quot;a1b2&quot;</span><br><span class="line">输出: [&quot;a1b2&quot;, &quot;a1B2&quot;, &quot;A1b2&quot;, &quot;A1B2&quot;]</span><br><span class="line"></span><br><span class="line">输入: S = &quot;3z4&quot;</span><br><span class="line">输出: [&quot;3z4&quot;, &quot;3Z4&quot;]</span><br><span class="line"></span><br><span class="line">输入: S = &quot;12345&quot;</span><br><span class="line">输出: [&quot;12345&quot;]</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>注意：</strong></p><ul><li><code>S</code> 的长度不超过<code>12</code>。</li><li><code>S</code> 仅由数字和字母组成。</li></ul><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>这题其实不难，将他想象成一颗树，每当是字母的时候分叉，不是字母的时候就不分叉。把所有子树列出来就是每个的字符串了。下面是通过深搜来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCasePermutation</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    list.add(S);</span><br><span class="line">    tolist(list, <span class="number">0</span>, S);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tolist</span><span class="params">(List&lt;String&gt; list, <span class="keyword">int</span> i, String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == s.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Boolean isTrue = (s.charAt(i) &gt;= <span class="string">'a'</span> &amp;&amp; s.charAt(i) &lt;= <span class="string">'z'</span>) || (s.charAt(i) &gt;= <span class="string">'A'</span> &amp;&amp; s.charAt(i) &lt;= <span class="string">'Z'</span>);</span><br><span class="line">    <span class="keyword">if</span> (isTrue) &#123;</span><br><span class="line">        String s1;</span><br><span class="line">        <span class="keyword">if</span> (Character.isLowerCase(s.charAt(i))) &#123;</span><br><span class="line">            s1 = s.substring(<span class="number">0</span>, i) + Character.toUpperCase(s.charAt(i)) + s.substring(i + <span class="number">1</span>, s.length());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            s1 = s.substring(<span class="number">0</span>, i) + Character.toLowerCase(s.charAt(i)) + s.substring(i + <span class="number">1</span>, s.length());</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(s1);</span><br><span class="line">        tolist(list, i + <span class="number">1</span>, s);</span><br><span class="line">        tolist(list, i + <span class="number">1</span>, s1);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tolist(list, i + <span class="number">1</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;难度：&lt;/strong&gt;&lt;font color=&quot;green&quot;&gt;简单&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;给定一个字符串&lt;code&gt;S&lt;/code&gt;，通过将字符串&lt;code&gt;S&lt;/code&gt;中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: S = &amp;quot;a1b2&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [&amp;quot;a1b2&amp;quot;, &amp;quot;a1B2&amp;quot;, &amp;quot;A1b2&amp;quot;, &amp;quot;A1B2&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: S = &amp;quot;3z4&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [&amp;quot;3z4&amp;quot;, &amp;quot;3Z4&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: S = &amp;quot;12345&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [&amp;quot;12345&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="回溯算法" scheme="http://yoursite.com/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>括号生成_22</title>
    <link href="http://yoursite.com/posts/generateParenthesis-22/"/>
    <id>http://yoursite.com/posts/generateParenthesis-22/</id>
    <published>2019-03-07T13:22:33.000Z</published>
    <updated>2019-03-07T14:10:46.921Z</updated>
    
    <content type="html"><![CDATA[<p><strong>难度：</strong><font color="e1e1">中等</font></p><p>这是该题的地址：<a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/generate-parentheses/</a></p><p>给出 <em>n</em> 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且<strong>有效的</strong>括号组合。</p><p>例如，给出 <em>n</em> = 3，生成结果为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  "((()))",</span><br><span class="line">  "(()())",</span><br><span class="line">  "(())()",</span><br><span class="line">  "()(())",</span><br><span class="line">  "()()()"</span><br><span class="line">]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>这题是我做回溯法的第一题，还是蛮有回溯的意思的 我觉得。</p><p>首先回溯法我觉得第一个特点就是将解答视为一个树，然后对它进行深度优先搜索。</p><p>然后通过剪枝，当违反条件的时候，该结点的子结点下的树都不进行考虑。来减少时间复杂度。</p><p>请看图！：</p><p><img src="/posts/generateParenthesis-22/picture.png" alt="1551965583784"></p><p>根据题干，第一个必须是左括号才能满足有效的括号组合。那么它的下一位就有两种选择方案，分别是左括号或者是右括号，这样进行深度优先搜索。如图：当进行到不符合条件的结点 ”（）） “ 这样是不符合的，那么就可以减掉该结点及其子节点，并返回上一层继续进行深度优先搜索。直到获取到所有答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    List list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    backtarcking(list,<span class="string">""</span>,n,n);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtarcking</span><span class="params">(List list,String s,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&gt;right)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left==<span class="number">0</span>&amp;&amp;right==<span class="number">0</span>)&#123;</span><br><span class="line">        list.add(s);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left!=<span class="number">0</span>)&#123;</span><br><span class="line">        backtarcking(list,s+<span class="string">"("</span>,left-<span class="number">1</span>,right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(right!=<span class="number">0</span>)&#123;</span><br><span class="line">        backtarcking(list,s+<span class="string">")"</span>,left,right-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>做了这道题之后对回溯法有了更加深刻的理解，继续加油！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;难度：&lt;/strong&gt;&lt;font color=&quot;e1e1&quot;&gt;中等&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;这是该题的地址：&lt;a href=&quot;https://leetcode-cn.com/problems/generate-parentheses/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/generate-parentheses/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给出 &lt;em&gt;n&lt;/em&gt; 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且&lt;strong&gt;有效的&lt;/strong&gt;括号组合。&lt;/p&gt;
&lt;p&gt;例如，给出 &lt;em&gt;n&lt;/em&gt; = 3，生成结果为：&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &quot;((()))&quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &quot;(()())&quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &quot;(())()&quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &quot;()(())&quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &quot;()()()&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="回溯法" scheme="http://yoursite.com/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>环形链表 II_142</title>
    <link href="http://yoursite.com/posts/detectCycle-142/"/>
    <id>http://yoursite.com/posts/detectCycle-142/</id>
    <published>2019-03-04T14:20:04.000Z</published>
    <updated>2019-03-04T15:02:23.345Z</updated>
    
    <content type="html"><![CDATA[<p><strong>难度：</strong><font color="e1e1">中等</font></p><p>这是本题的地址：<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-cycle-ii/</a></p><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code>。</p><p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。</p><p><strong>说明：</strong>不允许修改给定的链表。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：tail connects to node index 1</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p><img src="/posts/detectCycle-142/circularlinkedlist.png" alt="img"></p> <a id="more"></a><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：tail connects to node index 0</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p><img src="/posts/detectCycle-142/circularlinkedlist_test2.png" alt="img"></p><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：no cycle</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><p><img src="/posts/detectCycle-142/circularlinkedlist_test3.png" alt="img"></p><p><strong>进阶：</strong><br>你是否可以不用额外空间解决此题？</p><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>这题是<a href="https://jasonhejiachen.github.io/posts/hasCycle-141/" target="_blank" rel="noopener">环形链表_141</a>的加强版，他在找到循环的基础上增加了找到循环的入口。看似不难，其实是需要掌握一个诀窍的，通过网上查看别人的思路，大部分人的思路都是和下图一般。</p><p><img src="/posts/detectCycle-142/picture.png" alt=""></p><p>x 是快指针和慢指针出发的位置，假设 y点是入口点，z点是快慢指针的相遇点。我们可以得出下面三个条件。</p><ul><li><p>那么从初始点到入口点的距离假设为a，b为慢指针在循环中走的距离，那么我们可以假设出出b走的路程为a+b。</p></li><li><p>那么因为在z点进行相遇，所以快指针走的距离我们可以假设为 a+b+c+b（绕了一圈又走了b距离到z点相遇）。</p></li><li>还有最后一个条件，就是快指针走的速度是慢指针的2倍，也就是说 (a+b)*2 == a+b+c+b。</li></ul><p>根据这三个条件，我们可以得出一个结论就是 a == c。</p><p>那么 a == c有什么用呢，我们可以从图上发现，a的距离是 x 点到 y 点，而c是z点到y点的距离。z点又是快慢指针相遇的点。那么这时候我们可以发现，从z点往y点走的指针和从x点往y点走的指针最终会在y点相遇。而y点就是我们题目所需要的答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode fast = head;</span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next!=<span class="keyword">null</span>) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        <span class="keyword">if</span>(fast==slow)&#123;</span><br><span class="line">            ListNode newNode = head;</span><br><span class="line">            <span class="keyword">while</span>(slow!=newNode)&#123;</span><br><span class="line">                newNode = newNode.next;</span><br><span class="line">                slow = slow.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> newNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;难度：&lt;/strong&gt;&lt;font color=&quot;e1e1&quot;&gt;中等&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;这是本题的地址：&lt;a href=&quot;https://leetcode-cn.com/problems/linked-list-cycle-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/linked-list-cycle-ii/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 &lt;code&gt;null&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;为了表示给定链表中的环，我们使用整数 &lt;code&gt;pos&lt;/code&gt; 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 &lt;code&gt;pos&lt;/code&gt; 是 &lt;code&gt;-1&lt;/code&gt;，则在该链表中没有环。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;不允许修改给定的链表。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：head = [3,2,0,-4], pos = 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：tail connects to node index 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：链表中有一个环，其尾部连接到第二个节点。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;/posts/detectCycle-142/circularlinkedlist.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="双指针" scheme="http://yoursite.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>买卖股票的最佳时机 II_122</title>
    <link href="http://yoursite.com/posts/maxProfit-122/"/>
    <id>http://yoursite.com/posts/maxProfit-122/</id>
    <published>2019-03-01T05:48:53.000Z</published>
    <updated>2019-03-01T06:52:35.436Z</updated>
    
    <content type="html"><![CDATA[<p><strong>难度：</strong><font color="green">简单</font></p><p>该题的地址：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/</a></p><p>给定一个数组，它的第 <em>i</em> 个元素是一支给定股票第 <em>i</em> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。</span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>这题与 买股票的 最佳时机 这题是类似的，不过这题有一个不同就在于 尽可能完成更多交易来获取最多利润，而不是只卖一次获取最大利润了。</p><ul><li>我们可以使用 三个int 代表最低值价钱(min)、最高值价钱(max)和利润(value)，每当过了一天，如果当天的价格比最大价格大，那么最大价格就变为当天的价格。如果比最大价格小，那么就说明在上次最大价格的时候就可以卖了，利润=最高价格-最小价格。然后再把最小价格和最高价格定为当天的价格。</li><li>上述又会出现一个问题，假如是一直升的话，岂不是永远都不会判断了？，这时候我们需要在遍历完之后加一个判断，当max大于min的时候，value要加上（max-min）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(prices.length&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> min = prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> max = prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(max&gt;prices[i])&#123;</span><br><span class="line">            value+=(max-min);</span><br><span class="line">            min = prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">        max = prices[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(max &gt; min)&#123;</span><br><span class="line">         value+=(max-min);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实还有另一种思路，就是每当当天价格比最大价格大的时候，就增加利润，当小的时候，就不增加，并且重新定义最大最小价格。最后也能得出最大的利润。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;难度：&lt;/strong&gt;&lt;font color=&quot;green&quot;&gt;简单&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;该题的地址：&lt;a href=&quot;https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一个数组，它的第 &lt;em&gt;i&lt;/em&gt; 个元素是一支给定股票第 &lt;em&gt;i&lt;/em&gt; 天的价格。&lt;/p&gt;
&lt;p&gt;设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [7,1,5,3,6,4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="贪心算法" scheme="http://yoursite.com/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>买卖股票的最佳时机_121</title>
    <link href="http://yoursite.com/posts/maxProfit-121/"/>
    <id>http://yoursite.com/posts/maxProfit-121/</id>
    <published>2019-02-28T12:22:29.000Z</published>
    <updated>2019-02-28T14:41:26.224Z</updated>
    
    <content type="html"><![CDATA[<p><strong>难度：</strong><font color="green">简单</font></p><p>这是本题的地址：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/</a></p><p>给定一个数组，它的第 <em>i</em> 个元素是一支给定股票第 <em>i</em> 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p><p>注意你不能在买入股票前卖出股票。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>本题我觉得可以使用动态规划来做，通过动态规划得出第n天的最优解。但是做到最后感觉不使用动态规划也是一样的。。。</p><p>本题有一个特别的地方，它需要有两个点，一个代表当前的点，一个代表最小的点（在此点买入）。。 这时候可以用当前的点减去最小的点，这样得到最大的结果就是最大利润。</p><p>如下有两种写法：我觉得两种写法是一样的，时间复杂度也是O(n) 空间复杂度也是O(1),不知道为啥我跑的就比他的慢哈哈。</p><h3 id="我的写法（稍丑）"><a href="#我的写法（稍丑）" class="headerlink" title="我的写法（稍丑）"></a>我的写法（稍丑）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(prices.length&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] opt = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line">    <span class="comment">//我将opt[0] 定义为当前在prices数组中最小的点。（其实这句话没意义，因为它一开始就是0哈哈）</span></span><br><span class="line">    opt[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//对下个结点进行对比，哪个值更小则赋给opt[0];</span></span><br><span class="line">    opt[<span class="number">0</span>] = prices[<span class="number">1</span>]&lt;prices[opt[<span class="number">0</span>]]?<span class="number">1</span>:opt[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//假如当前结点的值比最小结点的大，则赋给当前结点利润（因为opt[0]代表最小值，所以1需要拿出来）。</span></span><br><span class="line">    opt[<span class="number">1</span>] = Math.max(prices[<span class="number">1</span>]-prices[opt[<span class="number">0</span>]],opt[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;prices.length)&#123;</span><br><span class="line">        opt[<span class="number">0</span>] = prices[i]&lt;prices[opt[<span class="number">0</span>]]?i:opt[<span class="number">0</span>];</span><br><span class="line">        opt[i] = Math.max(Math.max(prices[i]-prices[opt[<span class="number">0</span>]],opt[i]),opt[i-<span class="number">1</span>]);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> opt[prices.length-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="官方写法（优雅）"><a href="#官方写法（优雅）" class="headerlink" title="官方写法（优雅）"></a>官方写法（优雅）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit2</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(prices.length&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE,max=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices[i]&lt;min)&#123;</span><br><span class="line">            min = prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((prices[i]-min)&gt;max)&#123;</span><br><span class="line">            max = prices[i]-min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;难度：&lt;/strong&gt;&lt;font color=&quot;green&quot;&gt;简单&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;这是本题的地址：&lt;a href=&quot;https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一个数组，它的第 &lt;em&gt;i&lt;/em&gt; 个元素是一支给定股票第 &lt;em&gt;i&lt;/em&gt; 天的价格。&lt;/p&gt;
&lt;p&gt;如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。&lt;/p&gt;
&lt;p&gt;注意你不能在买入股票前卖出股票。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [7,1,5,3,6,4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [7,6,4,3,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>环形链表_141</title>
    <link href="http://yoursite.com/posts/hasCycle-141/"/>
    <id>http://yoursite.com/posts/hasCycle-141/</id>
    <published>2019-02-27T15:43:36.000Z</published>
    <updated>2019-03-04T15:02:28.782Z</updated>
    
    <content type="html"><![CDATA[<p><strong>难度：</strong><font color="green">简单</font></p><p>这是本题的地址：<a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/linked-list-cycle/</a></p><p>给定一个链表，判断链表中是否有环。</p><p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p><img src="/posts/hasCycle-141/circularlinkedlist.png" alt="img"></p><a id="more"></a><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p><img src="/posts/hasCycle-141/circularlinkedlist_test2.png" alt="img"></p><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：false</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><p><img src="/posts/hasCycle-141/circularlinkedlist_test3.png" alt="img"></p><p><strong>进阶：</strong></p><p>你能用 <em>O(1)</em>（即，常量）内存解决此问题吗？</p><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>这题一开始觉得有点无从入手，而且题目给的测试数据和输入数据也有一些不同。不过在细细的看一遍，我们可以发现其中的诀窍。</p><ol><li>因为题目的输入是一个ListNode 结点。我们可以通过这个发现，当没有“园”（循环）的时候，肯定有一个结点的next为空。所以我们可以以这个next为空作为我们遍历结点的终点。</li><li>因为可能有出现园的情况，我们可以用一个集合装下我们已遍历过的结点，然后每当到下一个结点的时候判断这个结点是否已经出现过了，如果没有则将这个结点放入集合中，如果有则返回true</li></ol><p>通过这两点我们就可以得到一个正确的题解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        ArrayList&lt;ListNode&gt; ar = new ArrayList&lt;&gt;(); 一开始我是用的是arraylist也可以实现</span></span><br><span class="line">        Set&lt;ListNode&gt; ar = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ar.contains(head))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ar.add(head);</span><br><span class="line">        &#125;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><p>题目有进阶解法，使用O(1)的内存解决此问题。</p><p>根据官方的题解：可以使用快慢指针这种形式。快指针移动两步慢指针就只移动一步。</p><ol><li>假如有一个圈的话，无论是跑得快还是跑的慢，他们都会在某个点相遇，这时候我们就可以返回false了。</li><li>快指针移动两步可以更快到达next=null的点，从而return false。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle2</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span>&amp;&amp;slow!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            <span class="keyword">if</span>(fast==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span>(fast==slow)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这题做出第一个解并不难，进阶做法让我们更理解快慢指针的应用！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;难度：&lt;/strong&gt;&lt;font color=&quot;green&quot;&gt;简单&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;这是本题的地址：&lt;a href=&quot;https://leetcode-cn.com/problems/linked-list-cycle/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/linked-list-cycle/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一个链表，判断链表中是否有环。&lt;/p&gt;
&lt;p&gt;为了表示给定链表中的环，我们使用整数 &lt;code&gt;pos&lt;/code&gt; 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 &lt;code&gt;pos&lt;/code&gt; 是 &lt;code&gt;-1&lt;/code&gt;，则在该链表中没有环。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：head = [3,2,0,-4], pos = 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：链表中有一个环，其尾部连接到第二个节点。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&quot;/posts/hasCycle-141/circularlinkedlist.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="双指针" scheme="http://yoursite.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>在排序数组中查找元素的第一个和最后一个位置_34</title>
    <link href="http://yoursite.com/posts/searchRange-34/"/>
    <id>http://yoursite.com/posts/searchRange-34/</id>
    <published>2019-02-24T13:50:43.000Z</published>
    <updated>2019-02-24T14:31:28.827Z</updated>
    
    <content type="html"><![CDATA[<p><strong>难度：</strong><font color="E1E1">中等</font></p><p>这是本题的地址：<a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/</a></p><p>给定一个按照升序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。找出给定目标值在数组中的开始位置和结束位置。</p><p>你的算法时间复杂度必须是 <em>O</em>(log <em>n</em>) 级别。</p><p>如果数组中不存在目标值，返回 <code>[-1, -1]</code>。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出: [3,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">输出: [-1,-1]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>因为题干中说了复杂度必须是O(logN)级别，所以我们可以联想到使用二分查找来做这道题目。</p><h3 id="一、二分查找"><a href="#一、二分查找" class="headerlink" title="一、二分查找"></a>一、二分查找</h3><p>通过题目我们可以发现，二分查找可以很快的确定target所在的区间。但是这里有一个小问题，当 mid 中间点和target相等时，你不仅要往左搜索 还要往右搜索。解决了这个就相当于解决了这个问题。</p><p><strong>第一种写法（我的写法）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> start=-<span class="number">1</span>,end=-<span class="number">1</span>;<span class="comment">//定义类变量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>,right = nums.length;</span><br><span class="line">    digui(left,right,nums,target);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;start,end&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">digui</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;=right)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">            <span class="keyword">if</span>(start ==-<span class="number">1</span>)&#123;</span><br><span class="line">                start = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(start&gt;mid)&#123;</span><br><span class="line">                start = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(mid&gt;end)&#123;</span><br><span class="line">                end = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果是相同，则双方向都进行二分查找</span></span><br><span class="line">            digui(left,mid,nums,target);</span><br><span class="line">            digui(mid+<span class="number">1</span>,right,nums,target);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">            digui(mid+<span class="number">1</span>,right,nums,target);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            digui(left,mid,nums,target);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二种写法：不使用类变量</strong></p><p>它是先定位第一个target的位置，然后再散发查找。可能是测试用例的问题，这段代码跑的比我的快，但是后面的散发查找肯定也使用二分查找是更快的。代码的时间复杂度也是O(logN)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] searchRange3(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">int</span> left =<span class="number">0</span>,right = nums.length,mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        <span class="keyword">int</span> i = mid;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=target)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> j = mid;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]!=target)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i+<span class="number">1</span>,j-<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、双指针"><a href="#二、双指针" class="headerlink" title="二、双指针"></a>二、双指针</h3><p>看到题目的评论中有人说使用双指针。</p><p>很显然，在这道题中双指针并不会让你更快，时间复杂度是O(N/2)，不符合题目要求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] searchRange2(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">int</span> left =<span class="number">0</span>,right = nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[left]!=target&amp;&amp;nums[right]!=target)&#123;</span><br><span class="line">            left++;right--;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[left]==target&amp;&amp;nums[right]==target)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left,right&#125;;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[left]==target)&#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[right]==target)&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>二分搜索不是只有说使用模板的 while() 这样递归才行。使用递归函数递归也是一个好方法！做法有千万种，理解了思想最重要</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;难度：&lt;/strong&gt;&lt;font color=&quot;E1E1&quot;&gt;中等&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;这是本题的地址：&lt;a href=&quot;https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一个按照升序排列的整数数组 &lt;code&gt;nums&lt;/code&gt;，和一个目标值 &lt;code&gt;target&lt;/code&gt;。找出给定目标值在数组中的开始位置和结束位置。&lt;/p&gt;
&lt;p&gt;你的算法时间复杂度必须是 &lt;em&gt;O&lt;/em&gt;(log &lt;em&gt;n&lt;/em&gt;) 级别。&lt;/p&gt;
&lt;p&gt;如果数组中不存在目标值，返回 &lt;code&gt;[-1, -1]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: nums = [5,7,7,8,8,10], target = 8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [3,4]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: nums = [5,7,7,8,8,10], target = 6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [-1,-1]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="二分查找" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
</feed>
