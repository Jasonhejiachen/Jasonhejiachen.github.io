<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>何嘉晨的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-02-14T09:04:33.543Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>何嘉晨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Queue队列-java源码了解</title>
    <link href="http://yoursite.com/2019/02/14/Queue%E9%98%9F%E5%88%97-java/"/>
    <id>http://yoursite.com/2019/02/14/Queue队列-java/</id>
    <published>2019-02-14T08:33:29.000Z</published>
    <updated>2019-02-14T09:04:33.543Z</updated>
    
    <content type="html"><![CDATA[<p>ok 因为在题目里面遇到了Queue，所以我就来了解一下Queue这个接口的功效吧！</p><p>来看看里面的注释是怎么说这个类的，英语四级启动！：</p><p><img src="/2019/02/14/Queue队列-java/img/Queue.jpg" alt=""></p><p>它说这是一个围在处理钱保存元素和设计的集合。基于util类库的操作，队列支持 额外的 插入、 提取 检查 操作。</p><a id="more"></a><p>每一个方法都存在两个形式：</p><p>1）在操作失败时抛出一个异常。</p><p>2）返回一个特殊值 null 或 false （取决于你的操作）。</p><p>第二种形式 在 插入操作中被特别设计成容量受限的情况。在大多数的情况下，插入操作不能出错。</p><h2 id="来看看Queue接口的源码"><a href="#来看看Queue接口的源码" class="headerlink" title="来看看Queue接口的源码"></a>来看看Queue接口的源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Queue从jdk1.5出现  继承Collection这个接口，方法一共有六个：</p><h3 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br></pre></td></tr></table></figure><p>将指定的元素插入此队列，成功则返回true，如果没有足够的空间 则抛出一个异常。</p><p>可能的异常有4个IllegalStateException、ClassCastException、NullPointerException、IllegalArgumentException</p><h3 id="offer方法"><a href="#offer方法" class="headerlink" title="offer方法"></a>offer方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;</span><br></pre></td></tr></table></figure><p>这个方法和add方法一样时将元素插入队列中的，不同之处在于，当队列因为没有足够空间插入元素时，这个元素会返回false而不是抛出IllegalStateException异常。</p><p>可能的异常有3个ClassCastException、NullPointerException、IllegalArgumentException。</p><h3 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">remove</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>检索并删除此队列的头部元素，这种方法在队列为空时会抛出异常 NoSuchElementException。</p><h3 id="poll方法"><a href="#poll方法" class="headerlink" title="poll方法"></a>poll方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">poll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>这个方法和remove方法一样，不同之处在于在队列为空时 poll是返回一个null而不是抛出异常。</p><h3 id="element方法"><a href="#element方法" class="headerlink" title="element方法"></a>element方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">element</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>检索但不删除队列的头部，如果队列为空则会抛出一个异常 NoSuchElementException。</p><h3 id="peek方法"><a href="#peek方法" class="headerlink" title="peek方法"></a>peek方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">peek</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>这个方法和element方法一样，不同之处在于如果队列位空，返回的是null而不是抛出异常。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ok 因为在题目里面遇到了Queue，所以我就来了解一下Queue这个接口的功效吧！&lt;/p&gt;
&lt;p&gt;来看看里面的注释是怎么说这个类的，英语四级启动！：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/02/14/Queue队列-java/img/Queue.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;它说这是一个围在处理钱保存元素和设计的集合。基于util类库的操作，队列支持 额外的 插入、 提取 检查 操作。&lt;/p&gt;
    
    </summary>
    
      <category term="ThinkinJava" scheme="http://yoursite.com/categories/ThinkinJava/"/>
    
    
      <category term="Java源码" scheme="http://yoursite.com/tags/Java%E6%BA%90%E7%A0%81/"/>
    
      <category term="Queue" scheme="http://yoursite.com/tags/Queue/"/>
    
  </entry>
  
  <entry>
    <title>symmetric-tree(对称二叉树)_101</title>
    <link href="http://yoursite.com/2019/02/14/isSymmetric-101/"/>
    <id>http://yoursite.com/2019/02/14/isSymmetric-101/</id>
    <published>2019-02-14T03:37:21.000Z</published>
    <updated>2019-02-14T06:39:18.636Z</updated>
    
    <content type="html"><![CDATA[<p>这是本题的地址：<a href="https://leetcode-cn.com/problems/symmetric-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/symmetric-tree/</a></p><p>给定一个二叉树，检查它是否是镜像对称的。</p><p>例如，二叉树 <code>[1,2,2,3,4,4,3]</code> 是对称的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line"> / \ / \</span><br><span class="line">3  4 4  3</span><br></pre></td></tr></table></figure><p>但是下面这个 <code>[1,2,2,null,3,null,3]</code> 则不是镜像对称的:</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">1</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">2</span>   <span class="number">2</span></span><br><span class="line"> \   \</span><br><span class="line"> <span class="number">3</span>    <span class="number">3</span></span><br></pre></td></tr></table></figure><p>题目给出的树的结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> val;</span><br><span class="line">      TreeNode left;</span><br><span class="line">      TreeNode right;</span><br><span class="line">      TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>这题让我思路头大，因为之前还没有做过树的题目，深搜广搜虽然了解大概是怎么样的做法却没有实际使用上。</p><p>这道题一开始我是想着如果要证明它们是镜像对称的，那么树的left的left节点 应该和right的right节点相同，left的right节点应该和right的left节点相同。</p><p>那么每当 left.val 和 right.val 的值相等的时候。</p><p>就进行递归digui(left.left,right.right) 和 digui(left.right,right.left) 这两个递归。这里要注意的就是一开始是使用两个root进入从而避免了一开始就要写left和right。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> digui(root,root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">digui</span><span class="params">(TreeNode t1,TreeNode t2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t1==<span class="keyword">null</span>&amp;&amp;t2==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(t1==<span class="keyword">null</span>||t2==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>(t1.val==t2.val) &amp;&amp; digui(t1.left,t2.right) &amp;&amp; digui(t1.right,t2.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="官方思路"><a href="#官方思路" class="headerlink" title="官方思路"></a>官方思路</h2><p>除了第一个递归之外，官方还写出了迭代的思路，我来试一试。既然这里的代码用到了Queue(队列)，我就去对自己科普了一下java的<a href="">Queue</a></p><p>代码可以忽略，列一下里面觉得有用的几个点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; ls = <span class="keyword">new</span> &lt;TreeNode&gt;LinkedList();</span><br><span class="line">    ls.add(root);</span><br><span class="line">    ls.add(root);</span><br><span class="line">    <span class="keyword">while</span>(ls.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">         <span class="comment">//poll函数 这个函数我很少用，用处是将队列里第一个元素取出，如果没有则返回null。</span></span><br><span class="line">        TreeNode t1 = ls.poll(); </span><br><span class="line">        <span class="comment">// 每次取出头两个来对比是否相同</span></span><br><span class="line">        TreeNode t2 = ls.poll();</span><br><span class="line">        <span class="comment">// 判断是和上面的代码是一样的</span></span><br><span class="line">        <span class="keyword">if</span>(t1==<span class="keyword">null</span>&amp;&amp;t2==<span class="keyword">null</span>)&#123; </span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(t1==<span class="keyword">null</span>||t2==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t1.val!=t2.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 往队列里添加新的节点，t1 t2的顺序相反 因为它们是镜像。</span></span><br><span class="line">            ls.add(t1.left);</span><br><span class="line">            ls.add(t2.right);</span><br><span class="line">            ls.add(t1.right);</span><br><span class="line">            ls.add(t2.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是本题的地址：&lt;a href=&quot;https://leetcode-cn.com/problems/symmetric-tree/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/symmetric-tree/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一个二叉树，检查它是否是镜像对称的。&lt;/p&gt;
&lt;p&gt;例如，二叉树 &lt;code&gt;[1,2,2,3,4,4,3]&lt;/code&gt; 是对称的。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;    1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   / \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  2   2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; / \ / \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3  4 4  3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但是下面这个 &lt;code&gt;[1,2,2,null,3,null,3]&lt;/code&gt; 则不是镜像对称的:&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="树" scheme="http://yoursite.com/tags/%E6%A0%91/"/>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>numDecodings_91</title>
    <link href="http://yoursite.com/2019/02/13/numDecodings-91/"/>
    <id>http://yoursite.com/2019/02/13/numDecodings-91/</id>
    <published>2019-02-13T06:09:44.000Z</published>
    <updated>2019-02-13T07:12:58.430Z</updated>
    
    <content type="html"><![CDATA[<p><strong>终于，感觉这道题不是那么的水了~</strong></p><p>这是本题的地址：<a href="https://leetcode-cn.com/problems/decode-ways/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/decode-ways/</a></p><p>一条包含字母 <code>A-Z</code> 的消息通过以下方式进行了编码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'A'</span> -&gt; <span class="number">1</span></span><br><span class="line"><span class="string">'B'</span> -&gt; <span class="number">2</span></span><br><span class="line">...</span><br><span class="line"><span class="string">'Z'</span> -&gt; <span class="number">26</span></span><br></pre></td></tr></table></figure><p>给定一个只包含数字的<strong>非空</strong>字符串，请计算解码方法的总数。</p><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">"12"</span></span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">解释: 它可以解码为 <span class="string">"AB"</span>（<span class="number">1</span> <span class="number">2</span>）或者 <span class="string">"L"</span>（<span class="number">12</span>）。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">"226"</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 它可以解码为 <span class="string">"BZ"</span> (<span class="number">2</span> <span class="number">26</span>), <span class="string">"VF"</span> (<span class="number">22</span> <span class="number">6</span>), 或者 <span class="string">"BBF"</span> (<span class="number">2</span> <span class="number">2</span> <span class="number">6</span>) 。</span><br></pre></td></tr></table></figure><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>这道题是真的挺多坑的。让我头大得很。从题目中的A B ….Z 这个其实可以不用管。这道题也是采用动态规划来做，因为他是从1-26的数字，所以最多只会有2个数字连在一起。不会出现3个数字连在一起的情况。所以而且我们可以发现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">例如字符串：<span class="string">"123"</span>。</span><br><span class="line">opt[<span class="number">0</span>] = <span class="number">1</span>;  也就是字符串<span class="string">"1"</span>处的最优解码是<span class="number">1</span></span><br><span class="line">opt[<span class="number">1</span>] = <span class="number">2</span>;  也就是字符串<span class="string">"2"</span>处的最优解码是<span class="number">2</span>, 他的解码方式是 <span class="number">1</span> <span class="number">2</span>和 <span class="number">12</span>  其实这时候还不是很好看出递归式。</span><br><span class="line">opt[<span class="number">3</span>] = <span class="number">3</span>;  为什么呢 其实这个我们可以拆解出来。</span><br><span class="line"><span class="number">123</span> 可以拆解为：</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">12</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">23</span></span><br><span class="line">三种。</span><br><span class="line">这时候我们可以发现一些有意思的东西，假如把 <span class="number">3</span> 拿出来 <span class="number">1</span> <span class="number">2</span>和<span class="number">12</span> 这两个不就是opt[<span class="number">1</span>]的值吗？把 <span class="number">23</span> 拿出来剩下的 <span class="number">1</span> 不就是opt[<span class="number">0</span>]的值吗。</span><br></pre></td></tr></table></figure><p>这时候我们就可以得出我们的递归式 ： opt[n] = opt[n-1]+opt[n-2] 突然发现这样的递归式不是很常见吗哈哈~</p><p>得到了递归式 其实还有一个很重要的坑那就是：当有一个值为0的时候，我们会发现题目中没有给出0。但是却有10 和 20 这两个符合解码的数。但假如是0开头的是不能解码的。所以我们就要对0这个字符进行判断。如果是有0出现，假如出现了不能解码的情况，那整个字符串都不能解码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s.length();</span><br><span class="line">    <span class="keyword">int</span>[] opt = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    opt[<span class="number">0</span>] = s.charAt(<span class="number">0</span>)==<span class="string">'0'</span>?<span class="number">0</span>:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> sum =Integer.parseInt(s.substring(i-<span class="number">1</span>,i+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i)==<span class="string">'0'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum&lt;<span class="number">10</span>||sum&gt;<span class="number">26</span>)&#123;</span><br><span class="line">                opt[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;<span class="number">2</span>)&#123;</span><br><span class="line">                    opt[i] = opt[i-<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    opt[i] = opt[i-<span class="number">2</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum&lt;=<span class="number">26</span>&amp;&amp;sum&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;<span class="number">2</span>)&#123;</span><br><span class="line">                    opt[i] = opt[i-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    opt[i] = opt[i-<span class="number">1</span>] + opt[i-<span class="number">2</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                opt[i] = opt[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> opt[n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="我的反思"><a href="#我的反思" class="headerlink" title="我的反思"></a>我的反思</h2><p>虽然用上了动态规划 但是我觉得里面的if else 也还是有点多….. </p><p>别人的速度虽然比我快一点，但是看起来我们的时间复杂度都是O(n)呀。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;终于，感觉这道题不是那么的水了~&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是本题的地址：&lt;a href=&quot;https://leetcode-cn.com/problems/decode-ways/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/decode-ways/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一条包含字母 &lt;code&gt;A-Z&lt;/code&gt; 的消息通过以下方式进行了编码：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;A&#39;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;B&#39;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;Z&#39;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;number&quot;&gt;26&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;给定一个只包含数字的&lt;strong&gt;非空&lt;/strong&gt;字符串，请计算解码方法的总数。&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>minPathSum_64</title>
    <link href="http://yoursite.com/2019/02/13/minPathSum-64/"/>
    <id>http://yoursite.com/2019/02/13/minPathSum-64/</id>
    <published>2019-02-13T01:55:07.000Z</published>
    <updated>2019-02-13T07:12:53.659Z</updated>
    
    <content type="html"><![CDATA[<p>这是本题的地址<a href="https://leetcode-cn.com/problems/minimum-path-sum/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/minimum-path-sum/</a></p><p>给定一个包含非负整数的 <em>m</em> x <em>n</em> 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p><strong>说明：</strong>每次只能向下或者向右移动一步。</p><a id="more"></a><p><strong>示例:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>],</span><br><span class="line">  [<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">]</span><br><span class="line">输出: <span class="number">7</span></span><br><span class="line">解释: 因为路径 <span class="number">1</span>→<span class="number">3</span>→<span class="number">1</span>→<span class="number">1</span>→<span class="number">1</span> 的总和最小。</span><br></pre></td></tr></table></figure><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>感觉62 63 64 都是连续的题目 都是使用动态规划来做这道题。都是一些很简单的动态规划。</p><p>从题目中我们可以了解递归式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">opt[i][j] = (opt[i-<span class="number">1</span>][j]&lt;opt[i][j-<span class="number">1</span>]?opt[i-<span class="number">1</span>][j]:opt[i][j-<span class="number">1</span>]) + grid[i][j];</span><br></pre></td></tr></table></figure><p>通过使用这个递归式最终我们可以得出我们想要的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(grid==<span class="keyword">null</span> || grid.length==<span class="number">0</span> ||(grid.length==<span class="number">1</span>&amp;&amp;grid[<span class="number">0</span>].length==<span class="number">0</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = grid.length;</span><br><span class="line">    <span class="keyword">int</span> m = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] opt = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) &#123;</span><br><span class="line">                opt[i][j] = grid[i][j];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                opt[i][j] = grid[i][j]+opt[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>)&#123;</span><br><span class="line">                opt[i][j] = grid[i][j]+opt[i-<span class="number">1</span>][j];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                opt[i][j] = (opt[i-<span class="number">1</span>][j]&lt;opt[i][j-<span class="number">1</span>]?opt[i-<span class="number">1</span>][j]:opt[i][j-<span class="number">1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> opt[n-<span class="number">1</span>][m-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="我的反思"><a href="#我的反思" class="headerlink" title="我的反思"></a>我的反思</h2><p>最终跑出来的速度比别人的慢很多，但是我看了下别人的范例代码。我觉得我们的代码好像都是一样的呀？有的人也用递归来做，也不知道是不是更好一些。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是本题的地址&lt;a href=&quot;https://leetcode-cn.com/problems/minimum-path-sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/minimum-path-sum/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一个包含非负整数的 &lt;em&gt;m&lt;/em&gt; x &lt;em&gt;n&lt;/em&gt; 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;每次只能向下或者向右移动一步。&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>uniquePathsWithObstacles_63</title>
    <link href="http://yoursite.com/2019/02/12/uniquePathsWithObstacles-63/"/>
    <id>http://yoursite.com/2019/02/12/uniquePathsWithObstacles-63/</id>
    <published>2019-02-12T02:31:09.000Z</published>
    <updated>2019-02-12T03:07:19.373Z</updated>
    
    <content type="html"><![CDATA[<p>这是本题的地址：<a href="https://leetcode-cn.com/problems/unique-paths-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-paths-ii/</a></p><p>一个机器人位于一个 <em>m x n</em> 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p>网格中的障碍物和空位置分别用 <code>1</code> 和 <code>0</code> 来表示。</p><a id="more"></a><p><strong>说明：*</strong>m<em> 和 </em>n* 的值均不超过 100。</p><p><strong>示例 1:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">  [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">]</span><br><span class="line">输出: <span class="number">2</span></span><br><span class="line">解释:</span><br><span class="line"><span class="number">3</span>x3 网格的正中间有一个障碍物。</span><br><span class="line">从左上角到右下角一共有 <span class="number">2</span> 条不同的路径：</span><br><span class="line"><span class="number">1</span>. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line"><span class="number">2</span>. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>这道题和<a href="https://jasonhejiachen.github.io/2019/02/11/uniquePaths-62/" target="_blank" rel="noopener">uniquePaths-62</a> 类似。但是增加了一个障碍的条件。我的做法其实和之前的差不多，但是增加了一些关于遇到“障碍”时的判断。这道题也是使用动态规划~，有一个问题在于假如传入的是空的数组。获取第二维的长度的时候会报错。</p><p><strong>判断二维数组是否位空</strong>：</p><p><strong>if ( array == null  ||  array.length == 0  ||  ( array.length == 1 &amp;&amp; array[0].length == 0 ) )</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = obstacleGrid.length;</span><br><span class="line">    <span class="keyword">int</span> m = obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] opt = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                opt[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;j==<span class="number">0</span>)&#123;</span><br><span class="line">                    opt[i][j] =<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                    opt[i][j] = opt[i][j-<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</span><br><span class="line">                    opt[i][j] = opt[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    opt[i][j] = opt[i][j-<span class="number">1</span>]+opt[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> opt[n-<span class="number">1</span>][m-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是本题的地址：&lt;a href=&quot;https://leetcode-cn.com/problems/unique-paths-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/unique-paths-ii/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一个机器人位于一个 &lt;em&gt;m x n&lt;/em&gt; 网格的左上角 （起始点在下图中标记为“Start” ）。&lt;/p&gt;
&lt;p&gt;机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。&lt;/p&gt;
&lt;p&gt;现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？&lt;/p&gt;
&lt;p&gt;网格中的障碍物和空位置分别用 &lt;code&gt;1&lt;/code&gt; 和 &lt;code&gt;0&lt;/code&gt; 来表示。&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>uniquePaths_62(java)</title>
    <link href="http://yoursite.com/2019/02/11/uniquePaths-62/"/>
    <id>http://yoursite.com/2019/02/11/uniquePaths-62/</id>
    <published>2019-02-11T02:33:52.000Z</published>
    <updated>2019-02-11T03:09:49.054Z</updated>
    
    <content type="html"><![CDATA[<p>这是本题的地址:<a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-paths/</a></p><p>一个机器人位于一个 <em>m x n</em> 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>问总共有多少条不同的路径？</p><a id="more"></a><p>例如，上图是一个7 x 3 的网格。有多少可能的路径？</p><p><strong>说明：*</strong>m<em> 和 </em>n* 的值均不超过 100。</p><p><strong>示例 1:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: m = <span class="number">3</span>, n = <span class="number">2</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释:</span><br><span class="line">从左上角开始，总共有 <span class="number">3</span> 条路径可以到达右下角。</span><br><span class="line"><span class="number">1</span>. 向右 -&gt; 向右 -&gt; 向下</span><br><span class="line"><span class="number">2</span>. 向右 -&gt; 向下 -&gt; 向右</span><br><span class="line"><span class="number">3</span>. 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: m = <span class="number">7</span>, n = <span class="number">3</span></span><br><span class="line">输出: <span class="number">28</span></span><br></pre></td></tr></table></figure><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>这题我是想着使用动态规划来做的，这个与之前动态规划不同的是 他是一个二维数组。这样的话最优解opt的数组也是一个二维数组。且题目中说明每次只能向下或向右移动一步。这样的话，递归式应该是这样：opt [n] [m] = opt[n-1] [m] + opt[n] [m-1]。得到了递归式，我们就可以开始进行操作了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">0</span>||n==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[][] opt = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>||j==<span class="number">0</span>)&#123;</span><br><span class="line">                opt[i][j]=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                opt[i][j] = opt[i][j-<span class="number">1</span>]+opt[i-<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> opt[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我感觉不太好，因为要使用两个for 但是好像必须这样，因为是一个二维数组。时间复杂度：O(n^2)。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是本题的地址:&lt;a href=&quot;https://leetcode-cn.com/problems/unique-paths/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/unique-paths/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一个机器人位于一个 &lt;em&gt;m x n&lt;/em&gt; 网格的左上角 （起始点在下图中标记为“Start” ）。&lt;/p&gt;
&lt;p&gt;机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。&lt;/p&gt;
&lt;p&gt;问总共有多少条不同的路径？&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>plusOne_66(java)</title>
    <link href="http://yoursite.com/2019/02/10/plusOne-66/"/>
    <id>http://yoursite.com/2019/02/10/plusOne-66/</id>
    <published>2019-02-10T11:14:27.000Z</published>
    <updated>2019-02-10T13:37:42.047Z</updated>
    
    <content type="html"><![CDATA[<p>这是本题的地址<a href="https://leetcode-cn.com/problems/plus-one/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/plus-one/</a></p><p>给定一个由<strong>整数</strong>组成的<strong>非空</strong>数组所表示的非负整数，在该数的基础上加一。</p><p>最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。</p><a id="more"></a><p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出: [1,2,4]</span><br><span class="line">解释: 输入数组表示数字 123。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">输出: [<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">解释: 输入数组表示数字 <span class="number">4321</span>。</span><br></pre></td></tr></table></figure><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>这道题我觉得同 <a href="https://jasonhejiachen.github.io/2019/01/26/addTwoNumbers-2/" target="_blank" rel="noopener">addTwoNumbers-2-两数之和</a> 题有一点点类似，但是一个是链表一个是数组</p><p>我的做法是这样的。从数组最后一个数字进行遍历，将其+1。若果超过了10。那么当前的数就要%10。并且flag=1。</p><p>通过flag来查看是否需要添加一位最新的数。如需要 就用for循环新建一个数组。如不需要就直接返回当前数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] plusOne(<span class="keyword">int</span>[] digits) &#123;</span><br><span class="line">    <span class="keyword">int</span> flag =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=digits.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        digits[i]+=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(digits[i]&gt;=<span class="number">10</span>)&#123;</span><br><span class="line">            flag =<span class="number">1</span>;</span><br><span class="line">            digits[i] = digits[i]%<span class="number">10</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            flag =<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="number">0</span>)&#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[digits.length+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(flag==<span class="number">1</span>)&#123;</span><br><span class="line">        a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=digits.length;i++)&#123;</span><br><span class="line">            a[i] = digits[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flag==<span class="number">1</span>?a:digits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度为 ：O(n) n为数组的长度。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是本题的地址&lt;a href=&quot;https://leetcode-cn.com/problems/plus-one/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/plus-one/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一个由&lt;strong&gt;整数&lt;/strong&gt;组成的&lt;strong&gt;非空&lt;/strong&gt;数组所表示的非负整数，在该数的基础上加一。&lt;/p&gt;
&lt;p&gt;最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>lengthOfLastWord_58(java)</title>
    <link href="http://yoursite.com/2019/02/07/lengthOfLastWord-58/"/>
    <id>http://yoursite.com/2019/02/07/lengthOfLastWord-58/</id>
    <published>2019-02-07T02:47:38.000Z</published>
    <updated>2019-02-07T03:12:26.979Z</updated>
    
    <content type="html"><![CDATA[<p>这是本题的地址：<a href="https://leetcode-cn.com/problems/length-of-last-word/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/length-of-last-word/</a></p><p>给定一个仅包含大小写字母和空格 <code>&#39; &#39;</code> 的字符串，返回其最后一个单词的长度。</p><p>如果不存在最后一个单词，请返回 0 。</p><p><strong>说明：</strong>一个单词是指由字母组成，但不包含任何空格的字符串。</p><a id="more"></a><p><strong>示例:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">"Hello World"</span></span><br><span class="line">输出: <span class="number">5</span></span><br></pre></td></tr></table></figure><h2 id="我的思路："><a href="#我的思路：" class="headerlink" title="我的思路："></a>我的思路：</h2><p>一开始想着用lastindexof来做，但是不行。因为假如是”a   b    “ 这样的字符串。用lastindexof是行不通的。那么我们就用for循环开始遍历整个字符串。获取字符的长度。每当是’ ‘的时候，就将长度值设为0。lastlength用于记录上个字符的长度。length记录当前字符的长度。当length为0时 说明 ‘ ’符后面没有字符了。这时候就需要返回lastlength</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> lastlength=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i)==<span class="string">' '</span>)&#123;</span><br><span class="line">            lastlength = length==<span class="number">0</span>?lastlength:length;</span><br><span class="line">            length = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            length++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length==<span class="number">0</span>?lastlength:length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="官方思路"><a href="#官方思路" class="headerlink" title="官方思路"></a>官方思路</h2><p>没有，让我们来看看别人的做法是怎么样的</p><p>看了一下范例，发现其实大多数都是用for循环的。它们从最后开始往回找，这样循环的遍历就少多了。但既然都是用for循环。就不列出来了。有一个蛮有意思的：</p><p>他的做法是用trim去掉首尾的 “ “空格符，通过寻找剩下的” “空格符。如果没有就返回整体的长度。如果有就判断是否有字符串，没有就返回0。最后再返回原长度-i-1。 i就是倒数的” “空格符的位置。那么减去它就相当于减掉了前面的长度。再-1就是把” “空格符所占的1个位置给减掉了~。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLastWord2</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    s = s.trim();</span><br><span class="line">    <span class="keyword">int</span> i = s.lastIndexOf(<span class="string">" "</span>);</span><br><span class="line">    <span class="keyword">if</span> (i == -<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> s.length();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == s.length()-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> s.length()-i-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是本题的地址：&lt;a href=&quot;https://leetcode-cn.com/problems/length-of-last-word/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/length-of-last-word/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一个仅包含大小写字母和空格 &lt;code&gt;&amp;#39; &amp;#39;&lt;/code&gt; 的字符串，返回其最后一个单词的长度。&lt;/p&gt;
&lt;p&gt;如果不存在最后一个单词，请返回 0 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;一个单词是指由字母组成，但不包含任何空格的字符串。&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>weekgame_122</title>
    <link href="http://yoursite.com/2019/02/03/weekgame-122/"/>
    <id>http://yoursite.com/2019/02/03/weekgame-122/</id>
    <published>2019-02-03T14:19:34.000Z</published>
    <updated>2019-02-03T15:07:27.923Z</updated>
    
    <content type="html"><![CDATA[<p>这是该题的地址：<a href="https://leetcode-cn.com/contest/weekly-contest-122/problems/sum-of-even-numbers-after-queries/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-122/problems/sum-of-even-numbers-after-queries/</a></p><p>给出一个整数数组 <code>A</code> 和一个查询数组 <code>queries</code>。</p><p>对于第 <code>i</code> 次查询，有 <code>val = queries[i][0], index = queries[i][1]</code>，我们会把 <code>val</code> 加到 <code>A[index]</code> 上。然后，第 <code>i</code> 次查询的答案是 <code>A</code>中偶数值的和。</p><p><em>（此处给定的 index = queries[i][1] 是从 0 开始的索引，每次查询都会永久修改数组 A。）</em></p><p>返回所有查询的答案。你的答案应当以数组 <code>answer</code> 给出，<code>answer[i]</code> 为第 <code>i</code> 次查询的答案。</p> <a id="more"></a><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：A = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], queries = [[<span class="number">1</span>,<span class="number">0</span>],[-<span class="number">3</span>,<span class="number">1</span>],[-<span class="number">4</span>,<span class="number">0</span>],[<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">输出：[<span class="number">8</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line">解释：</span><br><span class="line">开始时，数组为 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]。</span><br><span class="line">将 <span class="number">1</span> 加到 A[<span class="number">0</span>] 上之后，数组为 [<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]，偶数值之和为 <span class="number">2</span> + <span class="number">2</span> + <span class="number">4</span> = <span class="number">8</span>。</span><br><span class="line">将 -<span class="number">3</span> 加到 A[<span class="number">1</span>] 上之后，数组为 [<span class="number">2</span>,-<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>]，偶数值之和为 <span class="number">2</span> + <span class="number">4</span> = <span class="number">6</span>。</span><br><span class="line">将 -<span class="number">4</span> 加到 A[<span class="number">0</span>] 上之后，数组为 [-<span class="number">2</span>,-<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>]，偶数值之和为 -<span class="number">2</span> + <span class="number">4</span> = <span class="number">2</span>。</span><br><span class="line">将 <span class="number">2</span> 加到 A[<span class="number">3</span>] 上之后，数组为 [-<span class="number">2</span>,-<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>]，偶数值之和为 -<span class="number">2</span> + <span class="number">6</span> = <span class="number">4</span>。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= A.length &lt;= 10000</code></li><li><code>-10000 &lt;= A[i] &lt;= 10000</code></li><li><code>1 &lt;= queries.length &lt;= 10000</code></li><li><code>-10000 &lt;= queries[i][0] &lt;= 10000</code></li><li><code>0 &lt;= queries[i][1] &lt; A.length</code></li></ol><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>根据题目，我们可以得知，answer的长度为i 而i的值则是queries的长度。那么我们可以通过遍历queries数组。然后对数组A进行操作。之后通过遍历数组A 找出偶数，并相加求出和。然后得出一个值，放进anwser数组里。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sumEvenAfterQueries(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[][] queries) &#123;</span><br><span class="line">    <span class="keyword">int</span> [] answer = <span class="keyword">new</span> <span class="keyword">int</span>[queries.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;queries.length;i++)&#123;</span><br><span class="line">        A[queries[i][<span class="number">1</span>]] += queries[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> sum =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;A.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[j]%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                sum+=A[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        answer[i] = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> answer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：使用了暴力破解。时间复杂度增高。</p><h2 id="官方思路"><a href="#官方思路" class="headerlink" title="官方思路"></a>官方思路</h2><p>感觉官方的思路比较聪明，通过先找出A数组中的偶数和。然后再通过添加的操作判断当前数是否还是偶数。这样的话只需要通过单个循环就可以实现了。</p><p><a href="https://leetcode-cn.com/articles/sum-of-even-numbers-after-queries/" target="_blank" rel="noopener">https://leetcode-cn.com/articles/sum-of-even-numbers-after-queries/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是该题的地址：&lt;a href=&quot;https://leetcode-cn.com/contest/weekly-contest-122/problems/sum-of-even-numbers-after-queries/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/contest/weekly-contest-122/problems/sum-of-even-numbers-after-queries/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给出一个整数数组 &lt;code&gt;A&lt;/code&gt; 和一个查询数组 &lt;code&gt;queries&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;对于第 &lt;code&gt;i&lt;/code&gt; 次查询，有 &lt;code&gt;val = queries[i][0], index = queries[i][1]&lt;/code&gt;，我们会把 &lt;code&gt;val&lt;/code&gt; 加到 &lt;code&gt;A[index]&lt;/code&gt; 上。然后，第 &lt;code&gt;i&lt;/code&gt; 次查询的答案是 &lt;code&gt;A&lt;/code&gt;中偶数值的和。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（此处给定的 index = queries[i][1] 是从 0 开始的索引，每次查询都会永久修改数组 A。）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;返回所有查询的答案。你的答案应当以数组 &lt;code&gt;answer&lt;/code&gt; 给出，&lt;code&gt;answer[i]&lt;/code&gt; 为第 &lt;code&gt;i&lt;/code&gt; 次查询的答案。&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>climbStairs-70(java)</title>
    <link href="http://yoursite.com/2019/02/01/climbStairs-70/"/>
    <id>http://yoursite.com/2019/02/01/climbStairs-70/</id>
    <published>2019-02-01T07:29:31.000Z</published>
    <updated>2019-02-11T03:12:19.670Z</updated>
    
    <content type="html"><![CDATA[<p>这是本题的地址<a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/climbing-stairs/</a></p><p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><a id="more"></a><p><strong>注意：</strong>给定 <em>n</em> 是一个正整数。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶</span><br><span class="line">2.  2 阶</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入： <span class="number">3</span></span><br><span class="line">输出： <span class="number">3</span></span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line"><span class="number">1</span>.  <span class="number">1</span> 阶 + <span class="number">1</span> 阶 + <span class="number">1</span> 阶</span><br><span class="line"><span class="number">2</span>.  <span class="number">1</span> 阶 + <span class="number">2</span> 阶</span><br><span class="line"><span class="number">3</span>.  <span class="number">2</span> 阶 + <span class="number">1</span> 阶</span><br></pre></td></tr></table></figure><h2 id="我的思路："><a href="#我的思路：" class="headerlink" title="我的思路："></a>我的思路：</h2><p>其实这个仔细的看一下就会发现和哪个斐波那契数列第n项问题很像。主要的递归式就是 f[n] = f[n-1]+f[n-2]。</p><p>通过这个式子我们就可以得出第n个梯子有多少种变化啦~最后返回数组的n-1即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] foot = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    foot[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    foot[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">        foot[i] = foot[i-<span class="number">1</span>]+foot[i-<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> foot[n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="我的结果"><a href="#我的结果" class="headerlink" title="我的结果"></a>我的结果</h2><p><img src="/2019/02/01/climbStairs-70/access.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是本题的地址&lt;a href=&quot;https://leetcode-cn.com/problems/climbing-stairs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/climbing-stairs/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;假设你正在爬楼梯。需要 &lt;em&gt;n&lt;/em&gt; 阶你才能到达楼顶。&lt;/p&gt;
&lt;p&gt;每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>maxSubArray-53</title>
    <link href="http://yoursite.com/2019/02/01/maxSubArray-53/"/>
    <id>http://yoursite.com/2019/02/01/maxSubArray-53/</id>
    <published>2019-02-01T06:50:28.000Z</published>
    <updated>2019-02-11T03:11:56.614Z</updated>
    
    <content type="html"><![CDATA[<p>这是本题的地址：<a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-subarray/</a></p><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><a id="more"></a><p><strong>示例:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [-<span class="number">2</span>,<span class="number">1</span>,-<span class="number">3</span>,<span class="number">4</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,-<span class="number">5</span>,<span class="number">4</span>],</span><br><span class="line">输出: <span class="number">6</span></span><br><span class="line">解释: 连续子数组 [<span class="number">4</span>,-<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>] 的和最大，为 <span class="number">6</span>。</span><br></pre></td></tr></table></figure><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>1、暴力：</p><p>循环遍历当前数组的每个节点，设定一个int sum值来记录最长的子字符串的长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">int</span> sum=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> sum1 =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            sum1 += nums[j];</span><br><span class="line">            sum = sum&gt;sum1?sum:sum1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点： 慢。能不用就不用</p><p>2、动态规划：</p><p>进行一次遍历：</p><p>每当前面的子序之和为负值时，也就证明了有没有前面的数字都是无所谓的，这时候，就可以重新记录子序和了~。然后将这些进行比较，最大的就返回出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max= nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum&gt;<span class="number">0</span>  )&#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            sum=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        max = Math.max(sum,max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是本题的地址：&lt;a href=&quot;https://leetcode-cn.com/problems/maximum-subarray/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/maximum-subarray/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>longestPalindrome_5</title>
    <link href="http://yoursite.com/2019/01/30/longestPalindrome-5/"/>
    <id>http://yoursite.com/2019/01/30/longestPalindrome-5/</id>
    <published>2019-01-30T06:35:54.000Z</published>
    <updated>2019-02-11T03:11:34.589Z</updated>
    
    <content type="html"><![CDATA[<p>这是本题的地址：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-palindromic-substring/</a></p><p>给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。你可以假设 <code>s</code> 的最大长度为 1000。</p><a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">"babad"</span></span><br><span class="line">输出: <span class="string">"bab"</span></span><br><span class="line">注意: <span class="string">"aba"</span> 也是一个有效答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">"cbbd"</span></span><br><span class="line">输出: <span class="string">"bb"</span></span><br></pre></td></tr></table></figure><h2 id="我的思路："><a href="#我的思路：" class="headerlink" title="我的思路："></a>我的思路：</h2><p>有一个String sum =”” 来保存最大的回文。</p><p>有第一个for(int i=0)循环遍历整个字符串。然后第二个字符串由j=i 开始，判断这i j之间是否是回文。如果是，那么j-i+1(加1是因为j和i相同时，也是有一个字符的)是否大于sum的长度。如果大于，那么他们就是最大的回文。</p><p>那么用于判断ij之间是否为回文的方法我是这样做的：先判断当前i j的字符是否相同，如果相同则判断 i j 是否相等或相邻，如果是那么就返回true。如果不是那么进行 i+1 和 j-1的递归。若果i j的字符不相同，则返回false；这样是暴力解法。时间复杂度 n3次方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    String sum = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;s.length();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Panduan(i,j,s))&#123;</span><br><span class="line">                <span class="keyword">if</span>(j-i+<span class="number">1</span>&gt;sum.length())&#123;</span><br><span class="line">                    sum = s.substring(i,j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">Panduan</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,String s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.charAt(a)==s.charAt(b))&#123;</span><br><span class="line">        <span class="keyword">if</span>(a==b||a==b-<span class="number">1</span>||a-<span class="number">1</span>==b)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Panduan(++a,--b,s);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="我的结果："><a href="#我的结果：" class="headerlink" title="我的结果："></a>我的结果：</h2><p><img src="/2019/01/30/longestPalindrome-5/img/access.png" alt=""></p><p>特别的慢：这也是暴力解法的问题所在！</p><p>在官方的解答中：有动态规划和中心扩展算法这两个。等我看懂了再补充上来！~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是本题的地址：&lt;a href=&quot;https://leetcode-cn.com/problems/longest-palindromic-substring/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/longest-palindromic-substring/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一个字符串 &lt;code&gt;s&lt;/code&gt;，找到 &lt;code&gt;s&lt;/code&gt; 中最长的回文子串。你可以假设 &lt;code&gt;s&lt;/code&gt; 的最大长度为 1000。&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>清理：终结处理和垃圾回收</title>
    <link href="http://yoursite.com/2019/01/29/%E6%B8%85%E7%90%86%EF%BC%9A%E7%BB%88%E7%BB%93%E5%A4%84%E7%90%86%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>http://yoursite.com/2019/01/29/清理：终结处理和垃圾回收/</id>
    <published>2019-01-29T15:04:53.000Z</published>
    <updated>2019-01-29T15:07:02.635Z</updated>
    
    <content type="html"><![CDATA[<h2 id="清理：终结处理和垃圾回收"><a href="#清理：终结处理和垃圾回收" class="headerlink" title="清理：终结处理和垃圾回收"></a>清理：终结处理和垃圾回收</h2><p>垃圾回收的三个要点</p><p>1、对象可能不被垃圾回收</p><p>2、垃圾回收并不等于“析构”</p><p>3、垃圾回收只和内存有关</p><a id="more"></a><p>java 中允许调用finalize方法，这个方法却不能作为通用的清理方法。因为程序没有濒临储存空间用完，那么就不需要释放内存。因为垃圾回收也是需要开销的，如果不用它，那么这部分开销就省下来了。那么finalize方法在什么时候可以调用呢：在通过某种创建对象方式以外的方式为对象分配了储存空间，但是java一切皆为对象。。。this is special！ *java中有一种“本地方法”，它是一种在java中调用的非java代码，在jdk1.5时是只支持c/c++的，它可能会调用c的函数来分配对象，也可能调用任何其他语言。so，这些都需要特定的储存释放方法来释放。这时候finalize就有用武之地了。</p><h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><h5 id="1、引用计数"><a href="#1、引用计数" class="headerlink" title="1、引用计数"></a>1、引用计数</h5><p>这是一种很简单但是很慢的垃圾回收技术，每个对象都有一个引用计数器，当有引用链接到对象时，引用计数+1，当引用离开作用域或被置为null，引用计数就会-1，当引用计数=0的时候就回回收对象。</p><p>缺陷：当对象之前存在循环引用，引用计数不为0时但又要被回收的时候，这样对于垃圾回收工作量非常大。引用计数常用来说明垃圾收集的工作方式，没有被应用于任何java虚拟机实现。</p><h5 id="2、自适应垃圾回收技术：停止-复制"><a href="#2、自适应垃圾回收技术：停止-复制" class="headerlink" title="2、自适应垃圾回收技术：停止-复制"></a>2、自适应垃圾回收技术：停止-复制</h5><p>暂停程序的运行，将当前堆所有存活的对象复制到另一个堆，没有被复制的都会被垃圾回收。当对象被复制到新的堆中的时候，它们时一个挨着一个的。所以新堆抱持紧凑排列，以后的分配空间也很简单。</p><p>缺点：</p><p>–1 效率低，需要有两个堆。维护比实际需要多一倍的空间。 某些java虚拟机的处理方式：按需从内存中分配较大块的内存，复制动作发生在他们里面。</p><p>–2 程序进入稳定状态之后可能只会产生少量的垃圾，但是如果用这个还是会将内存从一处复制到另外一处。</p><h5 id="3、自适应垃圾回收技术：标记-清扫"><a href="#3、自适应垃圾回收技术：标记-清扫" class="headerlink" title="3、自适应垃圾回收技术：标记-清扫"></a>3、自适应垃圾回收技术：标记-清扫</h5><p>基于上一份放的问题2，产生了新的垃圾回收机制：标记-清扫。遍历所有的引用，找出活对象并标记，在全部标记完成之后，才会进行清扫工作。把没有标记的对象都进行垃圾回收。这样下来，剩下的空间是不连续的。</p><h4 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h4><p>java虚拟机会进行监视，如果所有对象都稳定，垃圾回收效率降低的话。就使用“标记-清扫”方式，当碎片过多就会使用“停止-复制”，这就是“自适应”垃圾回收机制。</p><h2 id="LAST"><a href="#LAST" class="headerlink" title="LAST"></a>LAST</h2><p>最后 java虚拟机中有许多附加技术用以提升速度，叫做just in time “即时”编译器技术。 当需要装载某些类的时候（通常是为该类创建第一个对象），编译器先找到.class文件。然后将该类的字节码装入内存。之后会有两种做法：</p><p>1、让即时编辑器编译所有代码。</p><p>这种方式有两种缺陷：一、加载动作散落在整个程序生命周期内，累加起来要花更多时间。二、增加可执行代码的长度，降低了程序速度。</p><p>2、让即时编辑器载必要时候才编译。</p><p>也称为惰性评估。这样不会被执行的代码也不会倍jit编译。在java HotSpot技术中采用了此操作。代码每次被执行都会做一些优化。执行的越多跑的越快。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;清理：终结处理和垃圾回收&quot;&gt;&lt;a href=&quot;#清理：终结处理和垃圾回收&quot; class=&quot;headerlink&quot; title=&quot;清理：终结处理和垃圾回收&quot;&gt;&lt;/a&gt;清理：终结处理和垃圾回收&lt;/h2&gt;&lt;p&gt;垃圾回收的三个要点&lt;/p&gt;
&lt;p&gt;1、对象可能不被垃圾回收&lt;/p&gt;
&lt;p&gt;2、垃圾回收并不等于“析构”&lt;/p&gt;
&lt;p&gt;3、垃圾回收只和内存有关&lt;/p&gt;
    
    </summary>
    
      <category term="ThinkinJava" scheme="http://yoursite.com/categories/ThinkinJava/"/>
    
    
      <category term="ThinkinJava" scheme="http://yoursite.com/tags/ThinkinJava/"/>
    
  </entry>
  
  <entry>
    <title>countAndSay_38(java)</title>
    <link href="http://yoursite.com/2019/01/29/countAndSay-38/"/>
    <id>http://yoursite.com/2019/01/29/countAndSay-38/</id>
    <published>2019-01-29T08:59:43.000Z</published>
    <updated>2019-01-29T15:14:35.309Z</updated>
    
    <content type="html"><![CDATA[<p>这是该题的地址<a href="https://leetcode-cn.com/problems/count-and-say/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-and-say/</a></p><p>报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.     1</span><br><span class="line">2.     11</span><br><span class="line">3.     21</span><br><span class="line">4.     1211</span><br><span class="line">5.     111221</span><br></pre></td></tr></table></figure><p><code>1</code> 被读作  <code>&quot;one 1&quot;</code>  (<code>&quot;一个一&quot;</code>) , 即 <code>11</code>。<br><code>11</code> 被读作 <code>&quot;two 1s&quot;</code> (<code>&quot;两个一&quot;</code>）, 即 <code>21</code>。<br><code>21</code> 被读作 <code>&quot;one 2&quot;</code>,  “<code>one 1&quot;</code> （<code>&quot;一个二&quot;</code> ,  <code>&quot;一个一&quot;</code>) , 即 <code>1211</code>。</p><p>给定一个正整数 <em>n</em>（1 ≤ <em>n</em> ≤ 30），输出报数序列的第 <em>n</em> 项。</p><p>注意：整数顺序将表示为一个字符串。</p><a id="more"></a> <p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1</span><br><span class="line">输出: &quot;1&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: &quot;1211&quot;</span><br></pre></td></tr></table></figure><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>因为题目给了整数n,所以我们应该进行遍历，直到为n的时候输出字符串。 在遍历中，我设定了3个遍历。一个是int sum （用来保存当前字符出现的数量） string now （现在这个字符是怎么样的 例如：11，21 ） string newstr （用来保存字符串的主体 几个now加起来 就是newstr） 通过遍历当前str的值。生成 now 和 newstr。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public String countAndSay(int n) &#123;</span><br><span class="line">        int i=1;</span><br><span class="line">        String str = &quot;1&quot;;</span><br><span class="line">        String now ;</span><br><span class="line">        String newstr ;</span><br><span class="line">        int sum;</span><br><span class="line">        while(i&lt;n)&#123;</span><br><span class="line">            sum = 1;</span><br><span class="line">            now = &quot;&quot;;</span><br><span class="line">            newstr = &quot;&quot;;</span><br><span class="line">            for(int j=0;j&lt;str.length();j++)&#123;</span><br><span class="line">                if(j==0)&#123;</span><br><span class="line">                    now = &quot;&quot;+sum+str.charAt(j);</span><br><span class="line">                &#125; else if(str.charAt(j)==str.charAt(j-1))&#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                    now = &quot;&quot;+ sum+str.charAt(j);</span><br><span class="line">                &#125; else&#123;</span><br><span class="line">                    sum = 1;</span><br><span class="line">                    newstr = newstr + now;</span><br><span class="line">                    now = &quot;&quot;+sum+str.charAt(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            str = newstr + now;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="这是我的结果："><a href="#这是我的结果：" class="headerlink" title="这是我的结果："></a>这是我的结果：</h2><p><img src="/2019/01/29/countAndSay-38/img/picture1.jpg" alt=""></p><p>虽然通过了 但是我觉得很慢，这时候我看了看别人的代码，我觉得我们的时间复杂度差不多啊….. 之后我就发现他们用的是stringbuilder 而我用的是string 所以我对我的代码进行了改版：</p><h2 id="使用Stringbuilder"><a href="#使用Stringbuilder" class="headerlink" title="使用Stringbuilder"></a>使用Stringbuilder</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">countAndSay2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    StringBuilder str = <span class="keyword">new</span> StringBuilder(<span class="string">"1"</span>);</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">        sum = <span class="number">1</span>;</span><br><span class="line">        StringBuilder now = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        StringBuilder newstr = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;str.length();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</span><br><span class="line">                now = <span class="keyword">new</span> StringBuilder(<span class="string">""</span>+sum+str.charAt(j));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(str.charAt(j)==str.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                sum++;</span><br><span class="line">                now = <span class="keyword">new</span> StringBuilder(<span class="string">""</span>+ sum+str.charAt(j));</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                sum = <span class="number">1</span>;</span><br><span class="line">                newstr = newstr.append(now);</span><br><span class="line">                now = <span class="keyword">new</span> StringBuilder(<span class="string">""</span>+sum+str.charAt(j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        str = newstr.append(now);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/2019/01/29/countAndSay-38/img/stringbuilder.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是该题的地址&lt;a href=&quot;https://leetcode-cn.com/problems/count-and-say/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/count-and-say/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1.     1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2.     11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3.     21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4.     1211&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5.     111221&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;1&lt;/code&gt; 被读作  &lt;code&gt;&amp;quot;one 1&amp;quot;&lt;/code&gt;  (&lt;code&gt;&amp;quot;一个一&amp;quot;&lt;/code&gt;) , 即 &lt;code&gt;11&lt;/code&gt;。&lt;br&gt;&lt;code&gt;11&lt;/code&gt; 被读作 &lt;code&gt;&amp;quot;two 1s&amp;quot;&lt;/code&gt; (&lt;code&gt;&amp;quot;两个一&amp;quot;&lt;/code&gt;）, 即 &lt;code&gt;21&lt;/code&gt;。&lt;br&gt;&lt;code&gt;21&lt;/code&gt; 被读作 &lt;code&gt;&amp;quot;one 2&amp;quot;&lt;/code&gt;,  “&lt;code&gt;one 1&amp;quot;&lt;/code&gt; （&lt;code&gt;&amp;quot;一个二&amp;quot;&lt;/code&gt; ,  &lt;code&gt;&amp;quot;一个一&amp;quot;&lt;/code&gt;) , 即 &lt;code&gt;1211&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;给定一个正整数 &lt;em&gt;n&lt;/em&gt;（1 ≤ &lt;em&gt;n&lt;/em&gt; ≤ 30），输出报数序列的第 &lt;em&gt;n&lt;/em&gt; 项。&lt;/p&gt;
&lt;p&gt;注意：整数顺序将表示为一个字符串。&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>lengthOfLongestSubstring_3(java)</title>
    <link href="http://yoursite.com/2019/01/28/lengthOfLongestSubstring-3/"/>
    <id>http://yoursite.com/2019/01/28/lengthOfLongestSubstring-3/</id>
    <published>2019-01-28T14:12:04.000Z</published>
    <updated>2019-01-28T14:50:45.209Z</updated>
    
    <content type="html"><![CDATA[<p>这是本题的地址：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/</a></p><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。<br><a id="more"></a><br>示例 1:<br>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2:</p><p>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3:</p><p>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。</p><p>请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p><h3 id="我的思路："><a href="#我的思路：" class="headerlink" title="我的思路："></a>我的思路：</h3><p>一开始我的思路也是使用类似于“滑动窗口”，但是应该是用到了双循环。所以，超时了不行。很难受，最后看了一下题目的解法。使用“滑动数组”。用int i , j 分别表示窗口的左右边[i,j)。创建一个hashset，用于储存字符。然后通过遍历，每当不相同时，通过判断，给maxlength 赋值给 i-j的长度。 每当有相同的时候，把hashset 里面和 s.charAt(i)相等的字符删除。然后把i往右边移动一位。</p><pre><code>public int lengthOfLongestSubstring(String s) {        int maxlength = 0;        int i=0,j=0;        HashSet hs = new HashSet();        while(i&lt;s.length()&amp;&amp;j&lt;s.length()){            if(!hs.contains(s.charAt(j))){                hs.add(s.charAt(j++));                int value = j-i;                maxlength = maxlength&gt;value?maxlength:value;            }else{                hs.remove(s.charAt(i++));            }        }        return maxlength;    }</code></pre><h3 id="优化："><a href="#优化：" class="headerlink" title="优化："></a>优化：</h3><p>答案中的优化时这样的。使用了hashmap()，遍历时，当不相等，判断sum和j-i+1的长度，（因为i j是2个字符了，所以需要+1长度）。然后给hashmap put一个值 key是当前的字符 value是j+1 代表当前这个字符现在在字符串中的哪个位置。 每当相等时，从hashmap里将这个字符拿出来。对比它和i哪个比较大。如果。然后将值赋给i。相当于i（左边界）右移到了第一个相同字符处。这样就形成了一个“滑动窗口拉”！</p><pre><code>public int lengthOfLongestSubstring2(String s) {    int sum =0;    HashMap&lt;Character,Integer&gt; hm = new HashMap();    for(int i=0,j=0;j&lt;s.length();j++){        if(hm.containsKey(s.charAt(j))){            i = hm.get(s.charAt(j))&gt;i?hm.get(s.charAt(j)):i;        }        sum = sum&gt;j-i+1?sum:j-i+1;        hm.put(s.charAt(j),j+1);    }    return sum;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是本题的地址：&lt;a href=&quot;https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Weekly_competition_121(java)</title>
    <link href="http://yoursite.com/2019/01/27/weekgame-121/"/>
    <id>http://yoursite.com/2019/01/27/weekgame-121/</id>
    <published>2019-01-27T15:14:00.000Z</published>
    <updated>2019-01-28T14:43:48.258Z</updated>
    
    <content type="html"><![CDATA[<p>这是我第一次参加周竞赛，只做对了一题。好垃圾。。。<br><a id="more"></a></p><p>第一题：</p><p>这是原题的地址：<a href="https://leetcode-cn.com/contest/weekly-contest-121/problems/string-without-aaa-or-bbb/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-121/problems/string-without-aaa-or-bbb/</a></p><h2 id="我的思路："><a href="#我的思路：" class="headerlink" title="我的思路："></a>我的思路：</h2><p>用一个flaga flagb 判断a b 是否已经到了2个。然后再通过循环遍历将每一个字符输入进去。最后返回string</p><pre><code>public String strWithout3a3b(int A, int B) {    int longa =0;    int longb =0;    StringBuffer sb = new StringBuffer();    while(A&gt;0||B&gt;0){        if(A&gt;B){            if(longa&lt;2){                longa++;                longb=0;                sb.append(&apos;a&apos;);                A--;            }else{                longa=0;                sb.append(&apos;b&apos;);                B--;            }        }else if(B&gt;A){            if(longb&lt;2){                longb++;                longa=0;                sb.append(&apos;b&apos;);                B--;            }else{                longb=0;                sb.append(&apos;a&apos;);                A--;            }        }else if(A==B){            if(longa&lt;2){                sb.append(&apos;a&apos;);                sb.append(&apos;b&apos;);            }else{                sb.append(&apos;b&apos;);                sb.append(&apos;a&apos;);            }            A--;B--;        }    }    return sb.toString();}</code></pre><h2 id="官方解答："><a href="#官方解答：" class="headerlink" title="官方解答："></a>官方解答：</h2><p>用贪心，先选择当前较多得字母写入字符串中。如果前面两个字符是一样的，下一个写入的字符就不应该相同。地址：<a href="https://leetcode-cn.com/articles/string-without-aaa-or-bbb/" target="_blank" rel="noopener">https://leetcode-cn.com/articles/string-without-aaa-or-bbb/</a></p><h2 id="我的反思："><a href="#我的反思：" class="headerlink" title="我的反思："></a>我的反思：</h2><p>官方比我的代码减少了很多代码量，也不用新建对象。so 要向着简洁前进！！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是我第一次参加周竞赛，只做对了一题。好垃圾。。。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>珠海扬名广场海底捞食记</title>
    <link href="http://yoursite.com/2019/01/26/zh-food1/"/>
    <id>http://yoursite.com/2019/01/26/zh-food1/</id>
    <published>2019-01-26T14:22:56.000Z</published>
    <updated>2019-01-28T07:12:12.544Z</updated>
    
    <content type="html"><![CDATA[<p>hi，这里是何嘉晨的食记，记录一下我每次去吃的餐厅。然后将我的感想在这里抒发出来！ <a id="more"></a></p><p>这次去的是珠海扬名广场的餐厅。因为是一次写所以没有准备拍很多照片。</p><p>这是这次去点的菜：牛肉 血旺 下滑 鸭肠 毛肚 娃娃菜 金针菇 两个人吃 一共261元：<br><img src="/2019/01/26/zh-food1/img/food.jpg" alt=""></p><p>我的评价：我觉得这几个菜里 </p><p>牛肉：火锅点牛肉也是很平常的一件事 ，所以我们就点了一份牛肉其他的都是半份，牛肉很滑煮久了也不会老，听服务员说他们的牛肉是经过腌制的前腿肉和后腿肉。虽然我并不知道前腿肉和后腿肉本来是不是就是这么嫩。。。</p><p>虾滑：我就虾滑也很滑很好吃。没什么特别的吧，感觉大部分的虾滑都差不多。</p><p>血旺就一般般 可能是我不吃辣，服务员说用辣锅煮好吃些。当然他也会给你一叠干辣椒面。</p><p>鸭肠：不用煮很久，吃起来爽爽的，还不错吧。</p><p>毛肚：不用煮很久，感觉吃起来就是有点脆脆的，口感很不错。</p><p>金针菇和娃娃菜：就很普通。。。</p><h2 id="我的总结"><a href="#我的总结" class="headerlink" title="我的总结"></a>我的总结</h2><p>价格：偏贵 味道：一般 服务：挺好的。</p><p>我的觉得海底捞的服务还是很不错的，反正大家都说他们是卖服务的。可能是这次一起吃的人少，所以没有点很多菜色。但是如果你问我是否会有很强烈的意愿再来一次的话：没有。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hi，这里是何嘉晨的食记，记录一下我每次去吃的餐厅。然后将我的感想在这里抒发出来！&lt;/p&gt;
    
    </summary>
    
      <category term="食记" scheme="http://yoursite.com/categories/%E9%A3%9F%E8%AE%B0/"/>
    
    
      <category term="food" scheme="http://yoursite.com/tags/food/"/>
    
      <category term="珠海" scheme="http://yoursite.com/tags/%E7%8F%A0%E6%B5%B7/"/>
    
  </entry>
  
  <entry>
    <title>addTwoNumbers_2(java)</title>
    <link href="http://yoursite.com/2019/01/26/addTwoNumbers-2/"/>
    <id>http://yoursite.com/2019/01/26/addTwoNumbers-2/</id>
    <published>2019-01-26T03:31:15.000Z</published>
    <updated>2019-01-27T08:44:20.898Z</updated>
    
    <content type="html"><![CDATA[<p>这是该题的地址：<a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-two-numbers/</a></p><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。<br>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。<br>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。<br><a id="more"></a><br>示例：</p><p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p><p>我的思路：</p><p>链表是倒序的 所以我们可以从个位开始相加。 然后用一个int flag 来代表进位+1。 有一个firstnode 和一个 endnode 用于判断链表的第一个和最后一个节点。 当一条链为空时，将它与另一条链相等。 这样循环就不用很快跳出了。最后判断最后一位是否有进位，来新增一个节点。最后返回first节点的next。</p><pre><code>public ListNode addTwoNumbers(ListNode l1, ListNode l2) {    int flag =0;    ListNode firstNo = new ListNode(0);    firstNo.next = l1;    ListNode EndNode = new ListNode(0);    while(l1!=null||l2!=null){        int sum;        if(l1==null){            l1=l2;        }else if(l2==null){            l2=l1;        }        if(l1==l2){            sum = l1.val +flag;        }else{            sum = l1.val + l2.val +flag;        }        flag=0;        if(sum&gt;=10){            sum-=10;            flag++;        }        l1.val = sum;        l2.val = sum;        EndNode.next = l1;        EndNode = l1;        l1 = l1.next;        l2 = l2.next;    }    if(flag!=0){        EndNode.next = new ListNode(1);    }    return firstNo.next;}</code></pre><p>我的结果：<br><img src="/2019/01/26/addTwoNumbers-2/img/access.png" alt=""></p><p>官方解答：</p><p>官方题解地址：<br><a href="https://leetcode-cn.com/problems/add-two-numbers/solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-two-numbers/solution/</a></p><p>我的反思：看了官方题解之后，我觉得我的和他的思路差不多。不过他是每次都新增一个，而我则是在原有的节点上进行修改 然后最后再考虑新增。<br>不过不知道为什么他的比我快哈哈~可能是官方的代码更加简洁吧。以后我的代码也要越来越简洁！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是该题的地址：&lt;a href=&quot;https://leetcode-cn.com/problems/add-two-numbers/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/add-two-numbers/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。&lt;br&gt;如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。&lt;br&gt;您可以假设除了数字 0 之外，这两个数都不会以 0 开头。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-searchInsert-35(java)</title>
    <link href="http://yoursite.com/2019/01/25/leetcode-searchInsert-35/"/>
    <id>http://yoursite.com/2019/01/25/leetcode-searchInsert-35/</id>
    <published>2019-01-25T03:16:28.000Z</published>
    <updated>2019-01-29T15:07:54.893Z</updated>
    
    <content type="html"><![CDATA[<p>这是该题的地址：<a href="#https://leetcode-cn.com/problems/search-insert-position/">https://leetcode-cn.com/problems/search-insert-position/</a></p><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。你可以假设数组中无重复元素。<a id="more"></a></p><p>示例 1:</p><p>输入: [1,3,5,6], 5<br>输出: 2<br>示例 2:</p><p>输入: [1,3,5,6], 2<br>输出: 1<br>示例 3:</p><p>输入: [1,3,5,6], 7<br>输出: 4<br>示例 4:</p><p>输入: [1,3,5,6], 0<br>输出: 0</p><p>我的思路：</p><p>从数组第一个数i=0开始遍历。将val和nums[]的值进行比较。假如值超过了或者相等了。那么就将i返回。如果遍历完了都没有返回 就将数组的长度返回</p><pre><code>public int searchInsert(int[] nums, int target) {       for(int i=0;i&lt;nums.length;i++){           if(target==nums[i] || target&lt;nums[i]){               return i;           }       }       return nums.length;   }</code></pre><p>最终的速度：</p><p><img src="/2019/01/25/leetcode-searchInsert-35/img/access.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是该题的地址：&lt;a href=&quot;#https://leetcode-cn.com/problems/search-insert-position/&quot;&gt;https://leetcode-cn.com/problems/search-insert-position/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。你可以假设数组中无重复元素。&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>hello-hexo</title>
    <link href="http://yoursite.com/2019/01/24/hello-hexo/"/>
    <id>http://yoursite.com/2019/01/24/hello-hexo/</id>
    <published>2019-01-24T12:35:01.000Z</published>
    <updated>2019-01-24T12:35:48.847Z</updated>
    
    <content type="html"><![CDATA[<p>我终于开始了我的hexo博客之旅。非常的开心。希望我能够一直坚持下去！！！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我终于开始了我的hexo博客之旅。非常的开心。希望我能够一直坚持下去！！！！！&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
</feed>
