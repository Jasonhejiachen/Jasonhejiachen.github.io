<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>何嘉晨的个人博客</title>
  
  <subtitle>Quality matters more than quantity.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-06-08T09:09:37.647Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>何嘉晨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2的幂_231</title>
    <link href="http://yoursite.com/posts/solution-231/"/>
    <id>http://yoursite.com/posts/solution-231/</id>
    <published>2019-06-08T08:49:50.000Z</published>
    <updated>2019-06-08T09:09:37.647Z</updated>
    
    <content type="html"><![CDATA[<p><strong>难度：</strong><font color="green">简单</font></p><p>这是本题的地址：<a href="https://leetcode-cn.com/problems/power-of-two/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/power-of-two/</a></p><p>给定一个整数，编写一个函数来判断它是否是 2 的幂次方。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 1</span><br><span class="line">输出: true</span><br><span class="line">解释: 20 = 1</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 16</span><br><span class="line">输出: true</span><br><span class="line">解释: 24 = 16</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 218</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>这题看起来很简单，但是这个需要使用二进制的做法来解题，如果时直接求2的次方来解题的话是会超时的。</p><p>重点在于&amp;位运算符的使用。百度百科：按位与运算符”&amp;”是双目运算符。 其功能是参与运算的两数各对应的二进位相与。只有对应的两个二进位均为1时，结果位才为1 ，否则为0。参与运算的数以补码方式出现。</p><p>当一个数可以是2的幂次方时，他的二进制数只有一个位是1。例如 8 就是 1000， 那么8-1 就是 0111。使用&amp;运算符，结果：8&amp;（8-1）==  1000 &amp; 0111 = 0。那么我们就可以通过&amp;运算符来判断数字是否是2的幂次方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n&gt;<span class="number">0</span>&amp;&amp;(n&amp;(n-<span class="number">1</span>))==<span class="number">0</span>?<span class="keyword">true</span>:<span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;难度：&lt;/strong&gt;&lt;font color=&quot;green&quot;&gt;简单&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;这是本题的地址：&lt;a href=&quot;https://leetcode-cn.com/problems/power-of-two/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/power-of-two/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一个整数，编写一个函数来判断它是否是 2 的幂次方。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 20 = 1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: 16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 24 = 16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;示例 3:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: 218&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: false&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="二进制" scheme="http://yoursite.com/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>weekgame_137</title>
    <link href="http://yoursite.com/posts/weekgame-137/"/>
    <id>http://yoursite.com/posts/weekgame-137/</id>
    <published>2019-05-19T13:50:02.000Z</published>
    <updated>2019-05-19T14:20:46.895Z</updated>
    
    <content type="html"><![CDATA[<p>第137周的周竞赛，这次的周竞赛我做出了2题 分别是《最后一块石头的重量》 和 《删除字符串中的所有相邻重复项》 </p><a id="more"></a><h2 id="最后一块石头的重量"><a href="#最后一块石头的重量" class="headerlink" title="最后一块石头的重量"></a>最后一块石头的重量</h2><p>有一堆石头，每块石头的重量都是正整数。</p><p>每一回合，从中选出两块<strong>最重的</strong>石头，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x &lt;= y</code>。那么粉碎的可能结果如下：</p><ul><li>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；</li><li>如果 <code>x != y</code>，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为 <code>y-x</code>。</li></ul><p>最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 <code>0</code>。</p><p><strong>提示：</strong></p><ol><li><code>1 &lt;= stones.length &lt;= 30</code></li><li><code>1 &lt;= stones[i] &lt;= 1000</code></li></ol><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>这道题我是这样思考的，升序排序数组，然后将倒数第一数减去倒数第二数，倒数第二数设为0，然后再进行排序，这样如果最后有剩石头，那么它就一定是最后一个数，如果没有剩石头则最后一个数也是0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastStoneWeight</span><span class="params">(<span class="keyword">int</span>[] stones)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (stones.length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> stones[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stones.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = stones.length - <span class="number">1</span>;</span><br><span class="line">    Arrays.sort(stones);</span><br><span class="line">    <span class="keyword">while</span> (stones[i] != <span class="number">0</span> &amp;&amp; stones[i - <span class="number">1</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">        stones[i] = stones[i] - stones[i - <span class="number">1</span>];</span><br><span class="line">        stones[i - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(stones);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> stones[stones.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除字符串中的所有相邻重复项"><a href="#删除字符串中的所有相邻重复项" class="headerlink" title="删除字符串中的所有相邻重复项"></a>删除字符串中的所有相邻重复项</h2><p>给出由小写字母组成的字符串 <code>S</code>，<strong>重复项删除操作</strong>会选择两个相邻且相同的字母，并删除它们。</p><p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p><p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;abbaca&quot;</span><br><span class="line">输出：&quot;ca&quot;</span><br><span class="line">解释：</span><br><span class="line">例如，在 &quot;abbaca&quot; 中，我们可以删除 &quot;bb&quot; 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 &quot;aaca&quot;，其中又只有 &quot;aa&quot; 可以执行重复项删除操作，所以最后的字符串为 &quot;ca&quot;。</span><br></pre></td></tr></table></figure><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>这道题我是用的回溯法的思路，当遇到第一个相邻的字符时，将这两个字符删掉，并且向前一位开始回溯。回溯进行匹配，如果相同则删掉并继续回溯，如果不同则不用继续回溯。这样最后剩下的字符串就是删到不能删的字符串了。</p><p><strong>关键点：</strong>在回溯完之后，遍历的指针需要返回到回溯到的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">removeDuplicates</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder(S);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sb.length() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sb.charAt(i) == sb.charAt(i + <span class="number">1</span>)) &#123;</span><br><span class="line">            sb.delete(i, i + <span class="number">2</span>);</span><br><span class="line">            <span class="comment">//回到回溯的位置</span></span><br><span class="line">            i -= backChecking(sb, i - <span class="number">1</span>, i, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">backChecking</span><span class="params">(StringBuilder s, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &gt;= s.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">        s.delete(i, j + <span class="number">1</span>);</span><br><span class="line">        num = backChecking(s, i - <span class="number">1</span>, i, num + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回回溯了几次</span></span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第137周的周竞赛，这次的周竞赛我做出了2题 分别是《最后一块石头的重量》 和 《删除字符串中的所有相邻重复项》 &lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="回溯法" scheme="http://yoursite.com/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
      <category term="周竞赛" scheme="http://yoursite.com/tags/%E5%91%A8%E7%AB%9E%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>杨辉三角_118和119</title>
    <link href="http://yoursite.com/posts/solution-118/"/>
    <id>http://yoursite.com/posts/solution-118/</id>
    <published>2019-05-18T03:30:14.000Z</published>
    <updated>2019-05-18T08:06:55.108Z</updated>
    
    <content type="html"><![CDATA[<p>这是该题目的地址：<a href="https://leetcode-cn.com/problems/pascals-triangle/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/pascals-triangle/</a></p><p><strong>难度：</strong><font color="green">简单</font></p><p>给定一个非负整数 <em>numRows，</em>生成杨辉三角的前 <em>numRows</em> 行。</p><p><img src="/posts/solution-118/PascalTriangleAnimated2.gif" alt="img"></p><p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p><a id="more"></a><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">     [1],</span><br><span class="line">    [1,1],</span><br><span class="line">   [1,2,1],</span><br><span class="line">  [1,3,3,1],</span><br><span class="line"> [1,4,6,4,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>简单的思路就是一层层的往下遍历，用图示的计算方式进行计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; nums = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; prior = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= numRows; i++) &#123;</span><br><span class="line">        List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">0</span> || j == i - <span class="number">1</span>) &#123;</span><br><span class="line">                temp.add(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp.add(prior.get(j - <span class="number">1</span>) + prior.get(j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nums.add(temp);</span><br><span class="line">        prior = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="杨辉三角2"><a href="#杨辉三角2" class="headerlink" title="杨辉三角2"></a>杨辉三角2</h1><p>这是该题的地址：<a href="https://leetcode-cn.com/problems/pascals-triangle-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/pascals-triangle-ii/</a></p><p>给定一个非负索引 <em>k</em>，其中 <em>k</em> ≤ 33，返回杨辉三角的第 <em>k</em> 行。</p><p><img src="/posts/solution-118/PascalTriangleAnimated2.gif" alt="img"></p><p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: [1,3,3,1]</span><br></pre></td></tr></table></figure><p><strong>进阶：</strong></p><p>你可以优化你的算法到 <em>O</em>(<em>k</em>) 空间复杂度吗？</p><h2 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h2><p>这题就是要你减少使用的空间复杂度。那么我们可以这样做。</p><p>因为这题只需要返回一层的数据，所以我们也可以用上一题类似的操作，只不过每个层不通过list来区分，而是都放再一起。当新的一层的数据要放入时，旧一层的数据就要逐渐的poll出去。这样整个链表的长度不会超过k。那么空间复杂度应该也是O(k)了吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; ls = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    ls.add(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (rowIndex == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ls;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rowIndex == <span class="number">1</span>) &#123;</span><br><span class="line">        ls.add(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ls;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= rowIndex + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                ls.add(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == i - <span class="number">1</span>) &#123;</span><br><span class="line">                ((LinkedList&lt;Integer&gt;) ls).poll();</span><br><span class="line">                ls.add(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ls.add(ls.get(<span class="number">1</span>) + ls.get(<span class="number">0</span>));</span><br><span class="line">                ((LinkedList&lt;Integer&gt;) ls).poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是该题目的地址：&lt;a href=&quot;https://leetcode-cn.com/problems/pascals-triangle/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/pascals-triangle/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;难度：&lt;/strong&gt;&lt;font color=&quot;green&quot;&gt;简单&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;给定一个非负整数 &lt;em&gt;numRows，&lt;/em&gt;生成杨辉三角的前 &lt;em&gt;numRows&lt;/em&gt; 行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/solution-118/PascalTriangleAnimated2.gif&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;在杨辉三角中，每个数是它左上方和右上方的数的和。&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="杨辉三角" scheme="http://yoursite.com/tags/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/"/>
    
  </entry>
  
  <entry>
    <title>删除排序链表中的重复元素_83</title>
    <link href="http://yoursite.com/posts/Solution-83/"/>
    <id>http://yoursite.com/posts/Solution-83/</id>
    <published>2019-05-15T05:48:04.000Z</published>
    <updated>2019-05-15T09:04:17.717Z</updated>
    
    <content type="html"><![CDATA[<p><strong>难度：</strong><font color="green">简单</font></p><p>这是本题的地址：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/</a></p><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;1-&gt;2</span><br><span class="line">输出: 1-&gt;2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;1-&gt;2-&gt;3-&gt;3</span><br><span class="line">输出: 1-&gt;2-&gt;3</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><h3 id="1、一般大家可能会想到用的比较低效的思路"><a href="#1、一般大家可能会想到用的比较低效的思路" class="headerlink" title="1、一般大家可能会想到用的比较低效的思路"></a>1、一般大家可能会想到用的比较低效的思路</h3><p>通过set的特性：set里面不会有重复的参数，来剥离重复元素。然后通过新建节点的方式重新建立一个链表。</p><p>下面这个例子：我通过将未出现过的元素放入set，然后新建一条没有重复值的列表。但是显然不需要浪费这么多资源来实现这个功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HashSet hs = <span class="keyword">new</span> HashSet();</span><br><span class="line">        ListNode thisNode = head;</span><br><span class="line">        ListNode newhead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode markhead = newhead;</span><br><span class="line">        <span class="keyword">while</span> (thisNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!hs.contains(thisNode.val)) &#123;</span><br><span class="line">                hs.add(thisNode.val);</span><br><span class="line">                newhead.next = <span class="keyword">new</span> ListNode(thisNode.val);</span><br><span class="line">                newhead = newhead.next;</span><br><span class="line">            &#125;</span><br><span class="line">            thisNode = thisNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> markhead.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="2、双指针"><a href="#2、双指针" class="headerlink" title="2、双指针"></a>2、双指针</h3><p>利用双指针，因为题目中已经给出了是排序了的列表，所以我们可以知道相同的数字是会在一起的。那么我们通过两个指针 一个left指针代表一个未重复值的点。right指针则寻找下一个与这个值不重复的点。假如找到了，那么将left.next = right。然后将left=right，继续寻找下一个不重复值的点。时间复杂度为O(n);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates2</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode left = head;</span><br><span class="line">    ListNode right = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left != <span class="keyword">null</span> || right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (right != <span class="keyword">null</span> &amp;&amp; right.val == left.val) &#123;</span><br><span class="line">            right = right.next;</span><br><span class="line">        &#125;</span><br><span class="line">        left.next = right;</span><br><span class="line">        left = left.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>下面这幅图是leetcode上跑得速度对比，上面的是双指针的~：</p><p><img src="/posts/Solution-83/result.png" alt=""></p><p>以上是我的两种思路，其实这题的做法有挺多的，但是我觉得双指针这种做法的代码逻辑会比较清晰~哈哈</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;难度：&lt;/strong&gt;&lt;font color=&quot;green&quot;&gt;简单&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;这是本题的地址：&lt;a href=&quot;https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: 1-&amp;gt;1-&amp;gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 1-&amp;gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 1-&amp;gt;2-&amp;gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="双指针" scheme="http://yoursite.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>leetcode周赛-134</title>
    <link href="http://yoursite.com/posts/weekgame-134/"/>
    <id>http://yoursite.com/posts/weekgame-134/</id>
    <published>2019-05-06T07:39:38.000Z</published>
    <updated>2019-05-18T08:07:16.913Z</updated>
    
    <content type="html"><![CDATA[<p>很久忘记写博客了。。。。感觉最近有点懈怠。。。</p><p>这次记录一下周赛134 我做的两道题目，移动石子直到连续和不相交的线</p><h2 id="1033-移动石子直到连续"><a href="#1033-移动石子直到连续" class="headerlink" title="1033. 移动石子直到连续"></a>1033. 移动石子直到连续</h2><p>三枚石子放置在数轴上，位置分别为 <code>a</code>，<code>b</code>，<code>c</code>。</p><p>每一回合，我们假设这三枚石子当前分别位于位置 <code>x, y, z</code> 且 <code>x &lt; y &lt; z</code>。从位置 <code>x</code> 或者是位置 <code>z</code> 拿起一枚石子，并将该石子移动到某一整数位置 <code>k</code> 处，其中 <code>x &lt; k &lt; z</code> 且 <code>k != y</code>。</p><p>当你无法进行任何移动时，即，这些石子的位置连续时，游戏结束。</p><p>要使游戏结束，你可以执行的最小和最大移动次数分别是多少？ 以长度为 2 的数组形式返回答案：<code>answer = [minimum_moves, maximum_moves]</code></p> <a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：a = 1, b = 2, c = 5</span><br><span class="line">输出：[1, 2]</span><br><span class="line">解释：将石子从 5 移动到 4 再移动到 3，或者我们可以直接将石子移动到 3。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：a = 4, b = 3, c = 2</span><br><span class="line">输出：[0, 0]</span><br><span class="line">解释：我们无法进行任何移动。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= a &lt;= 100</code></li><li><code>1 &lt;= b &lt;= 100</code></li><li><code>1 &lt;= c &lt;= 100</code></li><li><code>a != b, b != c, c != a</code></li></ol><h3 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h3><p>这个题目有一个坑，首先需要排序，将三个石子的顺序排列好，中间的那颗石头b是不动的。通过题目我们可以了解到，要做的就是把3个石头 用最短和最长的次数放到一起。这里有个坑就是 中间不动的石头不一定就是在最终排列的中间，也有可能在最终排列的末尾或者开头。</p><p>那么最短的路径就可能是1 或者 2 ， 最长的路径肯定是a到b的距离+ b到c的距离。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] numMovesStones(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] dict = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        dict[<span class="number">0</span>] = a;</span><br><span class="line">        dict[<span class="number">1</span>] = b;</span><br><span class="line">        dict[<span class="number">2</span>] = c;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dict[j] &gt; dict[i]) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = dict[i];</span><br><span class="line">                    dict[i] = dict[j];</span><br><span class="line">                    dict[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> x = dict[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> y = dict[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> z = dict[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span>[] num = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> left = (y - x - <span class="number">1</span>) &gt; <span class="number">0</span> ? (y - x - <span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = (z - y - <span class="number">1</span>) &gt; <span class="number">0</span> ? (z - y - <span class="number">1</span>) : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>) &#123;</span><br><span class="line">            num[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="number">0</span> || right == <span class="number">0</span>) &#123;</span><br><span class="line">            num[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> min = left &lt; right ? left : right;</span><br><span class="line">            num[<span class="number">0</span>] = <span class="number">2</span> &lt; min ? <span class="number">2</span> : min;</span><br><span class="line">        &#125;</span><br><span class="line">        num[<span class="number">1</span>] = left + right;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="1035-不相交的线"><a href="#1035-不相交的线" class="headerlink" title="1035. 不相交的线"></a>1035. 不相交的线</h2><p>我们在两条独立的水平线上按给定的顺序写下 <code>A</code> 和 <code>B</code> 中的整数。</p><p>现在，我们可以绘制一些连接两个数字 <code>A[i]</code> 和 <code>B[j]</code> 的直线，只要 <code>A[i] == B[j]</code>，且我们绘制的直线不与任何其他连线（非水平线）相交。</p><p>以这种方法绘制线条，并返回我们可以绘制的最大连线数。</p><p><strong>示例 1：</strong></p><p><img src="/posts/weekgame-134/142.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：A = [1,4,2], B = [1,2,4]</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">我们可以画出两条不交叉的线，如上图所示。</span><br><span class="line">我们无法画出第三条不相交的直线，因为从 A[1]=4 到 B[2]=4 的直线将与从 A[2]=2 到 B[1]=2 的直线相交。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：A = [2,5,1,2,5], B = [10,5,2,1,5,2]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：A = [1,3,7,1,7,5], B = [1,9,2,5,1]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= A.length &lt;= 500</code></li><li><code>1 &lt;= B.length &lt;= 500</code></li><li><code>1 &lt;= A[i], B[i] &lt;= 2000</code></li></ol><h3 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a>我的思路</h3><p>这道理有点糊弄人，其实也是很简单的动态规划做法。</p><p>坑： 当题目说是斜线且不能相交时，我失了智，想着去判断前面是否有相交的一条斜线。但其实事情并不需要这么麻烦。</p><p>简单的说，当我一条线段 一个点是i 另一个点是j，可能是斜线也可能是直线，那么如果我们要计算到这条线段会有多少条线最多，那我们要做的无非就是 i-1 j-1  这里最多有多少条线 然后加上1。那么动态规划的规则就很简单了 就是 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f[i][j] = f[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>那么知道了这个 接下来要做的就很简单了~</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxUncrossedLines</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] f = <span class="keyword">new</span> <span class="keyword">int</span>[A.length][B.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; B.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i] == B[j]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((i &gt; <span class="number">0</span>) &amp;&amp; (j &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">                        f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        f[i][j] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((i &gt; <span class="number">0</span>) &amp;&amp; (f[i - <span class="number">1</span>][j] &gt; f[i][j])) &#123;</span><br><span class="line">                    f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((j &gt; <span class="number">0</span>) &amp;&amp; (f[i][j - <span class="number">1</span>] &gt; f[i][j])) &#123;</span><br><span class="line">                    f[i][j] = f[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[A.length - <span class="number">1</span>][B.length - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很久忘记写博客了。。。。感觉最近有点懈怠。。。&lt;/p&gt;
&lt;p&gt;这次记录一下周赛134 我做的两道题目，移动石子直到连续和不相交的线&lt;/p&gt;
&lt;h2 id=&quot;1033-移动石子直到连续&quot;&gt;&lt;a href=&quot;#1033-移动石子直到连续&quot; class=&quot;headerlink&quot; title=&quot;1033. 移动石子直到连续&quot;&gt;&lt;/a&gt;1033. 移动石子直到连续&lt;/h2&gt;&lt;p&gt;三枚石子放置在数轴上，位置分别为 &lt;code&gt;a&lt;/code&gt;，&lt;code&gt;b&lt;/code&gt;，&lt;code&gt;c&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;每一回合，我们假设这三枚石子当前分别位于位置 &lt;code&gt;x, y, z&lt;/code&gt; 且 &lt;code&gt;x &amp;lt; y &amp;lt; z&lt;/code&gt;。从位置 &lt;code&gt;x&lt;/code&gt; 或者是位置 &lt;code&gt;z&lt;/code&gt; 拿起一枚石子，并将该石子移动到某一整数位置 &lt;code&gt;k&lt;/code&gt; 处，其中 &lt;code&gt;x &amp;lt; k &amp;lt; z&lt;/code&gt; 且 &lt;code&gt;k != y&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;当你无法进行任何移动时，即，这些石子的位置连续时，游戏结束。&lt;/p&gt;
&lt;p&gt;要使游戏结束，你可以执行的最小和最大移动次数分别是多少？ 以长度为 2 的数组形式返回答案：&lt;code&gt;answer = [minimum_moves, maximum_moves]&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="周竞赛" scheme="http://yoursite.com/tags/%E5%91%A8%E7%AB%9E%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>寻找峰值_162</title>
    <link href="http://yoursite.com/posts/solution-162/"/>
    <id>http://yoursite.com/posts/solution-162/</id>
    <published>2019-04-24T15:58:01.000Z</published>
    <updated>2019-04-24T16:15:32.669Z</updated>
    
    <content type="html"><![CDATA[<p><strong>难度：</strong><font color="e1e1">中等</font></p><p>这是该题的地址：<a href="https://leetcode-cn.com/problems/find-peak-element/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/find-peak-element/</a></p><p>峰值元素是指其值大于左右相邻值的元素。</p><p>给定一个输入数组 <code>nums</code>，其中 <code>nums[i] ≠ nums[i+1]</code>，找到峰值元素并返回其索引。</p><p>数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。</p><p>你可以假设 <code>nums[-1] = nums[n] = -∞</code>。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,2,3,1]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 3 是峰值元素，你的函数应该返回其索引 2。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,2,1,3,5,6,4]</span><br><span class="line">输出: 1 或 5 </span><br><span class="line">解释: 你的函数可以返回索引 1，其峰值元素为 2；</span><br><span class="line">     或者返回索引 5， 其峰值元素为 6。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><p>你的解法应该是 <em>O</em>(<em>logN</em>) 时间复杂度的。</p><a id="more"></a><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>这题一眼看过去 不是很简单嘛？直接遍历 找 nums[i-1]&lt;nums[i]&gt;nums[i+1] 这个关系式不就好了嘛？但是突然发现时间复杂度应该式logN 那么很显然应该要使用到二分查找法来做这一道题吧。</p><h3 id="二分搜索A（虚假的二分）"><a href="#二分搜索A（虚假的二分）" class="headerlink" title="二分搜索A（虚假的二分）"></a>二分搜索A（虚假的二分）</h3><p>然而我还是想错了，想着用二分搜索，将哪个nums[i-1]&lt;nums[i]&gt;nums[i+1]  的点搜出来直接返回就好了，也就是说我直接对数组二分，查找左半边和右半边第一个符合条件的点。最差的情况下时间复杂度是接近O（n） 比较优的情况下才是O(logN) 虽然AC了题目，但是我觉得这样其实也是不对的答案。我的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nums[<span class="number">0</span>]&gt;nums[<span class="number">1</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nums[nums.length-<span class="number">1</span>]&gt;nums[nums.length-<span class="number">2</span>])&#123;</span><br><span class="line">        <span class="keyword">return</span> nums.length-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">1</span>,right = nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> getPeak(nums,left,right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPeak</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&lt;right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; nums[mid - <span class="number">1</span>] &amp;&amp; nums[mid] &gt; nums[mid + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftpart = getPeak(nums, left, mid);</span><br><span class="line">        <span class="keyword">if</span> (leftpart != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> leftpart;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rightpart = getPeak(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">if</span> (rightpart != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> rightpart;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二分搜索B（真正的二分）"><a href="#二分搜索B（真正的二分）" class="headerlink" title="二分搜索B（真正的二分）"></a>二分搜索B（真正的二分）</h3><p>通过题目我们可以得知，当一个点比他的后一个点大时，那么前面一定有峰值，那么就选择前面的一半继续进行二分，当他比后一个点小的时候，后面一定有峰值，那么就选择后面的那一半进行二分。那么我们可以通过这个关系来进行二分。当left==right时，那个点就是峰值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left =<span class="number">0</span>,right = nums.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]&gt;nums[mid+<span class="number">1</span>])&#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;难度：&lt;/strong&gt;&lt;font color=&quot;e1e1&quot;&gt;中等&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;这是该题的地址：&lt;a href=&quot;https://leetcode-cn.com/problems/find-peak-element/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/find-peak-element/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;峰值元素是指其值大于左右相邻值的元素。&lt;/p&gt;
&lt;p&gt;给定一个输入数组 &lt;code&gt;nums&lt;/code&gt;，其中 &lt;code&gt;nums[i] ≠ nums[i+1]&lt;/code&gt;，找到峰值元素并返回其索引。&lt;/p&gt;
&lt;p&gt;数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。&lt;/p&gt;
&lt;p&gt;你可以假设 &lt;code&gt;nums[-1] = nums[n] = -∞&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: nums = [1,2,3,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 3 是峰值元素，你的函数应该返回其索引 2。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: nums = [1,2,1,3,5,6,4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 1 或 5 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 你的函数可以返回索引 1，其峰值元素为 2；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     或者返回索引 5， 其峰值元素为 6。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你的解法应该是 &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;logN&lt;/em&gt;) 时间复杂度的。&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="二分查找" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>零钱兑换_322</title>
    <link href="http://yoursite.com/posts/solution-322/"/>
    <id>http://yoursite.com/posts/solution-322/</id>
    <published>2019-04-20T07:18:37.000Z</published>
    <updated>2019-04-24T16:16:35.885Z</updated>
    
    <content type="html"><![CDATA[<p><strong>难度：</strong><font color="e1e1">中等</font></p><p>这是该题的地址：<a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/coin-change/</a></p><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code>。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: coins = [1, 2, 5], amount = 11</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 11 = 5 + 5 + 1</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: coins = [2], amount = 3</span><br><span class="line">输出: -1</span><br></pre></td></tr></table></figure><p><strong>说明</strong>:<br>你可以认为每种硬币的数量是无限的。</p><a id="more"></a><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><h3 id="按金额动态规划"><a href="#按金额动态规划" class="headerlink" title="按金额动态规划"></a>按金额动态规划</h3><p>该题我的思路是这样的，首先遍历到amount金额的每个金钱，然后对每个金钱动态规划求最优金额。时间复杂度应该是O(n*m); 我们可以根据这样得出下列推到式：i是当前的金币额度。</p><ol><li>当金钱比硬币大的时候  min[i] = 1+ ｛min[i-coinsA,i-coinsB,i-coinsC…….]｝</li><li>当金钱和硬币相等时 min[i] = 1;</li><li>当这个金钱无法被硬币代表时，值是Integer.MAX_VALUE，后续的操作对它进行判断。</li></ol><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">从1开始 </span><br><span class="line">一块钱的最优解是多少 是1。那么min[1] = 1;</span><br><span class="line">两块的最优解 min[2] = min[2 - 1] + 1 = 2;</span><br><span class="line">三块的最优解 1、min[3 - 1] + 1 = 2  2、min[3] = 1  得出：1&lt;2; </span><br><span class="line">---&gt;min[3] = 1;</span><br><span class="line">四块钱的最优解 1、min[4-1] +1 =2   2、min[4-3] + 1 = 2 </span><br><span class="line">--—&gt; min[4] = 2;</span><br><span class="line">五块钱的最优解 1、min[5-1] + 1 = 3 2、min[5-3] + 1 = 3 得出1&lt;3</span><br><span class="line">---&gt;min[5]= 1;</span><br><span class="line">以此类推 ......  min[11] 进行三次操作 min[11 - 1]+1  min[11 - 3] + 1  min[11-5] + 1 在三个值之中取最小值。min[11] = 3</span><br></pre></td></tr></table></figure><p>代码：</p><p>最后假如这个数是没有硬币对应的 要返回-1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] min = <span class="keyword">new</span> <span class="keyword">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=amount;i++)&#123;</span><br><span class="line">        min[i] = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;coins.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i-coins[j]&gt;<span class="number">0</span> &amp;&amp; min[i-coins[j]]!=Integer.MAX_VALUE)&#123;</span><br><span class="line">                min[i] = min[i-coins[j]] + <span class="number">1</span>&lt; min[i]?min[i-coins[j]]+<span class="number">1</span>:min[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i-coins[j]==<span class="number">0</span>)&#123;</span><br><span class="line">                min[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min[amount]==Integer.MAX_VALUE?-<span class="number">1</span>:min[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;难度：&lt;/strong&gt;&lt;font color=&quot;e1e1&quot;&gt;中等&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;这是该题的地址：&lt;a href=&quot;https://leetcode-cn.com/problems/coin-change/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/coin-change/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 &lt;code&gt;-1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: coins = [1, 2, 5], amount = 11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 3 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 11 = 5 + 5 + 1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: coins = [2], amount = 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: -1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;:&lt;br&gt;你可以认为每种硬币的数量是无限的。&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>最长上升子序列_300</title>
    <link href="http://yoursite.com/posts/solution-300/"/>
    <id>http://yoursite.com/posts/solution-300/</id>
    <published>2019-04-18T13:07:47.000Z</published>
    <updated>2019-04-18T13:49:07.555Z</updated>
    
    <content type="html"><![CDATA[<p><strong>难度：</strong><font color="e1e1">中等</font></p><p>这是本题的地址：<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-increasing-subsequence/</a></p><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [10,9,2,5,3,7,101,18]</span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。</li><li>你算法的时间复杂度应该为 O(<em>n2</em>) 。</li></ul><p><strong>进阶:</strong> 你能将算法的时间复杂度降低到 O(<em>n</em> log <em>n</em>) 吗?</p><a id="more"></a><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>这题一开始看到觉得 是不是可以用双指针，但是发现好像不是很行，因为这个最长上升子序列的值是可以跳跃的，而不是说都是连续的。这样感觉双指针就不好对长度进行划分，从而不是一个好想法</p><h3 id="冒泡遍历"><a href="#冒泡遍历" class="headerlink" title="冒泡遍历"></a>冒泡遍历</h3><p>然后我就按照题目的特性，速度是O(n^2) 则可以使用冒泡这种简单的双重遍历，从动态规划的角度看这个问题，我的想法如下：</p><ol><li>从数组第一个点开始遍历、将当前结点与后续结点进行对比，如果后续结点的值比当前结点的大，则比较后续结点和当前结点的最长子序列哪个更大，保留更大的值。</li><li>最长的子序列不一定在数组的尾部。在每个结点遍历完之后和max值比较，获取最长的子序列。</li><li>因为数组的值是从0开始 而子序的长度是从1开始 所以在最后返回时 值要加1</li></ol><p>如下解例子：</p><p>判断子序列的做法</p><ol><li>i 结点的值要小于 j 结点</li><li>当前点（i）子序列长度+1 和 后续结点（j）子序列长度 进行比较  保留更长的子序列长度</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">数组：[10,9,2,5,3,7,101,18]  当前结点的子序列长度：[0,0,0,0,0,0,0,0]</span><br><span class="line">抛出一个点 10。通过判断子序列的长度 后续的子序列长度为:  [0,0,0,0,0,0,1,1]</span><br><span class="line">抛出一个点9 [0,0,0,0,0,0,1,1]</span><br><span class="line">抛出一个点2 [0,0,0,1,1,1,1,1]</span><br><span class="line">抛出一个点5 [0,0,0,1,1,2,2,2]  特殊点：7比5大 但是5的长度是1+1=2 并没有比原本7的值大 所以长度不变</span><br><span class="line">抛出一个点3 [0,0,0,1,1,2,2,2]</span><br><span class="line">抛出一个点7 [0,0,0,1,1,2,3,3]</span><br><span class="line">抛出一个点101 [0,0,0,1,1,2,3,3]</span><br><span class="line">那么返回的值就是3+1=4.</span><br></pre></td></tr></table></figure><p>下面是代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] max = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    max[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> themax = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[i]) &#123;</span><br><span class="line">                max[j] = max[j] &gt; max[i] + <span class="number">1</span> ? max[j] : max[i] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        themax = themax&gt;max[i]?themax:max[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> themax + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="进阶解法"><a href="#进阶解法" class="headerlink" title="进阶解法"></a>进阶解法</h2><p>进阶解法nlogn 感觉一看就要二分呀… 暂时还没想出来，先挖个坑。</p><p>这个结束之后则获取最优解：</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;难度：&lt;/strong&gt;&lt;font color=&quot;e1e1&quot;&gt;中等&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;这是本题的地址：&lt;a href=&quot;https://leetcode-cn.com/problems/longest-increasing-subsequence/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/longest-increasing-subsequence/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一个无序的整数数组，找到其中最长上升子序列的长度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [10,9,2,5,3,7,101,18]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 4 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。&lt;/li&gt;
&lt;li&gt;你算法的时间复杂度应该为 O(&lt;em&gt;n2&lt;/em&gt;) 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;进阶:&lt;/strong&gt; 你能将算法的时间复杂度降低到 O(&lt;em&gt;n&lt;/em&gt; log &lt;em&gt;n&lt;/em&gt;) 吗?&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>最大值_179</title>
    <link href="http://yoursite.com/posts/solution-179/"/>
    <id>http://yoursite.com/posts/solution-179/</id>
    <published>2019-04-17T01:23:08.000Z</published>
    <updated>2019-04-17T02:15:46.247Z</updated>
    
    <content type="html"><![CDATA[<p><strong>难度：</strong><font color="e1e1">中等</font></p><p>这是本题的地址：<a href="https://leetcode-cn.com/problems/largest-number/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/largest-number/submissions/</a></p><p>给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [10,2]</span><br><span class="line">输出: 210</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,30,34,5,9]</span><br><span class="line">输出: 9534330</span><br></pre></td></tr></table></figure><p><strong>说明:</strong> 输出结果可能非常大，所以你需要返回一个字符串而不是整数。</p><a id="more"></a><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>根据题目，可以知道 这题大概的做法是： 按照一定的排序规则然后用排序算法进行排序。</p><p>首先我们先梳理一下比较规则：先把left right 两个值都转为string（因为题目中提示了字符串，所以用int类型进行比较应该是不合适的） ，这时候两个值的长度可能不相等，这时候我们将他们相加 left+right 和 right+left 这时候两个字符串的长度是相等的，这时候奖left+right 和 right+left 从第一个字符处开始比较，这时候来比较left 和right 哪个值在数组前更好，然后进行位置交换。</p><p>那么在有了比较规则之后，我们可以通过排序算法来让这个值和别的值再进行比较，最后就可以得出一个从大到小的数组，将数组转为string 然后判断第一个字符是否为’0’ （因为如果整个数组都是0的话，他的第一个字符肯定是零，那么返回的string就是’0’而不是”000”）最后返回string。</p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>我用的是比较好理解，但是效率不高的冒泡排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">largestNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = nums[i], right = nums[i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (!BiggerStr(<span class="string">""</span> + left + right, <span class="string">""</span> + right + left)) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">            nums[i] = nums[i + <span class="number">1</span>];</span><br><span class="line">            nums[i + <span class="number">1</span>] = temp;</span><br><span class="line">            BubbleSort(nums, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">        str.append(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (str.charAt(<span class="number">0</span>) == <span class="string">'0'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进行冒泡</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = num; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = nums[i], right = nums[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (BiggerStr(<span class="string">""</span> + left + right, <span class="string">""</span> + right + left)) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">            nums[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">            nums[i - <span class="number">1</span>] = temp;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//比较规则</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">BiggerStr</span><span class="params">(String left, String right)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left.charAt(<span class="number">0</span>) &gt; right.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left.charAt(<span class="number">0</span>) == right.charAt(<span class="number">0</span>) &amp;&amp; left.length() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> BiggerStr(left.substring(<span class="number">1</span>), right.substring(<span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;难度：&lt;/strong&gt;&lt;font color=&quot;e1e1&quot;&gt;中等&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;这是本题的地址：&lt;a href=&quot;https://leetcode-cn.com/problems/largest-number/submissions/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/largest-number/submissions/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [10,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 210&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [3,30,34,5,9]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 9534330&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt; 输出结果可能非常大，所以你需要返回一个字符串而不是整数。&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="最大值" scheme="http://yoursite.com/tags/%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>集成Netty框架的生产者消费者模式</title>
    <link href="http://yoursite.com/posts/%E9%9B%86%E6%88%90Netty%E6%A1%86%E6%9E%B6%E7%9A%84%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/posts/集成Netty框架的生产者消费者模式/</id>
    <published>2019-04-15T05:49:55.000Z</published>
    <updated>2019-04-17T02:33:33.869Z</updated>
    
    <content type="html"><![CDATA[<p>我相信作为一名程序员，每个人都是想要把自己的项目做的越来越好，这是毋庸置疑的。在一次项目中我实现了生产者消费者模式，现在在博客中和大家说说我的做法。</p><h2 id="生产者消费者模式"><a href="#生产者消费者模式" class="headerlink" title="生产者消费者模式"></a>生产者消费者模式</h2><p>下面是生产者模式和消费者模式原型图吧：</p><p><img src="/posts/集成Netty框架的生产者消费者模式/picutre1.png" alt=""></p><p>生产者向缓冲区放入数据，消费者向缓冲区获取数据，如果缓冲区中没有消费者要的数据，消费者就会阻塞。</p><a id="more"></a><h2 id="项目中的应用"><a href="#项目中的应用" class="headerlink" title="项目中的应用"></a>项目中的应用</h2><h3 id="数据流程图"><a href="#数据流程图" class="headerlink" title="数据流程图"></a>数据流程图</h3><p>下面是我在项目中使用阻塞队列实现生产者消费者模式的数据流程图</p><p><img src="/posts/集成Netty框架的生产者消费者模式/picture2.png" alt=""></p><p>在这个图中，当数据推送出去之后 发送数据的方法就成了消费者。而第三方系统则成了生产者，将数据推回本系统中。当消费者从阻塞队列中获取到了数据，就不会继续阻塞。</p><h3 id="关于代码"><a href="#关于代码" class="headerlink" title="关于代码"></a>关于代码</h3><p>在本文就不详细的聊netty框架了（虽然我也是刚接触~），主要是聊项目中的设计模式思想。但是我还是列举一些关键代码。</p><p>这个是ChannelHandler的read方法代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">    String body = (String) msg;</span><br><span class="line">    String newBody = body.substring(body.indexOf(<span class="string">"&#123;"</span>));</span><br><span class="line">    JSONObject object = JSONObject.fromObject(newBody);</span><br><span class="line">    String cmd = object.getString(<span class="string">"cmd"</span>).trim();</span><br><span class="line">    <span class="keyword">if</span> (NETTY_LOGIN.equals(cmd)) &#123;</span><br><span class="line">        <span class="comment">//客户端登陆时将通道保存下来</span></span><br><span class="line">        NettyChannelUtil.setClientCtx(ctx);</span><br><span class="line">        ...忽略</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (NETTY_PING.equals(cmd)) &#123;</span><br><span class="line">        ...忽略</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//将生产者的数据写入阻塞队列中</span></span><br><span class="line">        String SEQ = object.getString(<span class="string">"SEQ"</span>);</span><br><span class="line">        BlockingQueue blockingQueue = NettyChannelUtil.getResultMap().get(SEQ);</span><br><span class="line">        <span class="keyword">if</span> (blockingQueue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            blockingQueue.add(object);</span><br><span class="line">            NettyChannelUtil.getResultMap().put(SEQ, blockingQueue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是发送数据的方法 代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> JSONObject <span class="title">sendMessage</span><span class="params">(String mapkey, String msg)</span> </span>&#123;</span><br><span class="line">       ...省略</span><br><span class="line">    <span class="comment">//创建新的阻塞队列</span></span><br><span class="line">    NettyChannelUtil.getResultMap().put(mapkey, <span class="keyword">new</span> LinkedBlockingQueue(<span class="number">1</span>));</span><br><span class="line">    <span class="comment">//获取通道，将数据写入。</span></span><br><span class="line">    NettyChannelUtil.getClientCtx().channel().writeAndFlush(msg);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//通过阻塞队列获取数据</span></span><br><span class="line">        JSONObject result = NettyChannelUtil.getResultMap().get(mapkey).poll(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">        NettyChannelUtil.getResultMap().remove(mapkey);</span><br><span class="line">        ...省略</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        ...省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么阻塞队列具体是怎么做的呢？</p><p>通过ConcurrentHashMap，Key是传输过去的包编码，value是一个长度为1的阻塞队列。因为ConcurrenHashMap的特征，voliate关键字保证了value是最新的值，而且具备并发的线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyChannelUtil</span> </span>&#123;</span><br><span class="line"><span class="comment">//存储客户端的通道</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ChannelHandlerContext CLIENT_CTX = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//阻塞队列---生产者消费者模式中的缓冲区。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, BlockingQueue&lt;JSONObject&gt;&gt; RESULT_MAP = <span class="keyword">new</span> ConcurrentHashMap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ConcurrentHashMap&lt;String, BlockingQueue&lt;JSONObject&gt;&gt; getResultMap() &#123;</span><br><span class="line">        <span class="keyword">return</span> RESULT_MAP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ChannelHandlerContext <span class="title">getClientCtx</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CLIENT_CTX;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setClientCtx</span><span class="params">(ChannelHandlerContext clientCtx)</span> </span>&#123;</span><br><span class="line">        CLIENT_CTX = clientCtx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我相信作为一名程序员，每个人都是想要把自己的项目做的越来越好，这是毋庸置疑的。在一次项目中我实现了生产者消费者模式，现在在博客中和大家说说我的做法。&lt;/p&gt;
&lt;h2 id=&quot;生产者消费者模式&quot;&gt;&lt;a href=&quot;#生产者消费者模式&quot; class=&quot;headerlink&quot; title=&quot;生产者消费者模式&quot;&gt;&lt;/a&gt;生产者消费者模式&lt;/h2&gt;&lt;p&gt;下面是生产者模式和消费者模式原型图吧：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/集成Netty框架的生产者消费者模式/picutre1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;生产者向缓冲区放入数据，消费者向缓冲区获取数据，如果缓冲区中没有消费者要的数据，消费者就会阻塞。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="生产者消费者模式" scheme="http://yoursite.com/tags/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>链表排序_148</title>
    <link href="http://yoursite.com/posts/solution-148/"/>
    <id>http://yoursite.com/posts/solution-148/</id>
    <published>2019-04-10T14:42:10.000Z</published>
    <updated>2019-04-17T06:26:55.541Z</updated>
    
    <content type="html"><![CDATA[<p><strong>难度：</strong><font color="e1e1">中等</font></p><p>这是本题的地址：<a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sort-list/</a></p><p>在 <em>O</em>(<em>n</em> log <em>n</em>) 时间复杂度和常数级空间复杂度下，对链表进行排序。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 4-&gt;2-&gt;1-&gt;3</span><br><span class="line">输出: 1-&gt;2-&gt;3-&gt;4</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: -1-&gt;5-&gt;3-&gt;4-&gt;0</span><br><span class="line">输出: -1-&gt;0-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>我觉得这题不仅考查了链表还考查了排序的知识，是一道非常好的题目吧~</p><p>看到题目中的时间复杂度O(nlogn) ，就可以知道我们要使用一些比较搞笑的排序算法，比如快速排序、归并排序等等。像冒泡排序等时间复杂度为n^2的排序算法肯定是不适用的~</p><h3 id="1、归并排序"><a href="#1、归并排序" class="headerlink" title="1、归并排序"></a>1、归并排序</h3><p>归并排序有分治的思想，所以他的排序速度会更快。</p><p>在链表里使用归并排序有下列几个注意点：</p><p>1、分治法获取中点使用快慢指针，这样慢指针就肯定在中点处了</p><p>2、分治之后，左链表的尾部是中点，而右链表则是从中点开始往后。这样不断分治，最小的链表只有1个节点。</p><p>3、将左右链表合并进行排序，首先记录下合并的链表的头结点，然后再将后续节点进行对比，最后返回头结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode fast = head, slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    fast = slow.next;</span><br><span class="line">    slow.next = <span class="keyword">null</span>;</span><br><span class="line">    slow = head;</span><br><span class="line">    slow = sortList(slow);</span><br><span class="line">    fast = sortList(fast);</span><br><span class="line">    <span class="keyword">return</span> sort(fast, slow);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">sort</span><span class="params">(ListNode left, ListNode right)</span> </span>&#123;</span><br><span class="line">    ListNode firstNode, otherNode;</span><br><span class="line">    <span class="keyword">if</span> (left.val &lt; right.val) &#123;</span><br><span class="line">        firstNode = left;</span><br><span class="line">        left = left.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        firstNode = right;</span><br><span class="line">        right = right.next;</span><br><span class="line">    &#125;</span><br><span class="line">    otherNode = firstNode;</span><br><span class="line">    <span class="keyword">while</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (left.val &lt; right.val) &#123;</span><br><span class="line">            otherNode.next = left;</span><br><span class="line">            left = left.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            otherNode.next = right;</span><br><span class="line">            right = right.next;</span><br><span class="line">        &#125;</span><br><span class="line">        otherNode = otherNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        otherNode.next = left;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        otherNode.next = right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> firstNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、快速排序"><a href="#2、快速排序" class="headerlink" title="2、快速排序"></a>2、快速排序</h3><p>….之后更新！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;难度：&lt;/strong&gt;&lt;font color=&quot;e1e1&quot;&gt;中等&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;这是本题的地址：&lt;a href=&quot;https://leetcode-cn.com/problems/sort-list/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/sort-list/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在 &lt;em&gt;O&lt;/em&gt;(&lt;em&gt;n&lt;/em&gt; log &lt;em&gt;n&lt;/em&gt;) 时间复杂度和常数级空间复杂度下，对链表进行排序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: 4-&amp;gt;2-&amp;gt;1-&amp;gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: -1-&amp;gt;5-&amp;gt;3-&amp;gt;4-&amp;gt;0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: -1-&amp;gt;0-&amp;gt;3-&amp;gt;4-&amp;gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="归并排序" scheme="http://yoursite.com/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>移动零_283</title>
    <link href="http://yoursite.com/posts/solution-283/"/>
    <id>http://yoursite.com/posts/solution-283/</id>
    <published>2019-04-09T08:11:39.000Z</published>
    <updated>2019-04-17T06:26:33.859Z</updated>
    
    <content type="html"><![CDATA[<p><strong>难度：</strong><font color="green">简单</font></p><p>真是该题的地址：<a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/move-zeroes/</a></p><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure><p><strong>说明</strong>:</p><ol><li>必须在原数组上操作，不能拷贝额外的数组。</li><li>尽量减少操作次数。</li></ol><a id="more"></a><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>这题主要是让我对交换这个概念有了新的看法吧，所以我就把他记录了下来。</p><p>通过题干我们可以发现，0要到数据的末尾，那么我们刚开始学习java的时候，交换数组两个元素的位置，通常用的是下面这种操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> temp = nums[i];</span><br><span class="line">nums[i] = nums[i+<span class="number">1</span>];</span><br><span class="line">nums[i+<span class="number">1</span>] = temp;</span><br></pre></td></tr></table></figure><p>那么假如我们使用冒泡的话。要把第一个位的0换到最后一个位置上，需要n次的操作。那么把第二个位置的0换到倒数第二个位置上，需要n-2次操作… 以此类推的话我们的算法效率十分的低…</p><h3 id="1、-接近一次遍历。"><a href="#1、-接近一次遍历。" class="headerlink" title="1、 接近一次遍历。"></a>1、 接近一次遍历。</h3><p>这是我一开始的想法，都不知道为啥自己总往复杂的想：当1个0遇到第2个0时，跳过它并和下一个非零进行交换，并且记录遇到了几个0，因为0和0之间相靠的，在找下一个非0点的时候就要跳过前面的0。缺点：我觉得这里最终遍历的点还是多于n了，还是不够好。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> zeronum = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + zeronum; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">                    nums[i] = nums[j];</span><br><span class="line">                    nums[j] = temp;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    zeronum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、-一次遍历"><a href="#2、-一次遍历" class="headerlink" title="2、 一次遍历"></a>2、 一次遍历</h3><p>很巧妙的做法，通过两个指针i 和 j，当指针i为0的时候，将nums[i] 赋值给nums[j] 这样就能在保证顺序的同时去掉0，然后将j到数组末尾的赋值为0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">            nums[j++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;nums.length)&#123;</span><br><span class="line">        nums[j++] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;难度：&lt;/strong&gt;&lt;font color=&quot;green&quot;&gt;简单&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;真是该题的地址：&lt;a href=&quot;https://leetcode-cn.com/problems/move-zeroes/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/move-zeroes/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一个数组 &lt;code&gt;nums&lt;/code&gt;，编写一个函数将所有 &lt;code&gt;0&lt;/code&gt; 移动到数组的末尾，同时保持非零元素的相对顺序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [0,1,0,3,12]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [1,3,12,0,0]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;必须在原数组上操作，不能拷贝额外的数组。&lt;/li&gt;
&lt;li&gt;尽量减少操作次数。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="数组" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>课程表_207</title>
    <link href="http://yoursite.com/posts/solution-207/"/>
    <id>http://yoursite.com/posts/solution-207/</id>
    <published>2019-04-05T13:08:09.000Z</published>
    <updated>2019-04-17T06:26:12.134Z</updated>
    
    <content type="html"><![CDATA[<p><strong>难度：</strong><font color="e1e1">中等</font></p><p>这是该题的地址：<a href="https://leetcode-cn.com/problems/course-schedule/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/course-schedule/</a></p><p>现在你总共有 <em>n</em> 门课需要选，记为 <code>0</code> 到 <code>n-1</code>。</p><p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: <code>[0,1]</code></p><p>给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2, [[1,0]] </span><br><span class="line">输出: true</span><br><span class="line">解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2, [[1,0],[0,1]]</span><br><span class="line">输出: false</span><br><span class="line">解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>这道题其实题目中给出了拓补排序的提示，其实我认为就是判断您当前的图中，是否存在循环，如果有循环肯定不能进行拓补排序，那么就返回失败，如果没有循环，则继续进行拓补排序，最后返回成功。</p><p>拓补排序：简单的说就是把没有入度的结点一个个拿走。代码中可以将要去除的元素给与特定标记来标识。</p><p>在做这道题的时候发现有很多细节可以抠，以下是我的几种方案。</p><p>先贴它们的运行时间，用例是leetcode的测试用例，数组长度是1000：</p><p><img src="/posts/solution-207/picture1.png" alt=""></p><h3 id="1、用set存储以遍历过的数据（严重超时）"><a href="#1、用set存储以遍历过的数据（严重超时）" class="headerlink" title="1、用set存储以遍历过的数据（严重超时）"></a>1、用set存储以遍历过的数据（严重超时）</h3><p>这是我一开始的思路：通过一个set bighs存已遍历过的结点，通过一个set hs 存当前的点所经过的结点，通过这两个set来判断是否存在环的情况，很显然，因为有一个hs.clone操作在for循环里面，这里面的时间复杂度会高的不得了。。。。。而且这个方案确实太麻烦了太笨了。。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">HashSet bighs = <span class="keyword">new</span> HashSet();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (numCourses == <span class="number">0</span> || prerequisites == <span class="keyword">null</span> || prerequisites.length == <span class="number">0</span> || prerequisites[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!bighs.contains(prerequisites[i][<span class="number">0</span>]))&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dfs(prerequisites[i][<span class="number">0</span>],prerequisites,<span class="keyword">new</span> HashSet()))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> key,<span class="keyword">int</span>[][] prerequisites,HashSet hs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(bighs.contains(key))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    hs.add(key);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prerequisites.length;i++)&#123;</span><br><span class="line">        HashSet hs1 = (HashSet) hs.clone();</span><br><span class="line">        <span class="keyword">int</span> nums1 = prerequisites[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(nums1==key)&#123;</span><br><span class="line">            <span class="keyword">if</span>(hs.contains(prerequisites[i][<span class="number">1</span>]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!dfs(prerequisites[i][<span class="number">1</span>],prerequisites,hs1))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    bighs.add(key);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、使用一个数组-nums-来代表当前课程的状态。"><a href="#2、使用一个数组-nums-来代表当前课程的状态。" class="headerlink" title="2、使用一个数组 nums 来代表当前课程的状态。"></a>2、使用一个数组 nums 来代表当前课程的状态。</h3><p>nums的长度是n，数组nums有3个值 0代表未访问 1代表访问中 2代表访问过，每次遍历结点，假如是0就往下进行拓补排序，假如是1就返回false，假如是2就返回true。往下搜索时，对下一个结点继续拓补排序。通过nums这个数组，减少了很多不必要的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish2</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prerequisites.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[prerequisites[i][<span class="number">0</span>]]!=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dfs(prerequisites,nums,prerequisites[i][<span class="number">0</span>]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] prerequisites, <span class="keyword">int</span>[] nums , <span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums[key]==<span class="number">0</span>)&#123;</span><br><span class="line">        nums[key] = <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[key]==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[key]==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prerequisites.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(prerequisites[i][<span class="number">0</span>]==key)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dfs(prerequisites,nums,prerequisites[i][<span class="number">1</span>]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nums[key] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、Arraylist储存数组数据"><a href="#3、Arraylist储存数组数据" class="headerlink" title="3、Arraylist储存数组数据"></a>3、Arraylist储存数组数据</h3><p>将数据从二维数组中存放到arraylist中，这样在深搜递归时，arraylist的随机访问获取元素比遍历数组快。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish3</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; arrayLists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">        arrayLists.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prerequisites.length;i++)&#123;</span><br><span class="line">        arrayLists.get(prerequisites[i][<span class="number">0</span>]).add(prerequisites[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prerequisites.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[prerequisites[i][<span class="number">0</span>]]!=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dfs(arrayLists,nums,prerequisites[i][<span class="number">0</span>]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; arrayList,<span class="keyword">int</span>[] nums,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums[key]==<span class="number">0</span>)&#123;</span><br><span class="line">        nums[key] = <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[key]==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[key]==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> ls:arrayList.get(key))&#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfs(arrayList,nums,ls))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nums[key]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;难度：&lt;/strong&gt;&lt;font color=&quot;e1e1&quot;&gt;中等&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;这是该题的地址：&lt;a href=&quot;https://leetcode-cn.com/problems/course-schedule/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/course-schedule/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;现在你总共有 &lt;em&gt;n&lt;/em&gt; 门课需要选，记为 &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;n-1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: &lt;code&gt;[0,1]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: 2, [[1,0]] &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: 2, [[1,0],[0,1]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>岛屿的个数_200</title>
    <link href="http://yoursite.com/posts/numIslands%E5%B2%9B%E5%B1%BF%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>http://yoursite.com/posts/numIslands岛屿的个数/</id>
    <published>2019-04-01T13:32:38.000Z</published>
    <updated>2019-04-01T14:36:46.180Z</updated>
    
    <content type="html"><![CDATA[<p><strong>难度：</strong><font color="e1e1">中等</font></p><p>这是该题的地址：<a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-islands/</a></p><p>给定一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">11110</span><br><span class="line">11010</span><br><span class="line">11000</span><br><span class="line">00000</span><br><span class="line"></span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">11000</span><br><span class="line">11000</span><br><span class="line">00100</span><br><span class="line">00011</span><br><span class="line"></span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>这题其实是一套简单的图的遍历的题目，建立一个新的数组用于代表当前的点有无被访问过，然后对数组进行遍历，当是陆地是进行深搜，将每一块陆地都找出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (grid.length == <span class="number">0</span> || grid == <span class="keyword">null</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[][] init = <span class="keyword">new</span> <span class="keyword">int</span>[grid.length][grid[<span class="number">0</span>].length];</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; init.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; init[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (init[i][j] != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">'\u0001'</span>) &#123;</span><br><span class="line">                    num ++;</span><br><span class="line">                    nextLand(grid, i, j + <span class="number">1</span>, init);</span><br><span class="line">                    nextLand(grid, i + <span class="number">1</span>, j, init);</span><br><span class="line">                    nextLand(grid, i, j - <span class="number">1</span>, init);</span><br><span class="line">                    nextLand(grid, i - <span class="number">1</span>, j, init);</span><br><span class="line">                &#125;</span><br><span class="line">                init[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nextLand</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>[][] init)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> flag = left &gt;= <span class="number">0</span> &amp;&amp; right &gt;= <span class="number">0</span> &amp;&amp; left &lt; grid.length &amp;&amp; right &lt; grid[<span class="number">0</span>].length</span><br><span class="line">            &amp;&amp; grid[left][right] == <span class="string">'\u0001'</span> &amp;&amp; init[left][right] != <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        init[left][right] = <span class="number">1</span>;</span><br><span class="line">        nextLand(grid, left, right + <span class="number">1</span>, init);</span><br><span class="line">        nextLand(grid, left + <span class="number">1</span>, right, init);</span><br><span class="line">        nextLand(grid, left, right - <span class="number">1</span>, init);</span><br><span class="line">        nextLand(grid, left - <span class="number">1</span>, right, init);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;难度：&lt;/strong&gt;&lt;font color=&quot;e1e1&quot;&gt;中等&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;这是该题的地址：&lt;a href=&quot;https://leetcode-cn.com/problems/number-of-islands/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/number-of-islands/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一个由 &lt;code&gt;&amp;#39;1&amp;#39;&lt;/code&gt;（陆地）和 &lt;code&gt;&amp;#39;0&amp;#39;&lt;/code&gt;（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11110&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11010&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;00000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;00100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;00011&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>至少有K个重复字符的最长子串_395</title>
    <link href="http://yoursite.com/posts/solution-395/"/>
    <id>http://yoursite.com/posts/solution-395/</id>
    <published>2019-03-26T15:20:33.000Z</published>
    <updated>2019-03-27T08:09:18.199Z</updated>
    
    <content type="html"><![CDATA[<p><strong>难度：</strong><font color="e1e1">中等</font></p><p>这是本题的地址：<a href="https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/</a></p><p>找到给定字符串（由小写字符组成）中的最长子串 <strong>T</strong> ， 要求 <strong>T</strong> 中的每一字符出现次数都不少于 <em>k</em> 。输出 <strong>T</strong> 的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aaabb&quot;, k = 3</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">最长子串为 &quot;aaa&quot; ，其中 &apos;a&apos; 重复了 3 次。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;ababbc&quot;, k = 2</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">最长子串为 &quot;ababb&quot; ，其中 &apos;a&apos; 重复了 2 次， &apos;b&apos; 重复了 3 次。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>这题有一个思路点，使用长度为26的数组（代表26个小写字母）用于保存每个字符在字符串中出现了几次，如果有出现数小于k的字符，说明这个字符一定不能在字符串里。</p><p>这样就会出现就好像图里的这种情况。</p><p><img src="/posts/solution-395/picture.jpg" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestSubstring</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.length()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    HashMap&lt;Character,Integer&gt; hashMap = <span class="keyword">new</span> HashMap(<span class="number">26</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span>(hashMap.containsKey(c))&#123;</span><br><span class="line">            hashMap.put(c,hashMap.get(c)+<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            hashMap.put(c,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span>(hashMap.get(c)&lt;k)&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(longestSubstring(s.substring(<span class="number">0</span>,i),k),</span><br><span class="line">                    longestSubstring(s.substring(i+<span class="number">1</span>,s.length()),k));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码，第一遍历计算字符串的字符出现了几次，第二遍历计算当出现&lt;k的字符时，将字符串分开并重新计算字符串满足k最长字串，最后返回。看起来好像没什么问题，但是这段代码超时了。。。感觉也符合之前的思想，让我很不解。我感觉可能是出现了重复子问题的原因，如图的示例，找到最长子串aa 反而遍历了3次aa字符串 感觉有点麻烦？</p><p><img src="/posts/solution-395/picture2.jpg" alt=""></p><p>那么既然超时了，我们就应该优化一下代码。前面的不需要优化，就优化后面字符串的处理把。网上有这样的一种处理方法：通过两个指针begin和 end 来处理结点，每当遇到&lt;k的字符时，计算begin-》end的长度。和当前的长度比大小。但是我觉得和我之前的想法基本没差。。都是一样的想法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestSubstring2</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.length()==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    HashMap&lt;Character,Integer&gt; hashMap = <span class="keyword">new</span> HashMap(<span class="number">26</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">        <span class="keyword">if</span>(hashMap.containsKey(c))&#123;</span><br><span class="line">            hashMap.put(c,hashMap.get(c)+<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            hashMap.put(c,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> fullString = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(Integer i:hashMap.values())&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;k)&#123;</span><br><span class="line">            fullString = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fullString)&#123;</span><br><span class="line">        <span class="keyword">return</span> s.length();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> result=<span class="number">0</span>,begin=<span class="number">0</span>,end;</span><br><span class="line">    <span class="keyword">for</span>(end=<span class="number">0</span>;end&lt;s.length();end++)&#123;</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(end);</span><br><span class="line">        <span class="keyword">if</span>(hashMap.get(c)&lt;k)&#123;</span><br><span class="line">            result = Math.max(result,longestSubstring(s.substring(begin,end),k));</span><br><span class="line">            begin = end +<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(begin&lt;end)&#123;</span><br><span class="line">        result = Math.max(result,longestSubstring(s.substring(begin,end),k));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>没搞懂为什么这样会快很多，我觉得我们的方式都差不多，是我之前的代码遇到了重复子问题嘛。。。感觉也没有，难道是我的代码subStirng过多耗了性能？这是一个需要记录的问题。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;难度：&lt;/strong&gt;&lt;font color=&quot;e1e1&quot;&gt;中等&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;这是本题的地址：&lt;a href=&quot;https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;找到给定字符串（由小写字符组成）中的最长子串 &lt;strong&gt;T&lt;/strong&gt; ， 要求 &lt;strong&gt;T&lt;/strong&gt; 中的每一字符出现次数都不少于 &lt;em&gt;k&lt;/em&gt; 。输出 &lt;strong&gt;T&lt;/strong&gt; 的长度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;s = &amp;quot;aaabb&amp;quot;, k = 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;最长子串为 &amp;quot;aaa&amp;quot; ，其中 &amp;apos;a&amp;apos; 重复了 3 次。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;s = &amp;quot;ababbc&amp;quot;, k = 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;最长子串为 &amp;quot;ababb&amp;quot; ，其中 &amp;apos;a&amp;apos; 重复了 2 次， &amp;apos;b&amp;apos; 重复了 3 次。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>单词接龙_127</title>
    <link href="http://yoursite.com/posts/Solution-127/"/>
    <id>http://yoursite.com/posts/Solution-127/</id>
    <published>2019-03-25T14:08:57.000Z</published>
    <updated>2019-04-17T06:25:11.956Z</updated>
    
    <content type="html"><![CDATA[<p><strong>难度：</strong><font color="e1e1">中等</font></p><p>这是本题的地址：<a href="https://leetcode-cn.com/problems/word-ladder/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/word-ladder/</a></p><p>给定两个单词（<em>beginWord</em> 和 <em>endWord</em>）和一个字典，找到从 <em>beginWord</em> 到 <em>endWord</em> 的最短转换序列的长度。转换需遵循如下规则：</p><ol><li>每次转换只能改变一个字母。</li><li>转换过程中的中间单词必须是字典中的单词。</li></ol><p><strong>说明:</strong></p><ul><li>如果不存在这样的转换序列，返回 0。</li><li>所有单词具有相同的长度。</li><li>所有单词只由小写字母组成。</li><li>字典中不存在重复的单词。</li><li>你可以假设 <em>beginWord</em> 和 <em>endWord</em> 是非空的，且二者不相同。</li></ul><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">beginWord = &quot;hit&quot;,</span><br><span class="line">endWord = &quot;cog&quot;,</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line"></span><br><span class="line">输出: 5</span><br><span class="line"></span><br><span class="line">解释: 一个最短转换序列是 &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;,</span><br><span class="line">     返回它的长度 5。</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">beginWord = &quot;hit&quot;</span><br><span class="line">endWord = &quot;cog&quot;</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line"></span><br><span class="line">输出: 0</span><br><span class="line"></span><br><span class="line">解释: endWord &quot;cog&quot; 不在字典中，所以无法进行转换。</span><br></pre></td></tr></table></figure><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><h3 id="1、BFS"><a href="#1、BFS" class="headerlink" title="1、BFS"></a>1、BFS</h3><p>这题我本来的思路是这样的，使用BFS广度优先搜索，通过一个队列先保存beginword值，然后通过单个字母变化26次，遍历当前的字符串，匹配到wordlist中相应的项，然后把这些项加入队列，并将它们从list中remove。最终找到endword，通过这样广搜肯定能搜索到最短的路径。但值得一提的是，我超时了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//用一个hashSet代替list进行遍历，这样就不会超时了，真坑。</span></span><br><span class="line">    HashSet hashSet = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line">    <span class="keyword">if</span>(!hashSet.contains(endWord))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    ((LinkedList) queue).add(beginWord);</span><br><span class="line">    <span class="keyword">int</span> lengthA =<span class="number">0</span>,lengthB=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(queue.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">        String str = queue.poll();</span><br><span class="line">        <span class="keyword">if</span>(str.equals(endWord))&#123;</span><br><span class="line">            <span class="keyword">return</span> lengthA+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">            <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> j=<span class="string">'a'</span>;j&lt;=<span class="string">'z'</span>;j++)&#123;</span><br><span class="line">                chars[i] = j;</span><br><span class="line">                <span class="keyword">if</span>(hashSet.contains(<span class="keyword">new</span> String(chars)))&#123;</span><br><span class="line">                    queue.add(<span class="keyword">new</span> String(chars));</span><br><span class="line">                    hashSet.remove(<span class="keyword">new</span> String(chars));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lengthB--;</span><br><span class="line">        <span class="keyword">if</span>(lengthB==<span class="number">0</span>)&#123;</span><br><span class="line">            lengthB=queue.size();</span><br><span class="line">            lengthA++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n*26^str.length())</p><h3 id="2、双重BFS"><a href="#2、双重BFS" class="headerlink" title="2、双重BFS"></a>2、双重BFS</h3><p>通过看B站Up主的视频：<a href="https://www.bilibili.com/video/av38705526?from=search&amp;seid=16479832968747750696" target="_blank" rel="noopener">https://www.bilibili.com/video/av38705526?from=search&amp;seid=16479832968747750696</a></p><p>可以使用双重BFS这种更好的解法，就是通过两个队列，一个从beginword开始广搜，另一个从endword开始广搜，当他们相遇时，就是最短的路径，没有相遇就是0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength2</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">    HashSet hashSet = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line">    <span class="keyword">if</span>(!hashSet.contains(endWord))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    Queue&lt;String&gt; queue2 = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    queue.add(beginWord);</span><br><span class="line">    queue2.add(endWord);</span><br><span class="line">    <span class="keyword">int</span> step=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(queue.size()!=<span class="number">0</span>&amp;&amp;queue2.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">        step++;</span><br><span class="line">        <span class="keyword">if</span>(queue.size()&gt;queue2.size())&#123;</span><br><span class="line">            Queue q3 = <span class="keyword">new</span> LinkedList(queue);</span><br><span class="line">            queue = queue2;</span><br><span class="line">            queue2 =q3;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue queue1 = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        <span class="keyword">for</span>(String str:queue)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">                <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">char</span> j=<span class="string">'a'</span>;j&lt;=<span class="string">'z'</span>;j++)&#123;</span><br><span class="line">                    chars[i] = j;</span><br><span class="line">                    <span class="keyword">if</span>(queue2.contains(<span class="keyword">new</span> String(chars)))&#123;</span><br><span class="line">                        <span class="keyword">return</span> step+<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(hashSet.contains(<span class="keyword">new</span> String(chars)))&#123;</span><br><span class="line">                        queue1.add(<span class="keyword">new</span> String(chars));</span><br><span class="line">                        hashSet.remove(<span class="keyword">new</span> String(chars));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        queue = queue1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n*26^(str.lenght()/2))</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然因为直接就用list做操作导致了BFS的超时,但是通过这个我回忆了一下，arraylist的remove确实很耗时，每次删除都会把后面的往前复制一遍。</p><p>没有想到双BFS的操作，以后要善用这些操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;难度：&lt;/strong&gt;&lt;font color=&quot;e1e1&quot;&gt;中等&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;这是本题的地址：&lt;a href=&quot;https://leetcode-cn.com/problems/word-ladder/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/word-ladder/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定两个单词（&lt;em&gt;beginWord&lt;/em&gt; 和 &lt;em&gt;endWord&lt;/em&gt;）和一个字典，找到从 &lt;em&gt;beginWord&lt;/em&gt; 到 &lt;em&gt;endWord&lt;/em&gt; 的最短转换序列的长度。转换需遵循如下规则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每次转换只能改变一个字母。&lt;/li&gt;
&lt;li&gt;转换过程中的中间单词必须是字典中的单词。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果不存在这样的转换序列，返回 0。&lt;/li&gt;
&lt;li&gt;所有单词具有相同的长度。&lt;/li&gt;
&lt;li&gt;所有单词只由小写字母组成。&lt;/li&gt;
&lt;li&gt;字典中不存在重复的单词。&lt;/li&gt;
&lt;li&gt;你可以假设 &lt;em&gt;beginWord&lt;/em&gt; 和 &lt;em&gt;endWord&lt;/em&gt; 是非空的，且二者不相同。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;beginWord = &amp;quot;hit&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;endWord = &amp;quot;cog&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;wordList = [&amp;quot;hot&amp;quot;,&amp;quot;dot&amp;quot;,&amp;quot;dog&amp;quot;,&amp;quot;lot&amp;quot;,&amp;quot;log&amp;quot;,&amp;quot;cog&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 一个最短转换序列是 &amp;quot;hit&amp;quot; -&amp;gt; &amp;quot;hot&amp;quot; -&amp;gt; &amp;quot;dot&amp;quot; -&amp;gt; &amp;quot;dog&amp;quot; -&amp;gt; &amp;quot;cog&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     返回它的长度 5。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="BFS" scheme="http://yoursite.com/tags/BFS/"/>
    
      <category term="双向BFS" scheme="http://yoursite.com/tags/%E5%8F%8C%E5%90%91BFS/"/>
    
  </entry>
  
  <entry>
    <title>乘积最大子序列_152</title>
    <link href="http://yoursite.com/posts/Solution-152/"/>
    <id>http://yoursite.com/posts/Solution-152/</id>
    <published>2019-03-21T14:06:44.000Z</published>
    <updated>2019-04-17T06:27:07.506Z</updated>
    
    <content type="html"><![CDATA[<p><strong>难度：</strong><font color="e1e1">中等</font></p><p>这是该题的地址：<a href="https://leetcode-cn.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-product-subarray/</a></p><p>给定一个整数数组 <code>nums</code> ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,3,-2,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 子数组 [2,3] 有最大乘积 6。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [-2,0,-1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>有想到用动态规划来做，但是没想到使用这种方式。。。保留到前个字符的最大正数和最小负数。这样无论当前数是正数或是负数都能求到最大的乘积。通过动态规划就能得到最大的值了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> max = nums[<span class="number">0</span>], min = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            max = nums[i] &gt; nums[i] * max ? nums[i] : nums[i] * max;</span><br><span class="line">            min = nums[i] &lt; nums[i] * min ? nums[i] : nums[i] * min;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = max;</span><br><span class="line">            max = nums[i] &gt; min * nums[i] ? nums[i] : min * nums[i];</span><br><span class="line">            min = nums[i] &lt; temp * nums[i] ? nums[i] : temp * nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] = max &gt; dp[i - <span class="number">1</span>] ? max : dp[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[nums.length-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;难度：&lt;/strong&gt;&lt;font color=&quot;e1e1&quot;&gt;中等&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;这是该题的地址：&lt;a href=&quot;https://leetcode-cn.com/problems/maximum-product-subarray/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/maximum-product-subarray/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [2,3,-2,4]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 子数组 [2,3] 有最大乘积 6。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [-2,0,-1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>盛最多水的容器_11</title>
    <link href="http://yoursite.com/posts/solution-11/"/>
    <id>http://yoursite.com/posts/solution-11/</id>
    <published>2019-03-18T13:02:28.000Z</published>
    <updated>2019-04-17T06:23:53.982Z</updated>
    
    <content type="html"><![CDATA[<p><strong>难度：</strong><font color="e1e1">中等</font>（感觉没有中等难度啊）</p><p>这是该题的地址：<a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/container-with-most-water/</a></p><p>给定 <em>n</em> 个非负整数 <em>a</em>1，<em>a</em>2，…，<em>a</em>n，每个数代表坐标中的一个点 (<em>i</em>, <em>ai</em>) 。在坐标内画 <em>n</em> 条垂直线，垂直线 <em>i</em> 的两个端点分别为 (<em>i</em>, <em>ai</em>) 和 (<em>i</em>, 0)。找出其中的两条线，使得它们与 <em>x</em> 轴共同构成的容器可以容纳最多的水。</p><p><strong>说明：</strong>你不能倾斜容器，且 <em>n</em> 的值至少为 2。</p><p><img src="/posts/solution-11/question_11.jpg" alt=""></p><p>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p> <a id="more"></a><p><strong>示例:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">7</span>]</span><br><span class="line">输出: <span class="number">49</span></span><br></pre></td></tr></table></figure><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>这个感觉没有中等难度呀。使用双指针的做法，头尾两个指针，得出当前的区域大小，因为区域的大小取决于更小的那一个指针，这时候就要把我们的底线抬高。所以当左指针比右指针小的时候，左指针往右移，右指针同理。相遇的时候就跳出循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left =<span class="number">0</span>,right =height.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> max =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">int</span> min = height[right]&gt;height[left]?height[left]:height[right];</span><br><span class="line">        <span class="keyword">int</span> area = (right-left) * min;</span><br><span class="line">        max = max&gt;area?max:area;</span><br><span class="line">        <span class="keyword">if</span>(height[left]==min)&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;难度：&lt;/strong&gt;&lt;font color=&quot;e1e1&quot;&gt;中等&lt;/font&gt;（感觉没有中等难度啊）&lt;/p&gt;
&lt;p&gt;这是该题的地址：&lt;a href=&quot;https://leetcode-cn.com/problems/container-with-most-water/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/container-with-most-water/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定 &lt;em&gt;n&lt;/em&gt; 个非负整数 &lt;em&gt;a&lt;/em&gt;1，&lt;em&gt;a&lt;/em&gt;2，…，&lt;em&gt;a&lt;/em&gt;n，每个数代表坐标中的一个点 (&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;ai&lt;/em&gt;) 。在坐标内画 &lt;em&gt;n&lt;/em&gt; 条垂直线，垂直线 &lt;em&gt;i&lt;/em&gt; 的两个端点分别为 (&lt;em&gt;i&lt;/em&gt;, &lt;em&gt;ai&lt;/em&gt;) 和 (&lt;em&gt;i&lt;/em&gt;, 0)。找出其中的两条线，使得它们与 &lt;em&gt;x&lt;/em&gt; 轴共同构成的容器可以容纳最多的水。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;你不能倾斜容器，且 &lt;em&gt;n&lt;/em&gt; 的值至少为 2。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/solution-11/question_11.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="双指针" scheme="http://yoursite.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>字母大小写全排列_784</title>
    <link href="http://yoursite.com/posts/letterCasePermutation-784/"/>
    <id>http://yoursite.com/posts/letterCasePermutation-784/</id>
    <published>2019-03-15T09:44:53.000Z</published>
    <updated>2019-04-09T09:09:13.873Z</updated>
    
    <content type="html"><![CDATA[<p><strong>难度：</strong><font color="green">简单</font></p><p>给定一个字符串<code>S</code>，通过将字符串<code>S</code>中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line">输入: S = &quot;a1b2&quot;</span><br><span class="line">输出: [&quot;a1b2&quot;, &quot;a1B2&quot;, &quot;A1b2&quot;, &quot;A1B2&quot;]</span><br><span class="line"></span><br><span class="line">输入: S = &quot;3z4&quot;</span><br><span class="line">输出: [&quot;3z4&quot;, &quot;3Z4&quot;]</span><br><span class="line"></span><br><span class="line">输入: S = &quot;12345&quot;</span><br><span class="line">输出: [&quot;12345&quot;]</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>注意：</strong></p><ul><li><code>S</code> 的长度不超过<code>12</code>。</li><li><code>S</code> 仅由数字和字母组成。</li></ul><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>这题其实不难，将他想象成一颗树，每当是字母的时候分叉，不是字母的时候就不分叉。把所有子树列出来就是每个的字符串了。下面是通过深搜来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCasePermutation</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    list.add(S);</span><br><span class="line">    tolist(list, <span class="number">0</span>, S);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tolist</span><span class="params">(List&lt;String&gt; list, <span class="keyword">int</span> i, String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == s.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Boolean isTrue = (s.charAt(i) &gt;= <span class="string">'a'</span> &amp;&amp; s.charAt(i) &lt;= <span class="string">'z'</span>) || (s.charAt(i) &gt;= <span class="string">'A'</span> &amp;&amp; s.charAt(i) &lt;= <span class="string">'Z'</span>);</span><br><span class="line">    <span class="keyword">if</span> (isTrue) &#123;</span><br><span class="line">        String s1;</span><br><span class="line">        <span class="keyword">if</span> (Character.isLowerCase(s.charAt(i))) &#123;</span><br><span class="line">            s1 = s.substring(<span class="number">0</span>, i) + Character.toUpperCase(s.charAt(i)) + s.substring(i + <span class="number">1</span>, s.length());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            s1 = s.substring(<span class="number">0</span>, i) + Character.toLowerCase(s.charAt(i)) + s.substring(i + <span class="number">1</span>, s.length());</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(s1);</span><br><span class="line">        tolist(list, i + <span class="number">1</span>, s);</span><br><span class="line">        tolist(list, i + <span class="number">1</span>, s1);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tolist(list, i + <span class="number">1</span>, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;难度：&lt;/strong&gt;&lt;font color=&quot;green&quot;&gt;简单&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;给定一个字符串&lt;code&gt;S&lt;/code&gt;，通过将字符串&lt;code&gt;S&lt;/code&gt;中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: S = &amp;quot;a1b2&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [&amp;quot;a1b2&amp;quot;, &amp;quot;a1B2&amp;quot;, &amp;quot;A1b2&amp;quot;, &amp;quot;A1B2&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: S = &amp;quot;3z4&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [&amp;quot;3z4&amp;quot;, &amp;quot;3Z4&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: S = &amp;quot;12345&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: [&amp;quot;12345&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="DFS" scheme="http://yoursite.com/tags/DFS/"/>
    
      <category term="回溯算法" scheme="http://yoursite.com/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>括号生成_22</title>
    <link href="http://yoursite.com/posts/generateParenthesis-22/"/>
    <id>http://yoursite.com/posts/generateParenthesis-22/</id>
    <published>2019-03-07T13:22:33.000Z</published>
    <updated>2019-03-07T14:10:46.921Z</updated>
    
    <content type="html"><![CDATA[<p><strong>难度：</strong><font color="e1e1">中等</font></p><p>这是该题的地址：<a href="https://leetcode-cn.com/problems/generate-parentheses/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/generate-parentheses/</a></p><p>给出 <em>n</em> 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且<strong>有效的</strong>括号组合。</p><p>例如，给出 <em>n</em> = 3，生成结果为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  "((()))",</span><br><span class="line">  "(()())",</span><br><span class="line">  "(())()",</span><br><span class="line">  "()(())",</span><br><span class="line">  "()()()"</span><br><span class="line">]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>这题是我做回溯法的第一题，还是蛮有回溯的意思的 我觉得。</p><p>首先回溯法我觉得第一个特点就是将解答视为一个树，然后对它进行深度优先搜索。</p><p>然后通过剪枝，当违反条件的时候，该结点的子结点下的树都不进行考虑。来减少时间复杂度。</p><p>请看图！：</p><p><img src="/posts/generateParenthesis-22/picture.png" alt="1551965583784"></p><p>根据题干，第一个必须是左括号才能满足有效的括号组合。那么它的下一位就有两种选择方案，分别是左括号或者是右括号，这样进行深度优先搜索。如图：当进行到不符合条件的结点 ”（）） “ 这样是不符合的，那么就可以减掉该结点及其子节点，并返回上一层继续进行深度优先搜索。直到获取到所有答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    List list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    backtarcking(list,<span class="string">""</span>,n,n);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtarcking</span><span class="params">(List list,String s,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&gt;right)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left==<span class="number">0</span>&amp;&amp;right==<span class="number">0</span>)&#123;</span><br><span class="line">        list.add(s);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left!=<span class="number">0</span>)&#123;</span><br><span class="line">        backtarcking(list,s+<span class="string">"("</span>,left-<span class="number">1</span>,right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(right!=<span class="number">0</span>)&#123;</span><br><span class="line">        backtarcking(list,s+<span class="string">")"</span>,left,right-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>做了这道题之后对回溯法有了更加深刻的理解，继续加油！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;难度：&lt;/strong&gt;&lt;font color=&quot;e1e1&quot;&gt;中等&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;这是该题的地址：&lt;a href=&quot;https://leetcode-cn.com/problems/generate-parentheses/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/generate-parentheses/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给出 &lt;em&gt;n&lt;/em&gt; 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且&lt;strong&gt;有效的&lt;/strong&gt;括号组合。&lt;/p&gt;
&lt;p&gt;例如，给出 &lt;em&gt;n&lt;/em&gt; = 3，生成结果为：&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &quot;((()))&quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &quot;(()())&quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &quot;(())()&quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &quot;()(())&quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &quot;()()()&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
      <category term="回溯法" scheme="http://yoursite.com/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
  </entry>
  
</feed>
