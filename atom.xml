<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>何嘉晨的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-30T15:10:10.402Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>何嘉晨</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>longestPalindrome_5</title>
    <link href="http://yoursite.com/2019/01/30/longestPalindrome-5/"/>
    <id>http://yoursite.com/2019/01/30/longestPalindrome-5/</id>
    <published>2019-01-30T06:35:54.000Z</published>
    <updated>2019-01-30T15:10:10.402Z</updated>
    
    <content type="html"><![CDATA[<p>这是本题的地址：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-palindromic-substring/</a></p><p>给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。你可以假设 <code>s</code> 的最大长度为 1000。</p><a id="more"></a><p><strong>示例 1：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">"babad"</span></span><br><span class="line">输出: <span class="string">"bab"</span></span><br><span class="line">注意: <span class="string">"aba"</span> 也是一个有效答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">"cbbd"</span></span><br><span class="line">输出: <span class="string">"bb"</span></span><br></pre></td></tr></table></figure><h2 id="我的思路："><a href="#我的思路：" class="headerlink" title="我的思路："></a>我的思路：</h2><p>有一个String sum =”” 来保存最大的回文。</p><p>有第一个for(int i=0)循环遍历整个字符串。然后第二个字符串由j=i 开始，判断这i j之间是否是回文。如果是，那么j-i+1(加1是因为j和i相同时，也是有一个字符的)是否大于sum的长度。如果大于，那么他们就是最大的回文。</p><p>那么用于判断ij之间是否为回文的方法我是这样做的：先判断当前i j的字符是否相同，如果相同则判断 i j 是否相等或相邻，如果是那么就返回true。如果不是那么进行 i+1 和 j-1的递归。若果i j的字符不相同，则返回false；这样是暴力解法。时间复杂度 n3次方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    String sum = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;s.length();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Panduan(i,j,s))&#123;</span><br><span class="line">                <span class="keyword">if</span>(j-i+<span class="number">1</span>&gt;sum.length())&#123;</span><br><span class="line">                    sum = s.substring(i,j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">Panduan</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,String s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.charAt(a)==s.charAt(b))&#123;</span><br><span class="line">        <span class="keyword">if</span>(a==b||a==b-<span class="number">1</span>||a-<span class="number">1</span>==b)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Panduan(++a,--b,s);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="我的结果："><a href="#我的结果：" class="headerlink" title="我的结果："></a>我的结果：</h2><p><img src="/2019/01/30/longestPalindrome-5/img/access.png" alt=""></p><p>特别的慢：这也是暴力解法的问题所在！</p><p>在官方的解答中：有动态规划和中心扩展算法这两个。等我看懂了再补充上来！~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是本题的地址：&lt;a href=&quot;https://leetcode-cn.com/problems/longest-palindromic-substring/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/longest-palindromic-substring/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一个字符串 &lt;code&gt;s&lt;/code&gt;，找到 &lt;code&gt;s&lt;/code&gt; 中最长的回文子串。你可以假设 &lt;code&gt;s&lt;/code&gt; 的最大长度为 1000。&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>清理：终结处理和垃圾回收</title>
    <link href="http://yoursite.com/2019/01/29/%E6%B8%85%E7%90%86%EF%BC%9A%E7%BB%88%E7%BB%93%E5%A4%84%E7%90%86%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>http://yoursite.com/2019/01/29/清理：终结处理和垃圾回收/</id>
    <published>2019-01-29T15:04:53.000Z</published>
    <updated>2019-01-29T15:07:02.635Z</updated>
    
    <content type="html"><![CDATA[<h2 id="清理：终结处理和垃圾回收"><a href="#清理：终结处理和垃圾回收" class="headerlink" title="清理：终结处理和垃圾回收"></a>清理：终结处理和垃圾回收</h2><p>垃圾回收的三个要点</p><p>1、对象可能不被垃圾回收</p><p>2、垃圾回收并不等于“析构”</p><p>3、垃圾回收只和内存有关</p><a id="more"></a><p>java 中允许调用finalize方法，这个方法却不能作为通用的清理方法。因为程序没有濒临储存空间用完，那么就不需要释放内存。因为垃圾回收也是需要开销的，如果不用它，那么这部分开销就省下来了。那么finalize方法在什么时候可以调用呢：在通过某种创建对象方式以外的方式为对象分配了储存空间，但是java一切皆为对象。。。this is special！ *java中有一种“本地方法”，它是一种在java中调用的非java代码，在jdk1.5时是只支持c/c++的，它可能会调用c的函数来分配对象，也可能调用任何其他语言。so，这些都需要特定的储存释放方法来释放。这时候finalize就有用武之地了。</p><h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><h5 id="1、引用计数"><a href="#1、引用计数" class="headerlink" title="1、引用计数"></a>1、引用计数</h5><p>这是一种很简单但是很慢的垃圾回收技术，每个对象都有一个引用计数器，当有引用链接到对象时，引用计数+1，当引用离开作用域或被置为null，引用计数就会-1，当引用计数=0的时候就回回收对象。</p><p>缺陷：当对象之前存在循环引用，引用计数不为0时但又要被回收的时候，这样对于垃圾回收工作量非常大。引用计数常用来说明垃圾收集的工作方式，没有被应用于任何java虚拟机实现。</p><h5 id="2、自适应垃圾回收技术：停止-复制"><a href="#2、自适应垃圾回收技术：停止-复制" class="headerlink" title="2、自适应垃圾回收技术：停止-复制"></a>2、自适应垃圾回收技术：停止-复制</h5><p>暂停程序的运行，将当前堆所有存活的对象复制到另一个堆，没有被复制的都会被垃圾回收。当对象被复制到新的堆中的时候，它们时一个挨着一个的。所以新堆抱持紧凑排列，以后的分配空间也很简单。</p><p>缺点：</p><p>–1 效率低，需要有两个堆。维护比实际需要多一倍的空间。 某些java虚拟机的处理方式：按需从内存中分配较大块的内存，复制动作发生在他们里面。</p><p>–2 程序进入稳定状态之后可能只会产生少量的垃圾，但是如果用这个还是会将内存从一处复制到另外一处。</p><h5 id="3、自适应垃圾回收技术：标记-清扫"><a href="#3、自适应垃圾回收技术：标记-清扫" class="headerlink" title="3、自适应垃圾回收技术：标记-清扫"></a>3、自适应垃圾回收技术：标记-清扫</h5><p>基于上一份放的问题2，产生了新的垃圾回收机制：标记-清扫。遍历所有的引用，找出活对象并标记，在全部标记完成之后，才会进行清扫工作。把没有标记的对象都进行垃圾回收。这样下来，剩下的空间是不连续的。</p><h4 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h4><p>java虚拟机会进行监视，如果所有对象都稳定，垃圾回收效率降低的话。就使用“标记-清扫”方式，当碎片过多就会使用“停止-复制”，这就是“自适应”垃圾回收机制。</p><h2 id="LAST"><a href="#LAST" class="headerlink" title="LAST"></a>LAST</h2><p>最后 java虚拟机中有许多附加技术用以提升速度，叫做just in time “即时”编译器技术。 当需要装载某些类的时候（通常是为该类创建第一个对象），编译器先找到.class文件。然后将该类的字节码装入内存。之后会有两种做法：</p><p>1、让即时编辑器编译所有代码。</p><p>这种方式有两种缺陷：一、加载动作散落在整个程序生命周期内，累加起来要花更多时间。二、增加可执行代码的长度，降低了程序速度。</p><p>2、让即时编辑器载必要时候才编译。</p><p>也称为惰性评估。这样不会被执行的代码也不会倍jit编译。在java HotSpot技术中采用了此操作。代码每次被执行都会做一些优化。执行的越多跑的越快。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;清理：终结处理和垃圾回收&quot;&gt;&lt;a href=&quot;#清理：终结处理和垃圾回收&quot; class=&quot;headerlink&quot; title=&quot;清理：终结处理和垃圾回收&quot;&gt;&lt;/a&gt;清理：终结处理和垃圾回收&lt;/h2&gt;&lt;p&gt;垃圾回收的三个要点&lt;/p&gt;
&lt;p&gt;1、对象可能不被垃圾回收&lt;/p&gt;
&lt;p&gt;2、垃圾回收并不等于“析构”&lt;/p&gt;
&lt;p&gt;3、垃圾回收只和内存有关&lt;/p&gt;
    
    </summary>
    
      <category term="ThinkinJava" scheme="http://yoursite.com/categories/ThinkinJava/"/>
    
    
      <category term="ThinkinJava" scheme="http://yoursite.com/tags/ThinkinJava/"/>
    
  </entry>
  
  <entry>
    <title>countAndSay_38(java)</title>
    <link href="http://yoursite.com/2019/01/29/countAndSay-38/"/>
    <id>http://yoursite.com/2019/01/29/countAndSay-38/</id>
    <published>2019-01-29T08:59:43.000Z</published>
    <updated>2019-01-29T15:14:35.309Z</updated>
    
    <content type="html"><![CDATA[<p>这是该题的地址<a href="https://leetcode-cn.com/problems/count-and-say/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/count-and-say/</a></p><p>报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.     1</span><br><span class="line">2.     11</span><br><span class="line">3.     21</span><br><span class="line">4.     1211</span><br><span class="line">5.     111221</span><br></pre></td></tr></table></figure><p><code>1</code> 被读作  <code>&quot;one 1&quot;</code>  (<code>&quot;一个一&quot;</code>) , 即 <code>11</code>。<br><code>11</code> 被读作 <code>&quot;two 1s&quot;</code> (<code>&quot;两个一&quot;</code>）, 即 <code>21</code>。<br><code>21</code> 被读作 <code>&quot;one 2&quot;</code>,  “<code>one 1&quot;</code> （<code>&quot;一个二&quot;</code> ,  <code>&quot;一个一&quot;</code>) , 即 <code>1211</code>。</p><p>给定一个正整数 <em>n</em>（1 ≤ <em>n</em> ≤ 30），输出报数序列的第 <em>n</em> 项。</p><p>注意：整数顺序将表示为一个字符串。</p><a id="more"></a> <p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1</span><br><span class="line">输出: &quot;1&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: &quot;1211&quot;</span><br></pre></td></tr></table></figure><h2 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a>我的思路</h2><p>因为题目给了整数n,所以我们应该进行遍历，直到为n的时候输出字符串。 在遍历中，我设定了3个遍历。一个是int sum （用来保存当前字符出现的数量） string now （现在这个字符是怎么样的 例如：11，21 ） string newstr （用来保存字符串的主体 几个now加起来 就是newstr） 通过遍历当前str的值。生成 now 和 newstr。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public String countAndSay(int n) &#123;</span><br><span class="line">        int i=1;</span><br><span class="line">        String str = &quot;1&quot;;</span><br><span class="line">        String now ;</span><br><span class="line">        String newstr ;</span><br><span class="line">        int sum;</span><br><span class="line">        while(i&lt;n)&#123;</span><br><span class="line">            sum = 1;</span><br><span class="line">            now = &quot;&quot;;</span><br><span class="line">            newstr = &quot;&quot;;</span><br><span class="line">            for(int j=0;j&lt;str.length();j++)&#123;</span><br><span class="line">                if(j==0)&#123;</span><br><span class="line">                    now = &quot;&quot;+sum+str.charAt(j);</span><br><span class="line">                &#125; else if(str.charAt(j)==str.charAt(j-1))&#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                    now = &quot;&quot;+ sum+str.charAt(j);</span><br><span class="line">                &#125; else&#123;</span><br><span class="line">                    sum = 1;</span><br><span class="line">                    newstr = newstr + now;</span><br><span class="line">                    now = &quot;&quot;+sum+str.charAt(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            str = newstr + now;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="这是我的结果："><a href="#这是我的结果：" class="headerlink" title="这是我的结果："></a>这是我的结果：</h2><p><img src="/2019/01/29/countAndSay-38/img/picture1.jpg" alt=""></p><p>虽然通过了 但是我觉得很慢，这时候我看了看别人的代码，我觉得我们的时间复杂度差不多啊….. 之后我就发现他们用的是stringbuilder 而我用的是string 所以我对我的代码进行了改版：</p><h2 id="使用Stringbuilder"><a href="#使用Stringbuilder" class="headerlink" title="使用Stringbuilder"></a>使用Stringbuilder</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">countAndSay2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    StringBuilder str = <span class="keyword">new</span> StringBuilder(<span class="string">"1"</span>);</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">        sum = <span class="number">1</span>;</span><br><span class="line">        StringBuilder now = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        StringBuilder newstr = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;str.length();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</span><br><span class="line">                now = <span class="keyword">new</span> StringBuilder(<span class="string">""</span>+sum+str.charAt(j));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(str.charAt(j)==str.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                sum++;</span><br><span class="line">                now = <span class="keyword">new</span> StringBuilder(<span class="string">""</span>+ sum+str.charAt(j));</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                sum = <span class="number">1</span>;</span><br><span class="line">                newstr = newstr.append(now);</span><br><span class="line">                now = <span class="keyword">new</span> StringBuilder(<span class="string">""</span>+sum+str.charAt(j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        str = newstr.append(now);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/2019/01/29/countAndSay-38/img/stringbuilder.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是该题的地址&lt;a href=&quot;https://leetcode-cn.com/problems/count-and-say/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/count-and-say/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1.     1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2.     11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3.     21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4.     1211&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5.     111221&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;1&lt;/code&gt; 被读作  &lt;code&gt;&amp;quot;one 1&amp;quot;&lt;/code&gt;  (&lt;code&gt;&amp;quot;一个一&amp;quot;&lt;/code&gt;) , 即 &lt;code&gt;11&lt;/code&gt;。&lt;br&gt;&lt;code&gt;11&lt;/code&gt; 被读作 &lt;code&gt;&amp;quot;two 1s&amp;quot;&lt;/code&gt; (&lt;code&gt;&amp;quot;两个一&amp;quot;&lt;/code&gt;）, 即 &lt;code&gt;21&lt;/code&gt;。&lt;br&gt;&lt;code&gt;21&lt;/code&gt; 被读作 &lt;code&gt;&amp;quot;one 2&amp;quot;&lt;/code&gt;,  “&lt;code&gt;one 1&amp;quot;&lt;/code&gt; （&lt;code&gt;&amp;quot;一个二&amp;quot;&lt;/code&gt; ,  &lt;code&gt;&amp;quot;一个一&amp;quot;&lt;/code&gt;) , 即 &lt;code&gt;1211&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;给定一个正整数 &lt;em&gt;n&lt;/em&gt;（1 ≤ &lt;em&gt;n&lt;/em&gt; ≤ 30），输出报数序列的第 &lt;em&gt;n&lt;/em&gt; 项。&lt;/p&gt;
&lt;p&gt;注意：整数顺序将表示为一个字符串。&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>lengthOfLongestSubstring_3(java)</title>
    <link href="http://yoursite.com/2019/01/28/lengthOfLongestSubstring-3/"/>
    <id>http://yoursite.com/2019/01/28/lengthOfLongestSubstring-3/</id>
    <published>2019-01-28T14:12:04.000Z</published>
    <updated>2019-01-28T14:50:45.209Z</updated>
    
    <content type="html"><![CDATA[<p>这是本题的地址：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/</a></p><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。<br><a id="more"></a><br>示例 1:<br>输入: “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。<br>示例 2:</p><p>输入: “bbbbb”<br>输出: 1<br>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。<br>示例 3:</p><p>输入: “pwwkew”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。</p><p>请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p><h3 id="我的思路："><a href="#我的思路：" class="headerlink" title="我的思路："></a>我的思路：</h3><p>一开始我的思路也是使用类似于“滑动窗口”，但是应该是用到了双循环。所以，超时了不行。很难受，最后看了一下题目的解法。使用“滑动数组”。用int i , j 分别表示窗口的左右边[i,j)。创建一个hashset，用于储存字符。然后通过遍历，每当不相同时，通过判断，给maxlength 赋值给 i-j的长度。 每当有相同的时候，把hashset 里面和 s.charAt(i)相等的字符删除。然后把i往右边移动一位。</p><pre><code>public int lengthOfLongestSubstring(String s) {        int maxlength = 0;        int i=0,j=0;        HashSet hs = new HashSet();        while(i&lt;s.length()&amp;&amp;j&lt;s.length()){            if(!hs.contains(s.charAt(j))){                hs.add(s.charAt(j++));                int value = j-i;                maxlength = maxlength&gt;value?maxlength:value;            }else{                hs.remove(s.charAt(i++));            }        }        return maxlength;    }</code></pre><h3 id="优化："><a href="#优化：" class="headerlink" title="优化："></a>优化：</h3><p>答案中的优化时这样的。使用了hashmap()，遍历时，当不相等，判断sum和j-i+1的长度，（因为i j是2个字符了，所以需要+1长度）。然后给hashmap put一个值 key是当前的字符 value是j+1 代表当前这个字符现在在字符串中的哪个位置。 每当相等时，从hashmap里将这个字符拿出来。对比它和i哪个比较大。如果。然后将值赋给i。相当于i（左边界）右移到了第一个相同字符处。这样就形成了一个“滑动窗口拉”！</p><pre><code>public int lengthOfLongestSubstring2(String s) {    int sum =0;    HashMap&lt;Character,Integer&gt; hm = new HashMap();    for(int i=0,j=0;j&lt;s.length();j++){        if(hm.containsKey(s.charAt(j))){            i = hm.get(s.charAt(j))&gt;i?hm.get(s.charAt(j)):i;        }        sum = sum&gt;j-i+1?sum:j-i+1;        hm.put(s.charAt(j),j+1);    }    return sum;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是本题的地址：&lt;a href=&quot;https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Weekly_competition_121(java)</title>
    <link href="http://yoursite.com/2019/01/27/weekgame-121/"/>
    <id>http://yoursite.com/2019/01/27/weekgame-121/</id>
    <published>2019-01-27T15:14:00.000Z</published>
    <updated>2019-01-28T14:43:48.258Z</updated>
    
    <content type="html"><![CDATA[<p>这是我第一次参加周竞赛，只做对了一题。好垃圾。。。<br><a id="more"></a></p><p>第一题：</p><p>这是原题的地址：<a href="https://leetcode-cn.com/contest/weekly-contest-121/problems/string-without-aaa-or-bbb/" target="_blank" rel="noopener">https://leetcode-cn.com/contest/weekly-contest-121/problems/string-without-aaa-or-bbb/</a></p><h2 id="我的思路："><a href="#我的思路：" class="headerlink" title="我的思路："></a>我的思路：</h2><p>用一个flaga flagb 判断a b 是否已经到了2个。然后再通过循环遍历将每一个字符输入进去。最后返回string</p><pre><code>public String strWithout3a3b(int A, int B) {    int longa =0;    int longb =0;    StringBuffer sb = new StringBuffer();    while(A&gt;0||B&gt;0){        if(A&gt;B){            if(longa&lt;2){                longa++;                longb=0;                sb.append(&apos;a&apos;);                A--;            }else{                longa=0;                sb.append(&apos;b&apos;);                B--;            }        }else if(B&gt;A){            if(longb&lt;2){                longb++;                longa=0;                sb.append(&apos;b&apos;);                B--;            }else{                longb=0;                sb.append(&apos;a&apos;);                A--;            }        }else if(A==B){            if(longa&lt;2){                sb.append(&apos;a&apos;);                sb.append(&apos;b&apos;);            }else{                sb.append(&apos;b&apos;);                sb.append(&apos;a&apos;);            }            A--;B--;        }    }    return sb.toString();}</code></pre><h2 id="官方解答："><a href="#官方解答：" class="headerlink" title="官方解答："></a>官方解答：</h2><p>用贪心，先选择当前较多得字母写入字符串中。如果前面两个字符是一样的，下一个写入的字符就不应该相同。地址：<a href="https://leetcode-cn.com/articles/string-without-aaa-or-bbb/" target="_blank" rel="noopener">https://leetcode-cn.com/articles/string-without-aaa-or-bbb/</a></p><h2 id="我的反思："><a href="#我的反思：" class="headerlink" title="我的反思："></a>我的反思：</h2><p>官方比我的代码减少了很多代码量，也不用新建对象。so 要向着简洁前进！！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是我第一次参加周竞赛，只做对了一题。好垃圾。。。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>珠海扬名广场海底捞食记</title>
    <link href="http://yoursite.com/2019/01/26/zh-food1/"/>
    <id>http://yoursite.com/2019/01/26/zh-food1/</id>
    <published>2019-01-26T14:22:56.000Z</published>
    <updated>2019-01-28T07:12:12.544Z</updated>
    
    <content type="html"><![CDATA[<p>hi，这里是何嘉晨的食记，记录一下我每次去吃的餐厅。然后将我的感想在这里抒发出来！ <a id="more"></a></p><p>这次去的是珠海扬名广场的餐厅。因为是一次写所以没有准备拍很多照片。</p><p>这是这次去点的菜：牛肉 血旺 下滑 鸭肠 毛肚 娃娃菜 金针菇 两个人吃 一共261元：<br><img src="/2019/01/26/zh-food1/img/food.jpg" alt=""></p><p>我的评价：我觉得这几个菜里 </p><p>牛肉：火锅点牛肉也是很平常的一件事 ，所以我们就点了一份牛肉其他的都是半份，牛肉很滑煮久了也不会老，听服务员说他们的牛肉是经过腌制的前腿肉和后腿肉。虽然我并不知道前腿肉和后腿肉本来是不是就是这么嫩。。。</p><p>虾滑：我就虾滑也很滑很好吃。没什么特别的吧，感觉大部分的虾滑都差不多。</p><p>血旺就一般般 可能是我不吃辣，服务员说用辣锅煮好吃些。当然他也会给你一叠干辣椒面。</p><p>鸭肠：不用煮很久，吃起来爽爽的，还不错吧。</p><p>毛肚：不用煮很久，感觉吃起来就是有点脆脆的，口感很不错。</p><p>金针菇和娃娃菜：就很普通。。。</p><h2 id="我的总结"><a href="#我的总结" class="headerlink" title="我的总结"></a>我的总结</h2><p>价格：偏贵 味道：一般 服务：挺好的。</p><p>我的觉得海底捞的服务还是很不错的，反正大家都说他们是卖服务的。可能是这次一起吃的人少，所以没有点很多菜色。但是如果你问我是否会有很强烈的意愿再来一次的话：没有。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hi，这里是何嘉晨的食记，记录一下我每次去吃的餐厅。然后将我的感想在这里抒发出来！&lt;/p&gt;
    
    </summary>
    
      <category term="食记" scheme="http://yoursite.com/categories/%E9%A3%9F%E8%AE%B0/"/>
    
    
      <category term="food" scheme="http://yoursite.com/tags/food/"/>
    
      <category term="珠海" scheme="http://yoursite.com/tags/%E7%8F%A0%E6%B5%B7/"/>
    
  </entry>
  
  <entry>
    <title>addTwoNumbers_2(java)</title>
    <link href="http://yoursite.com/2019/01/26/addTwoNumbers-2/"/>
    <id>http://yoursite.com/2019/01/26/addTwoNumbers-2/</id>
    <published>2019-01-26T03:31:15.000Z</published>
    <updated>2019-01-27T08:44:20.898Z</updated>
    
    <content type="html"><![CDATA[<p>这是该题的地址：<a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-two-numbers/</a></p><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。<br>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。<br>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。<br><a id="more"></a><br>示例：</p><p>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 = 807</p><p>我的思路：</p><p>链表是倒序的 所以我们可以从个位开始相加。 然后用一个int flag 来代表进位+1。 有一个firstnode 和一个 endnode 用于判断链表的第一个和最后一个节点。 当一条链为空时，将它与另一条链相等。 这样循环就不用很快跳出了。最后判断最后一位是否有进位，来新增一个节点。最后返回first节点的next。</p><pre><code>public ListNode addTwoNumbers(ListNode l1, ListNode l2) {    int flag =0;    ListNode firstNo = new ListNode(0);    firstNo.next = l1;    ListNode EndNode = new ListNode(0);    while(l1!=null||l2!=null){        int sum;        if(l1==null){            l1=l2;        }else if(l2==null){            l2=l1;        }        if(l1==l2){            sum = l1.val +flag;        }else{            sum = l1.val + l2.val +flag;        }        flag=0;        if(sum&gt;=10){            sum-=10;            flag++;        }        l1.val = sum;        l2.val = sum;        EndNode.next = l1;        EndNode = l1;        l1 = l1.next;        l2 = l2.next;    }    if(flag!=0){        EndNode.next = new ListNode(1);    }    return firstNo.next;}</code></pre><p>我的结果：<br><img src="/2019/01/26/addTwoNumbers-2/img/access.png" alt=""></p><p>官方解答：</p><p>官方题解地址：<br><a href="https://leetcode-cn.com/problems/add-two-numbers/solution/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-two-numbers/solution/</a></p><p>我的反思：看了官方题解之后，我觉得我的和他的思路差不多。不过他是每次都新增一个，而我则是在原有的节点上进行修改 然后最后再考虑新增。<br>不过不知道为什么他的比我快哈哈~可能是官方的代码更加简洁吧。以后我的代码也要越来越简洁！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是该题的地址：&lt;a href=&quot;https://leetcode-cn.com/problems/add-two-numbers/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://leetcode-cn.com/problems/add-two-numbers/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。&lt;br&gt;如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。&lt;br&gt;您可以假设除了数字 0 之外，这两个数都不会以 0 开头。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-searchInsert-35(java)</title>
    <link href="http://yoursite.com/2019/01/25/leetcode-searchInsert-35/"/>
    <id>http://yoursite.com/2019/01/25/leetcode-searchInsert-35/</id>
    <published>2019-01-25T03:16:28.000Z</published>
    <updated>2019-01-29T15:07:54.893Z</updated>
    
    <content type="html"><![CDATA[<p>这是该题的地址：<a href="#https://leetcode-cn.com/problems/search-insert-position/">https://leetcode-cn.com/problems/search-insert-position/</a></p><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。你可以假设数组中无重复元素。<a id="more"></a></p><p>示例 1:</p><p>输入: [1,3,5,6], 5<br>输出: 2<br>示例 2:</p><p>输入: [1,3,5,6], 2<br>输出: 1<br>示例 3:</p><p>输入: [1,3,5,6], 7<br>输出: 4<br>示例 4:</p><p>输入: [1,3,5,6], 0<br>输出: 0</p><p>我的思路：</p><p>从数组第一个数i=0开始遍历。将val和nums[]的值进行比较。假如值超过了或者相等了。那么就将i返回。如果遍历完了都没有返回 就将数组的长度返回</p><pre><code>public int searchInsert(int[] nums, int target) {       for(int i=0;i&lt;nums.length;i++){           if(target==nums[i] || target&lt;nums[i]){               return i;           }       }       return nums.length;   }</code></pre><p>最终的速度：</p><p><img src="/2019/01/25/leetcode-searchInsert-35/img/access.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是该题的地址：&lt;a href=&quot;#https://leetcode-cn.com/problems/search-insert-position/&quot;&gt;https://leetcode-cn.com/problems/search-insert-position/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。你可以假设数组中无重复元素。&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>hello-hexo</title>
    <link href="http://yoursite.com/2019/01/24/hello-hexo/"/>
    <id>http://yoursite.com/2019/01/24/hello-hexo/</id>
    <published>2019-01-24T12:35:01.000Z</published>
    <updated>2019-01-24T12:35:48.847Z</updated>
    
    <content type="html"><![CDATA[<p>我终于开始了我的hexo博客之旅。非常的开心。希望我能够一直坚持下去！！！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我终于开始了我的hexo博客之旅。非常的开心。希望我能够一直坚持下去！！！！！&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>leetcode-removeElement-27(java)</title>
    <link href="http://yoursite.com/2019/01/24/leetcode-removeElement-27/"/>
    <id>http://yoursite.com/2019/01/24/leetcode-removeElement-27/</id>
    <published>2019-01-24T12:33:41.000Z</published>
    <updated>2019-01-25T03:26:44.388Z</updated>
    
    <content type="html"><![CDATA[<p>这是该题的地址：<a href="#https://leetcode-cn.com/problems/remove-element">https://leetcode-cn.com/problems/remove-element</a></p><p>给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。<br><a id="more"></a><br>示例:</p><p>给定 nums = [3,2,2,3], val = 3,函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。</p><p>你不需要考虑数组中超出新长度后面的元素。<br>元素可为任意顺序。</p><p>我的思路：</p><p>写一个变量flag赋值数组的长度-1。从最后开始遍历数组。当前数=val时。将当前数和flag处的数位置进行调换。然后flag–<br>最终减剩下的flag+1就是我们要返回的数字。数值=val的数也放到了数组的末端。这样就可以得到我们的想要的结果了！</p><pre><code>public int removeElement(int[] nums, int val) {        if(nums.length==0){            return 0;        }        int flag = nums.length-1;        for(int i=nums.length-1;i&gt;=0;i--){            if(nums[i]==val){                int temp = nums[flag];                nums[flag] = nums[i];                nums[i] = temp;                flag--;            }        }        return flag +1;    }</code></pre><p>最终的速度：</p><p><img src="/2019/01/24/leetcode-removeElement-27/access.jpg" alt=""><br>范例代码：</p><p><img src="/2019/01/24/leetcode-removeElement-27/others.png" alt=""></p><p>我可改进之处：</p><p>不需要判断长度是否位空，也不需要多创建一个temp对象占用空间。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是该题的地址：&lt;a href=&quot;#https://leetcode-cn.com/problems/remove-element&quot;&gt;https://leetcode-cn.com/problems/remove-element&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
</feed>
