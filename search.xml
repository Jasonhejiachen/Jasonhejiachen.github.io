<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[删除排序链表中的重复元素_83]]></title>
    <url>%2Fposts%2FSolution-83%2F</url>
    <content type="text"><![CDATA[难度：简单 这是本题的地址：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/ 给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。 示例 1: 12输入: 1-&gt;1-&gt;2输出: 1-&gt;2 示例 2: 12输入: 1-&gt;1-&gt;2-&gt;3-&gt;3输出: 1-&gt;2-&gt;3 我的思路1、一般大家可能会想到用的比较低效的思路通过set的特性：set里面不会有重复的参数，来剥离重复元素。然后通过新建节点的方式重新建立一个链表。 下面这个例子：我通过将未出现过的元素放入set，然后新建一条没有重复值的列表。但是显然不需要浪费这么多资源来实现这个功能。 123456789101112131415161718public ListNode deleteDuplicates(ListNode head) &#123; if (head == null) &#123; return null; &#125; HashSet hs = new HashSet(); ListNode thisNode = head; ListNode newhead = new ListNode(0); ListNode markhead = newhead; while (thisNode != null) &#123; if (!hs.contains(thisNode.val)) &#123; hs.add(thisNode.val); newhead.next = new ListNode(thisNode.val); newhead = newhead.next; &#125; thisNode = thisNode.next; &#125; return markhead.next; &#125; 2、双指针利用双指针，因为题目中已经给出了是排序了的列表，所以我们可以知道相同的数字是会在一起的。那么我们通过两个指针 一个left指针代表一个未重复值的点。right指针则寻找下一个与这个值不重复的点。假如找到了，那么将left.next = right。然后将left=right，继续寻找下一个不重复值的点。时间复杂度为O(n); 12345678910111213141516public ListNode deleteDuplicates2(ListNode head) &#123; if (head == null) &#123; return null; &#125; ListNode left = head; ListNode right = head; while (left != null || right != null) &#123; while (right != null &amp;&amp; right.val == left.val) &#123; right = right.next; &#125; left.next = right; left = left.next; &#125; return head;&#125; 总结下面这幅图是leetcode上跑得速度对比，上面的是双指针的~： 以上是我的两种思路，其实这题的做法有挺多的，但是我觉得双指针这种做法的代码逻辑会比较清晰~哈哈]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode周赛-134]]></title>
    <url>%2Fposts%2Fweekgame-134%2F</url>
    <content type="text"><![CDATA[很久忘记写博客了。。。。感觉最近有点懈怠。。。 这次记录一下周赛134 我做的两道题目，移动石子直到连续和不相交的线 1033. 移动石子直到连续三枚石子放置在数轴上，位置分别为 a，b，c。 每一回合，我们假设这三枚石子当前分别位于位置 x, y, z 且 x &lt; y &lt; z。从位置 x 或者是位置 z 拿起一枚石子，并将该石子移动到某一整数位置 k 处，其中 x &lt; k &lt; z 且 k != y。 当你无法进行任何移动时，即，这些石子的位置连续时，游戏结束。 要使游戏结束，你可以执行的最小和最大移动次数分别是多少？ 以长度为 2 的数组形式返回答案：answer = [minimum_moves, maximum_moves] 示例 1： 123输入：a = 1, b = 2, c = 5输出：[1, 2]解释：将石子从 5 移动到 4 再移动到 3，或者我们可以直接将石子移动到 3。 示例 2： 123输入：a = 4, b = 3, c = 2输出：[0, 0]解释：我们无法进行任何移动。 提示： 1 &lt;= a &lt;= 100 1 &lt;= b &lt;= 100 1 &lt;= c &lt;= 100 a != b, b != c, c != a 我的思路这个题目有一个坑，首先需要排序，将三个石子的顺序排列好，中间的那颗石头b是不动的。通过题目我们可以了解到，要做的就是把3个石头 用最短和最长的次数放到一起。这里有个坑就是 中间不动的石头不一定就是在最终排列的中间，也有可能在最终排列的末尾或者开头。 那么最短的路径就可能是1 或者 2 ， 最长的路径肯定是a到b的距离+ b到c的距离。 12345678910111213141516171819202122232425262728293031public int[] numMovesStones(int a, int b, int c) &#123; int[] dict = new int[3]; dict[0] = a; dict[1] = b; dict[2] = c; for (int i = 0; i &lt; 3; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; if (dict[j] &gt; dict[i]) &#123; int temp = dict[i]; dict[i] = dict[j]; dict[j] = temp; &#125; &#125; &#125; int x = dict[0]; int y = dict[1]; int z = dict[2]; int[] num = new int[2]; int left = (y - x - 1) &gt; 0 ? (y - x - 1) : 0; int right = (z - y - 1) &gt; 0 ? (z - y - 1) : 0; if (left == 0 &amp;&amp; right == 0) &#123; num[0] = 0; &#125; else if (left == 0 || right == 0) &#123; num[0] = 1; &#125; else &#123; int min = left &lt; right ? left : right; num[0] = 2 &lt; min ? 2 : min; &#125; num[1] = left + right; return num; &#125; 1035. 不相交的线我们在两条独立的水平线上按给定的顺序写下 A 和 B 中的整数。 现在，我们可以绘制一些连接两个数字 A[i] 和 B[j] 的直线，只要 A[i] == B[j]，且我们绘制的直线不与任何其他连线（非水平线）相交。 以这种方法绘制线条，并返回我们可以绘制的最大连线数。 示例 1： 12345输入：A = [1,4,2], B = [1,2,4]输出：2解释：我们可以画出两条不交叉的线，如上图所示。我们无法画出第三条不相交的直线，因为从 A[1]=4 到 B[2]=4 的直线将与从 A[2]=2 到 B[1]=2 的直线相交。 示例 2： 12输入：A = [2,5,1,2,5], B = [10,5,2,1,5,2]输出：3 示例 3： 12输入：A = [1,3,7,1,7,5], B = [1,9,2,5,1]输出：2 提示： 1 &lt;= A.length &lt;= 500 1 &lt;= B.length &lt;= 500 1 &lt;= A[i], B[i] &lt;= 2000 我的思路这道理有点糊弄人，其实也是很简单的动态规划做法。 坑： 当题目说是斜线且不能相交时，我失了智，想着去判断前面是否有相交的一条斜线。但其实事情并不需要这么麻烦。 简单的说，当我一条线段 一个点是i 另一个点是j，可能是斜线也可能是直线，那么如果我们要计算到这条线段会有多少条线最多，那我们要做的无非就是 i-1 j-1 这里最多有多少条线 然后加上1。那么动态规划的规则就很简单了 就是 1f[i][j] = f[i-1][j-1]+1; 那么知道了这个 接下来要做的就很简单了~ 12345678910111213141516171819202122public int maxUncrossedLines(int[] A, int[] B) &#123; int[][] f = new int[A.length][B.length]; for (int i = 0; i &lt; A.length; i++) &#123; for (int j = 0; j &lt; B.length; j++) &#123; if (A[i] == B[j]) &#123; if ((i &gt; 0) &amp;&amp; (j &gt; 0)) &#123; f[i][j] = f[i - 1][j - 1] + 1; &#125; else &#123; f[i][j] = 1; &#125; &#125; if ((i &gt; 0) &amp;&amp; (f[i - 1][j] &gt; f[i][j])) &#123; f[i][j] = f[i - 1][j]; &#125; if ((j &gt; 0) &amp;&amp; (f[i][j - 1] &gt; f[i][j])) &#123; f[i][j] = f[i][j - 1]; &#125; &#125; &#125; return f[A.length - 1][B.length - 1]; &#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>周竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[寻找峰值_162]]></title>
    <url>%2Fposts%2Fsolution-162%2F</url>
    <content type="text"><![CDATA[难度：中等 这是该题的地址：https://leetcode-cn.com/problems/find-peak-element/ 峰值元素是指其值大于左右相邻值的元素。 给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。 数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。 你可以假设 nums[-1] = nums[n] = -∞。 示例 1: 123输入: nums = [1,2,3,1]输出: 2解释: 3 是峰值元素，你的函数应该返回其索引 2。 示例 2: 1234输入: nums = [1,2,1,3,5,6,4]输出: 1 或 5 解释: 你的函数可以返回索引 1，其峰值元素为 2； 或者返回索引 5， 其峰值元素为 6。 说明: 你的解法应该是 O(logN) 时间复杂度的。 我的思路这题一眼看过去 不是很简单嘛？直接遍历 找 nums[i-1]&lt;nums[i]&gt;nums[i+1] 这个关系式不就好了嘛？但是突然发现时间复杂度应该式logN 那么很显然应该要使用到二分查找法来做这一道题吧。 二分搜索A（虚假的二分）然而我还是想错了，想着用二分搜索，将哪个nums[i-1]&lt;nums[i]&gt;nums[i+1] 的点搜出来直接返回就好了，也就是说我直接对数组二分，查找左半边和右半边第一个符合条件的点。最差的情况下时间复杂度是接近O（n） 比较优的情况下才是O(logN) 虽然AC了题目，但是我觉得这样其实也是不对的答案。我的代码如下： 12345678910111213141516171819202122232425262728293031public int findPeakElement(int[] nums) &#123; if(nums.length==1)&#123; return 0; &#125; if(nums[0]&gt;nums[1])&#123; return 0; &#125; if(nums[nums.length-1]&gt;nums[nums.length-2])&#123; return nums.length-1; &#125; int left = 1,right = nums.length-1; return getPeak(nums,left,right);&#125;public int getPeak(int[] nums, int left, int right)&#123; if(left&lt;right) &#123; int mid = left + (right - left) / 2; if (nums[mid] &gt; nums[mid - 1] &amp;&amp; nums[mid] &gt; nums[mid + 1]) &#123; return mid; &#125; int leftpart = getPeak(nums, left, mid); if (leftpart != -1) &#123; return leftpart; &#125; int rightpart = getPeak(nums, mid + 1, right); if (rightpart != -1) &#123; return rightpart; &#125; &#125; return -1;&#125; 二分搜索B（真正的二分）通过题目我们可以得知，当一个点比他的后一个点大时，那么前面一定有峰值，那么就选择前面的一半继续进行二分，当他比后一个点小的时候，后面一定有峰值，那么就选择后面的那一半进行二分。那么我们可以通过这个关系来进行二分。当left==right时，那个点就是峰值。 12345678910111213public int findPeakElement2(int[] nums) &#123; int left =0,right = nums.length-1; while(left&lt;right)&#123; int mid = left + (right-left)/2; if(nums[mid]&gt;nums[mid+1])&#123; right = mid; &#125;else &#123; left = mid+1; &#125; &#125; return left;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零钱兑换_322]]></title>
    <url>%2Fposts%2Fsolution-322%2F</url>
    <content type="text"><![CDATA[难度：中等 这是该题的地址：https://leetcode-cn.com/problems/coin-change/ 给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。 示例 1: 123输入: coins = [1, 2, 5], amount = 11输出: 3 解释: 11 = 5 + 5 + 1 示例 2: 12输入: coins = [2], amount = 3输出: -1 说明:你可以认为每种硬币的数量是无限的。 我的思路按金额动态规划该题我的思路是这样的，首先遍历到amount金额的每个金钱，然后对每个金钱动态规划求最优金额。时间复杂度应该是O(n*m); 我们可以根据这样得出下列推到式：i是当前的金币额度。 当金钱比硬币大的时候 min[i] = 1+ ｛min[i-coinsA,i-coinsB,i-coinsC…….]｝ 当金钱和硬币相等时 min[i] = 1; 当这个金钱无法被硬币代表时，值是Integer.MAX_VALUE，后续的操作对它进行判断。 例子： 12345678910从1开始 一块钱的最优解是多少 是1。那么min[1] = 1;两块的最优解 min[2] = min[2 - 1] + 1 = 2;三块的最优解 1、min[3 - 1] + 1 = 2 2、min[3] = 1 得出：1&lt;2; ---&gt;min[3] = 1;四块钱的最优解 1、min[4-1] +1 =2 2、min[4-3] + 1 = 2 --—&gt; min[4] = 2;五块钱的最优解 1、min[5-1] + 1 = 3 2、min[5-3] + 1 = 3 得出1&lt;3---&gt;min[5]= 1;以此类推 ...... min[11] 进行三次操作 min[11 - 1]+1 min[11 - 3] + 1 min[11-5] + 1 在三个值之中取最小值。min[11] = 3 代码： 最后假如这个数是没有硬币对应的 要返回-1。 1234567891011121314public int coinChange(int[] coins, int amount) &#123; int[] min = new int[amount+1]; for(int i=1;i&lt;=amount;i++)&#123; min[i] = Integer.MAX_VALUE; for(int j=0;j&lt;coins.length;j++)&#123; if(i-coins[j]&gt;0 &amp;&amp; min[i-coins[j]]!=Integer.MAX_VALUE)&#123; min[i] = min[i-coins[j]] + 1&lt; min[i]?min[i-coins[j]]+1:min[i]; &#125;else if(i-coins[j]==0)&#123; min[i] = 1; &#125; &#125; &#125; return min[amount]==Integer.MAX_VALUE?-1:min[amount];&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最长上升子序列_300]]></title>
    <url>%2Fposts%2Fsolution-300%2F</url>
    <content type="text"><![CDATA[难度：中等 这是本题的地址：https://leetcode-cn.com/problems/longest-increasing-subsequence/ 给定一个无序的整数数组，找到其中最长上升子序列的长度。 示例: 123输入: [10,9,2,5,3,7,101,18]输出: 4 解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。 说明: 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。 你算法的时间复杂度应该为 O(n2) 。 进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗? 我的思路这题一开始看到觉得 是不是可以用双指针，但是发现好像不是很行，因为这个最长上升子序列的值是可以跳跃的，而不是说都是连续的。这样感觉双指针就不好对长度进行划分，从而不是一个好想法 冒泡遍历然后我就按照题目的特性，速度是O(n^2) 则可以使用冒泡这种简单的双重遍历，从动态规划的角度看这个问题，我的想法如下： 从数组第一个点开始遍历、将当前结点与后续结点进行对比，如果后续结点的值比当前结点的大，则比较后续结点和当前结点的最长子序列哪个更大，保留更大的值。 最长的子序列不一定在数组的尾部。在每个结点遍历完之后和max值比较，获取最长的子序列。 因为数组的值是从0开始 而子序的长度是从1开始 所以在最后返回时 值要加1 如下解例子： 判断子序列的做法 i 结点的值要小于 j 结点 当前点（i）子序列长度+1 和 后续结点（j）子序列长度 进行比较 保留更长的子序列长度 123456789数组：[10,9,2,5,3,7,101,18] 当前结点的子序列长度：[0,0,0,0,0,0,0,0]抛出一个点 10。通过判断子序列的长度 后续的子序列长度为: [0,0,0,0,0,0,1,1]抛出一个点9 [0,0,0,0,0,0,1,1]抛出一个点2 [0,0,0,1,1,1,1,1]抛出一个点5 [0,0,0,1,1,2,2,2] 特殊点：7比5大 但是5的长度是1+1=2 并没有比原本7的值大 所以长度不变抛出一个点3 [0,0,0,1,1,2,2,2]抛出一个点7 [0,0,0,1,1,2,3,3]抛出一个点101 [0,0,0,1,1,2,3,3]那么返回的值就是3+1=4. 下面是代码： 1234567891011121314151617public int lengthOfLIS(int[] nums) &#123; if (nums.length == 0) &#123; return 0; &#125; int[] max = new int[nums.length]; max[0] = 0; int themax = 0; for (int i = 0; i &lt; nums.length; i++) &#123; for (int j = i + 1; j &lt; nums.length; j++) &#123; if (nums[j] &gt; nums[i]) &#123; max[j] = max[j] &gt; max[i] + 1 ? max[j] : max[i] + 1; &#125; &#125; themax = themax&gt;max[i]?themax:max[i]; &#125; return themax + 1;&#125; 进阶解法进阶解法nlogn 感觉一看就要二分呀… 暂时还没想出来，先挖个坑。 这个结束之后则获取最优解：]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大值_179]]></title>
    <url>%2Fposts%2Fsolution-179%2F</url>
    <content type="text"><![CDATA[难度：中等 这是本题的地址：https://leetcode-cn.com/problems/largest-number/submissions/ 给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。 示例 1: 12输入: [10,2]输出: 210 示例 2: 12输入: [3,30,34,5,9]输出: 9534330 说明: 输出结果可能非常大，所以你需要返回一个字符串而不是整数。 我的思路根据题目，可以知道 这题大概的做法是： 按照一定的排序规则然后用排序算法进行排序。 首先我们先梳理一下比较规则：先把left right 两个值都转为string（因为题目中提示了字符串，所以用int类型进行比较应该是不合适的） ，这时候两个值的长度可能不相等，这时候我们将他们相加 left+right 和 right+left 这时候两个字符串的长度是相等的，这时候奖left+right 和 right+left 从第一个字符处开始比较，这时候来比较left 和right 哪个值在数组前更好，然后进行位置交换。 那么在有了比较规则之后，我们可以通过排序算法来让这个值和别的值再进行比较，最后就可以得出一个从大到小的数组，将数组转为string 然后判断第一个字符是否为’0’ （因为如果整个数组都是0的话，他的第一个字符肯定是零，那么返回的string就是’0’而不是”000”）最后返回string。 冒泡排序我用的是比较好理解，但是效率不高的冒泡排序。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public String largestNumber(int[] nums) &#123; StringBuilder str = new StringBuilder(); for (int i = 0; i &lt; nums.length - 1; i++) &#123; int left = nums[i], right = nums[i + 1]; if (!BiggerStr("" + left + right, "" + right + left)) &#123; int temp = nums[i]; nums[i] = nums[i + 1]; nums[i + 1] = temp; BubbleSort(nums, i); &#125; &#125; for (int i : nums) &#123; str.append(i); &#125; if (str.charAt(0) == '0') &#123; return "0"; &#125; return str.toString();&#125;//进行冒泡void BubbleSort(int[] nums, int num) &#123; for (int i = num; i &gt; 0; i--) &#123; int left = nums[i], right = nums[i - 1]; if (BiggerStr("" + left + right, "" + right + left)) &#123; int temp = nums[i]; nums[i] = nums[i - 1]; nums[i - 1] = temp; &#125; else &#123; return; &#125; &#125;&#125;//比较规则boolean BiggerStr(String left, String right) &#123; if (left.charAt(0) &gt; right.charAt(0)) &#123; return true; &#125; else if (left.charAt(0) == right.charAt(0) &amp;&amp; left.length() &gt; 1) &#123; return BiggerStr(left.substring(1), right.substring(1)); &#125; else &#123; return false; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>排序</tag>
        <tag>最大值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集成Netty框架的生产者消费者模式]]></title>
    <url>%2Fposts%2F%E9%9B%86%E6%88%90Netty%E6%A1%86%E6%9E%B6%E7%9A%84%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[我相信作为一名程序员，每个人都是想要把自己的项目做的越来越好，这是毋庸置疑的。在一次项目中我实现了生产者消费者模式，现在在博客中和大家说说我的做法。 生产者消费者模式下面是生产者模式和消费者模式原型图吧： 生产者向缓冲区放入数据，消费者向缓冲区获取数据，如果缓冲区中没有消费者要的数据，消费者就会阻塞。 项目中的应用数据流程图下面是我在项目中使用阻塞队列实现生产者消费者模式的数据流程图 在这个图中，当数据推送出去之后 发送数据的方法就成了消费者。而第三方系统则成了生产者，将数据推回本系统中。当消费者从阻塞队列中获取到了数据，就不会继续阻塞。 关于代码在本文就不详细的聊netty框架了（虽然我也是刚接触~），主要是聊项目中的设计模式思想。但是我还是列举一些关键代码。 这个是ChannelHandler的read方法代码。 12345678910111213141516171819202122@Overridepublic void channelRead(ChannelHandlerContext ctx, Object msg) &#123; String body = (String) msg; String newBody = body.substring(body.indexOf("&#123;")); JSONObject object = JSONObject.fromObject(newBody); String cmd = object.getString("cmd").trim(); if (NETTY_LOGIN.equals(cmd)) &#123; //客户端登陆时将通道保存下来 NettyChannelUtil.setClientCtx(ctx); ...忽略 &#125; else if (NETTY_PING.equals(cmd)) &#123; ...忽略 &#125; else &#123; //将生产者的数据写入阻塞队列中 String SEQ = object.getString("SEQ"); BlockingQueue blockingQueue = NettyChannelUtil.getResultMap().get(SEQ); if (blockingQueue != null) &#123; blockingQueue.add(object); NettyChannelUtil.getResultMap().put(SEQ, blockingQueue); &#125; &#125;&#125; 这是发送数据的方法 代码： 123456789101112131415private JSONObject sendMessage(String mapkey, String msg) &#123; ...省略 //创建新的阻塞队列 NettyChannelUtil.getResultMap().put(mapkey, new LinkedBlockingQueue(1)); //获取通道，将数据写入。 NettyChannelUtil.getClientCtx().channel().writeAndFlush(msg); try &#123; //通过阻塞队列获取数据 JSONObject result = NettyChannelUtil.getResultMap().get(mapkey).poll(5, TimeUnit.SECONDS); NettyChannelUtil.getResultMap().remove(mapkey); ...省略 return result; &#125; catch (Exception e) &#123; ...省略&#125; 那么阻塞队列具体是怎么做的呢？ 通过ConcurrentHashMap，Key是传输过去的包编码，value是一个长度为1的阻塞队列。因为ConcurrenHashMap的特征，voliate关键字保证了value是最新的值，而且具备并发的线程安全。 123456789101112131415161718public class NettyChannelUtil &#123; //存储客户端的通道 private static ChannelHandlerContext CLIENT_CTX = null; //阻塞队列---生产者消费者模式中的缓冲区。 private static final ConcurrentHashMap&lt;String, BlockingQueue&lt;JSONObject&gt;&gt; RESULT_MAP = new ConcurrentHashMap(); public static ConcurrentHashMap&lt;String, BlockingQueue&lt;JSONObject&gt;&gt; getResultMap() &#123; return RESULT_MAP; &#125; public static ChannelHandlerContext getClientCtx() &#123; return CLIENT_CTX; &#125; public static void setClientCtx(ChannelHandlerContext clientCtx) &#123; CLIENT_CTX = clientCtx; &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>生产者消费者模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表排序_148]]></title>
    <url>%2Fposts%2Fsolution-148%2F</url>
    <content type="text"><![CDATA[难度：中等 这是本题的地址：https://leetcode-cn.com/problems/sort-list/ 在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。 示例 1: 12输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4 示例 2: 12输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5 我的思路我觉得这题不仅考查了链表还考查了排序的知识，是一道非常好的题目吧~ 看到题目中的时间复杂度O(nlogn) ，就可以知道我们要使用一些比较搞笑的排序算法，比如快速排序、归并排序等等。像冒泡排序等时间复杂度为n^2的排序算法肯定是不适用的~ 1、归并排序归并排序有分治的思想，所以他的排序速度会更快。 在链表里使用归并排序有下列几个注意点： 1、分治法获取中点使用快慢指针，这样慢指针就肯定在中点处了 2、分治之后，左链表的尾部是中点，而右链表则是从中点开始往后。这样不断分治，最小的链表只有1个节点。 3、将左右链表合并进行排序，首先记录下合并的链表的头结点，然后再将后续节点进行对比，最后返回头结点。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public ListNode sortList(ListNode head) &#123; if (head == null || head.next == null) &#123; return head; &#125; ListNode fast = head, slow = head; while (fast.next != null &amp;&amp; fast.next.next != null) &#123; fast = fast.next; fast = fast.next; slow = slow.next; &#125; fast = slow.next; slow.next = null; slow = head; slow = sortList(slow); fast = sortList(fast); return sort(fast, slow);&#125;public ListNode sort(ListNode left, ListNode right) &#123; ListNode firstNode, otherNode; if (left.val &lt; right.val) &#123; firstNode = left; left = left.next; &#125; else &#123; firstNode = right; right = right.next; &#125; otherNode = firstNode; while (left != null &amp;&amp; right != null) &#123; if (left.val &lt; right.val) &#123; otherNode.next = left; left = left.next; &#125; else &#123; otherNode.next = right; right = right.next; &#125; otherNode = otherNode.next; &#125; if (left != null) &#123; otherNode.next = left; &#125; else if (right != null) &#123; otherNode.next = right; &#125; return firstNode;&#125; 2、快速排序….之后更新！]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>归并排序</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动零_283]]></title>
    <url>%2Fposts%2Fsolution-283%2F</url>
    <content type="text"><![CDATA[难度：简单 真是该题的地址：https://leetcode-cn.com/problems/move-zeroes/ 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 示例: 12输入: [0,1,0,3,12]输出: [1,3,12,0,0] 说明: 必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。 我的思路这题主要是让我对交换这个概念有了新的看法吧，所以我就把他记录了下来。 通过题干我们可以发现，0要到数据的末尾，那么我们刚开始学习java的时候，交换数组两个元素的位置，通常用的是下面这种操作： 123int temp = nums[i];nums[i] = nums[i+1];nums[i+1] = temp; 那么假如我们使用冒泡的话。要把第一个位的0换到最后一个位置上，需要n次的操作。那么把第二个位置的0换到倒数第二个位置上，需要n-2次操作… 以此类推的话我们的算法效率十分的低… 1、 接近一次遍历。这是我一开始的想法，都不知道为啥自己总往复杂的想：当1个0遇到第2个0时，跳过它并和下一个非零进行交换，并且记录遇到了几个0，因为0和0之间相靠的，在找下一个非0点的时候就要跳过前面的0。缺点：我觉得这里最终遍历的点还是多于n了，还是不够好。 1234567891011121314151617public void moveZeroes(int[] nums) &#123; int zeronum = 1; for (int i = 0; i &lt; nums.length;i++) &#123; if (nums[i] == 0) &#123; for (int j = i + zeronum; j &lt; nums.length; j++) &#123; if (nums[j] != 0) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; break; &#125; else &#123; zeronum++; &#125; &#125; &#125; &#125;&#125; 2、 一次遍历很巧妙的做法，通过两个指针i 和 j，当指针i为0的时候，将nums[i] 赋值给nums[j] 这样就能在保证顺序的同时去掉0，然后将j到数组末尾的赋值为0。 1234567891011public void moveZeroes(int[] nums) &#123; int i,j=0; for(i=0;i&lt;nums.length;i++)&#123; if(nums[i]!=0)&#123; nums[j++] = nums[i]; &#125; &#125; while(j&lt;nums.length)&#123; nums[j++] = 0; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[课程表_207]]></title>
    <url>%2Fposts%2Fsolution-207%2F</url>
    <content type="text"><![CDATA[难度：中等 这是该题的地址：https://leetcode-cn.com/problems/course-schedule/ 现在你总共有 n 门课需要选，记为 0 到 n-1。 在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1] 给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？ 示例 1: 123输入: 2, [[1,0]] 输出: true解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。 示例 2: 123输入: 2, [[1,0],[0,1]]输出: false解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。 我的思路这道题其实题目中给出了拓补排序的提示，其实我认为就是判断您当前的图中，是否存在循环，如果有循环肯定不能进行拓补排序，那么就返回失败，如果没有循环，则继续进行拓补排序，最后返回成功。 拓补排序：简单的说就是把没有入度的结点一个个拿走。代码中可以将要去除的元素给与特定标记来标识。 在做这道题的时候发现有很多细节可以抠，以下是我的几种方案。 先贴它们的运行时间，用例是leetcode的测试用例，数组长度是1000： 1、用set存储以遍历过的数据（严重超时）这是我一开始的思路：通过一个set bighs存已遍历过的结点，通过一个set hs 存当前的点所经过的结点，通过这两个set来判断是否存在环的情况，很显然，因为有一个hs.clone操作在for循环里面，这里面的时间复杂度会高的不得了。。。。。而且这个方案确实太麻烦了太笨了。。 123456789101112131415161718192021222324252627282930313233343536HashSet bighs = new HashSet();public boolean canFinish(int numCourses, int[][] prerequisites) &#123; if (numCourses == 0 || prerequisites == null || prerequisites.length == 0 || prerequisites[0].length == 0) &#123; return true; &#125; for (int i = 0; i &lt; prerequisites.length; i++) &#123; if(!bighs.contains(prerequisites[i][0]))&#123; if(!dfs(prerequisites[i][0],prerequisites,new HashSet()))&#123; return false; &#125; &#125; &#125; return true;&#125;boolean dfs(int key,int[][] prerequisites,HashSet hs)&#123; if(bighs.contains(key))&#123; return true; &#125; hs.add(key); for(int i=0;i&lt;prerequisites.length;i++)&#123; HashSet hs1 = (HashSet) hs.clone(); int nums1 = prerequisites[i][0]; if(nums1==key)&#123; if(hs.contains(prerequisites[i][1]))&#123; return false; &#125; if(!dfs(prerequisites[i][1],prerequisites,hs1))&#123; return false; &#125; &#125; &#125; bighs.add(key); return true;&#125; 2、使用一个数组 nums 来代表当前课程的状态。nums的长度是n，数组nums有3个值 0代表未访问 1代表访问中 2代表访问过，每次遍历结点，假如是0就往下进行拓补排序，假如是1就返回false，假如是2就返回true。往下搜索时，对下一个结点继续拓补排序。通过nums这个数组，减少了很多不必要的操作。 1234567891011121314151617181920212223242526272829303132public boolean canFinish2(int numCourses, int[][] prerequisites) &#123; int[] nums = new int[numCourses]; for(int i=0;i&lt;prerequisites.length;i++)&#123; if(nums[prerequisites[i][0]]!=2)&#123; if(!dfs(prerequisites,nums,prerequisites[i][0]))&#123; return false; &#125; &#125; &#125; return true;&#125;boolean dfs(int[][] prerequisites, int[] nums , int key)&#123; if(nums[key]==0)&#123; nums[key] = 1; &#125;else if(nums[key]==1)&#123; return false; &#125;else if(nums[key]==2)&#123; return true; &#125; for(int i=0;i&lt;prerequisites.length;i++)&#123; if(prerequisites[i][0]==key)&#123; if(!dfs(prerequisites,nums,prerequisites[i][1]))&#123; return false; &#125; &#125; &#125; nums[key] = 2; return true;&#125; 3、Arraylist储存数组数据将数据从二维数组中存放到arraylist中，这样在深搜递归时，arraylist的随机访问获取元素比遍历数组快。 1234567891011121314151617181920212223242526272829303132333435363738public boolean canFinish3(int numCourses, int[][] prerequisites) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; arrayLists = new ArrayList&lt;&gt;(); for(int i=0;i&lt;numCourses;i++)&#123; arrayLists.add(new ArrayList&lt;&gt;()); &#125; for(int i=0;i&lt;prerequisites.length;i++)&#123; arrayLists.get(prerequisites[i][0]).add(prerequisites[i][1]); &#125; int[] nums = new int[numCourses]; for(int i=0;i&lt;prerequisites.length;i++)&#123; if(nums[prerequisites[i][0]]!=2)&#123; if(!dfs(arrayLists,nums,prerequisites[i][0]))&#123; return false; &#125; &#125; &#125; return true;&#125;boolean dfs(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; arrayList,int[] nums,int key)&#123; if(nums[key]==0)&#123; nums[key] = 1; &#125;else if(nums[key]==1)&#123; return false; &#125;else if(nums[key]==2)&#123; return true; &#125; for(int ls:arrayList.get(key))&#123; if(!dfs(arrayList,nums,ls))&#123; return false; &#125; &#125; nums[key]=2; return true;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[岛屿的个数_200]]></title>
    <url>%2Fposts%2FnumIslands%E5%B2%9B%E5%B1%BF%E7%9A%84%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[难度：中等 这是该题的地址：https://leetcode-cn.com/problems/number-of-islands/ 给定一个由 &#39;1&#39;（陆地）和 &#39;0&#39;（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。 示例 1: 1234567输入:11110110101100000000输出: 1 示例 2: 1234567输入:11000110000010000011输出: 3 我的思路这题其实是一套简单的图的遍历的题目，建立一个新的数组用于代表当前的点有无被访问过，然后对数组进行遍历，当是陆地是进行深搜，将每一块陆地都找出来。 12345678910111213141516171819202122232425262728293031323334public int numIslands(char[][] grid) &#123; if (grid.length == 0 || grid == null || grid[0].length == 0) &#123; return 0; &#125; int[][] init = new int[grid.length][grid[0].length]; int num = 0; for (int i = 0; i &lt; init.length; i++) &#123; for (int j = 0; j &lt; init[0].length; j++) &#123; if (init[i][j] != 1) &#123; if (grid[i][j] == '\u0001') &#123; num ++; nextLand(grid, i, j + 1, init); nextLand(grid, i + 1, j, init); nextLand(grid, i, j - 1, init); nextLand(grid, i - 1, j, init); &#125; init[i][j] = 1; &#125; &#125; &#125; return num;&#125;void nextLand(char[][] grid, int left, int right, int[][] init) &#123; boolean flag = left &gt;= 0 &amp;&amp; right &gt;= 0 &amp;&amp; left &lt; grid.length &amp;&amp; right &lt; grid[0].length &amp;&amp; grid[left][right] == '\u0001' &amp;&amp; init[left][right] != 1; if (flag) &#123; init[left][right] = 1; nextLand(grid, left, right + 1, init); nextLand(grid, left + 1, right, init); nextLand(grid, left, right - 1, init); nextLand(grid, left - 1, right, init); &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[至少有K个重复字符的最长子串_395]]></title>
    <url>%2Fposts%2Fsolution-395%2F</url>
    <content type="text"><![CDATA[难度：中等 这是本题的地址：https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/ 找到给定字符串（由小写字符组成）中的最长子串 T ， 要求 T 中的每一字符出现次数都不少于 k 。输出 T 的长度。 示例 1: 1234567输入:s = &quot;aaabb&quot;, k = 3输出:3最长子串为 &quot;aaa&quot; ，其中 &apos;a&apos; 重复了 3 次。 示例 2: 1234567输入:s = &quot;ababbc&quot;, k = 2输出:5最长子串为 &quot;ababb&quot; ，其中 &apos;a&apos; 重复了 2 次， &apos;b&apos; 重复了 3 次。 我的思路这题有一个思路点，使用长度为26的数组（代表26个小写字母）用于保存每个字符在字符串中出现了几次，如果有出现数小于k的字符，说明这个字符一定不能在字符串里。 这样就会出现就好像图里的这种情况。 12345678910111213141516171819202122public int longestSubstring(String s, int k) &#123; if(s.length()==0)&#123; return 0; &#125; HashMap&lt;Character,Integer&gt; hashMap = new HashMap(26); for(int i=0;i&lt;s.length();i++)&#123; char c = s.charAt(i); if(hashMap.containsKey(c))&#123; hashMap.put(c,hashMap.get(c)+1); &#125;else &#123; hashMap.put(c,1); &#125; &#125; for(int i=0;i&lt;s.length();i++)&#123; char c = s.charAt(i); if(hashMap.get(c)&lt;k)&#123; return Math.max(longestSubstring(s.substring(0,i),k), longestSubstring(s.substring(i+1,s.length()),k)); &#125; &#125; return s.length();&#125; 上面这段代码，第一遍历计算字符串的字符出现了几次，第二遍历计算当出现&lt;k的字符时，将字符串分开并重新计算字符串满足k最长字串，最后返回。看起来好像没什么问题，但是这段代码超时了。。。感觉也符合之前的思想，让我很不解。我感觉可能是出现了重复子问题的原因，如图的示例，找到最长子串aa 反而遍历了3次aa字符串 感觉有点麻烦？ 那么既然超时了，我们就应该优化一下代码。前面的不需要优化，就优化后面字符串的处理把。网上有这样的一种处理方法：通过两个指针begin和 end 来处理结点，每当遇到&lt;k的字符时，计算begin-》end的长度。和当前的长度比大小。但是我觉得和我之前的想法基本没差。。都是一样的想法 12345678910111213141516171819202122232425262728293031323334353637public int longestSubstring2(String s, int k) &#123; if(s.length()==0)&#123; return 0; &#125; HashMap&lt;Character,Integer&gt; hashMap = new HashMap(26); for(int i=0;i&lt;s.length();i++)&#123; char c = s.charAt(i); if(hashMap.containsKey(c))&#123; hashMap.put(c,hashMap.get(c)+1); &#125;else &#123; hashMap.put(c,1); &#125; &#125; boolean fullString = true; for(Integer i:hashMap.values())&#123; if(i&lt;k)&#123; fullString = false; &#125; &#125; if(fullString)&#123; return s.length(); &#125; int result=0,begin=0,end; for(end=0;end&lt;s.length();end++)&#123; char c = s.charAt(end); if(hashMap.get(c)&lt;k)&#123; result = Math.max(result,longestSubstring(s.substring(begin,end),k)); begin = end +1; &#125; &#125; if(begin&lt;end)&#123; result = Math.max(result,longestSubstring(s.substring(begin,end),k)); &#125; return result;&#125; 总结没搞懂为什么这样会快很多，我觉得我们的方式都差不多，是我之前的代码遇到了重复子问题嘛。。。感觉也没有，难道是我的代码subStirng过多耗了性能？这是一个需要记录的问题。。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单词接龙_127]]></title>
    <url>%2Fposts%2FSolution-127%2F</url>
    <content type="text"><![CDATA[难度：中等 这是本题的地址：https://leetcode-cn.com/problems/word-ladder/ 给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则： 每次转换只能改变一个字母。 转换过程中的中间单词必须是字典中的单词。 说明: 如果不存在这样的转换序列，返回 0。 所有单词具有相同的长度。 所有单词只由小写字母组成。 字典中不存在重复的单词。 你可以假设 beginWord 和 endWord 是非空的，且二者不相同。 示例 1: 123456789输入:beginWord = &quot;hit&quot;,endWord = &quot;cog&quot;,wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]输出: 5解释: 一个最短转换序列是 &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;, 返回它的长度 5。 示例 2: 12345678输入:beginWord = &quot;hit&quot;endWord = &quot;cog&quot;wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]输出: 0解释: endWord &quot;cog&quot; 不在字典中，所以无法进行转换。 我的思路1、BFS这题我本来的思路是这样的，使用BFS广度优先搜索，通过一个队列先保存beginword值，然后通过单个字母变化26次，遍历当前的字符串，匹配到wordlist中相应的项，然后把这些项加入队列，并将它们从list中remove。最终找到endword，通过这样广搜肯定能搜索到最短的路径。但值得一提的是，我超时了。 1234567891011121314151617181920212223242526272829303132public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) &#123; //用一个hashSet代替list进行遍历，这样就不会超时了，真坑。 HashSet hashSet = new HashSet&lt;&gt;(wordList); if(!hashSet.contains(endWord))&#123; return 0; &#125; Queue&lt;String&gt; queue = new LinkedList(); ((LinkedList) queue).add(beginWord); int lengthA =0,lengthB=1; while(queue.size()!=0)&#123; String str = queue.poll(); if(str.equals(endWord))&#123; return lengthA+1; &#125; for(int i=0;i&lt;str.length();i++)&#123; char[] chars = str.toCharArray(); for(char j='a';j&lt;='z';j++)&#123; chars[i] = j; if(hashSet.contains(new String(chars)))&#123; queue.add(new String(chars)); hashSet.remove(new String(chars)); &#125; &#125; &#125; lengthB--; if(lengthB==0)&#123; lengthB=queue.size(); lengthA++; &#125; &#125; return 0;&#125; 时间复杂度：O(n*26^str.length()) 2、双重BFS通过看B站Up主的视频：https://www.bilibili.com/video/av38705526?from=search&amp;seid=16479832968747750696 可以使用双重BFS这种更好的解法，就是通过两个队列，一个从beginword开始广搜，另一个从endword开始广搜，当他们相遇时，就是最短的路径，没有相遇就是0。 12345678910111213141516171819202122232425262728293031323334353637public int ladderLength2(String beginWord, String endWord, List&lt;String&gt; wordList) &#123; HashSet hashSet = new HashSet&lt;&gt;(wordList); if(!hashSet.contains(endWord))&#123; return 0; &#125; Queue&lt;String&gt; queue = new LinkedList(); Queue&lt;String&gt; queue2 = new LinkedList(); queue.add(beginWord); queue2.add(endWord); int step=0; while(queue.size()!=0&amp;&amp;queue2.size()!=0)&#123; step++; if(queue.size()&gt;queue2.size())&#123; Queue q3 = new LinkedList(queue); queue = queue2; queue2 =q3; &#125; Queue queue1 = new LinkedList(); for(String str:queue)&#123; for(int i=0;i&lt;str.length();i++)&#123; char[] chars = str.toCharArray(); for(char j='a';j&lt;='z';j++)&#123; chars[i] = j; if(queue2.contains(new String(chars)))&#123; return step+1; &#125; if(hashSet.contains(new String(chars)))&#123; queue1.add(new String(chars)); hashSet.remove(new String(chars)); &#125; &#125; &#125; &#125; queue = queue1; &#125; return 0;&#125; 时间复杂度：O(n*26^(str.lenght()/2)) 总结虽然因为直接就用list做操作导致了BFS的超时,但是通过这个我回忆了一下，arraylist的remove确实很耗时，每次删除都会把后面的往前复制一遍。 没有想到双BFS的操作，以后要善用这些操作。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>BFS</tag>
        <tag>双向BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[乘积最大子序列_152]]></title>
    <url>%2Fposts%2FSolution-152%2F</url>
    <content type="text"><![CDATA[难度：中等 这是该题的地址：https://leetcode-cn.com/problems/maximum-product-subarray/ 给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。 示例 1: 123输入: [2,3,-2,4]输出: 6解释: 子数组 [2,3] 有最大乘积 6。 示例 2: 123输入: [-2,0,-1]输出: 0解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。 我的思路有想到用动态规划来做，但是没想到使用这种方式。。。保留到前个字符的最大正数和最小负数。这样无论当前数是正数或是负数都能求到最大的乘积。通过动态规划就能得到最大的值了。 1234567891011121314151617public int maxProduct(int[] nums) &#123; int[] dp = new int[nums.length]; dp[0] = nums[0]; int max = nums[0], min = nums[0]; for (int i = 1; i &lt; nums.length; i++) &#123; if (nums[i] &gt;= 0) &#123; max = nums[i] &gt; nums[i] * max ? nums[i] : nums[i] * max; min = nums[i] &lt; nums[i] * min ? nums[i] : nums[i] * min; &#125; else &#123; int temp = max; max = nums[i] &gt; min * nums[i] ? nums[i] : min * nums[i]; min = nums[i] &lt; temp * nums[i] ? nums[i] : temp * nums[i]; &#125; dp[i] = max &gt; dp[i - 1] ? max : dp[i - 1]; &#125; return dp[nums.length-1];&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[盛最多水的容器_11]]></title>
    <url>%2Fposts%2Fsolution-11%2F</url>
    <content type="text"><![CDATA[难度：中等（感觉没有中等难度啊） 这是该题的地址：https://leetcode-cn.com/problems/container-with-most-water/ 给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例: 12输入: [1,8,6,2,5,4,8,3,7]输出: 49 我的思路这个感觉没有中等难度呀。使用双指针的做法，头尾两个指针，得出当前的区域大小，因为区域的大小取决于更小的那一个指针，这时候就要把我们的底线抬高。所以当左指针比右指针小的时候，左指针往右移，右指针同理。相遇的时候就跳出循环。 123456789101112131415public int maxArea(int[] height) &#123; int left =0,right =height.length-1; int max =0; while(left&lt;right)&#123; int min = height[right]&gt;height[left]?height[left]:height[right]; int area = (right-left) * min; max = max&gt;area?max:area; if(height[left]==min)&#123; left++; &#125;else &#123; right--; &#125; &#125; return max;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字母大小写全排列_784]]></title>
    <url>%2Fposts%2FletterCasePermutation-784%2F</url>
    <content type="text"><![CDATA[难度：简单 给定一个字符串S，通过将字符串S中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。 123456789示例:输入: S = &quot;a1b2&quot;输出: [&quot;a1b2&quot;, &quot;a1B2&quot;, &quot;A1b2&quot;, &quot;A1B2&quot;]输入: S = &quot;3z4&quot;输出: [&quot;3z4&quot;, &quot;3Z4&quot;]输入: S = &quot;12345&quot;输出: [&quot;12345&quot;] 注意： S 的长度不超过12。 S 仅由数字和字母组成。 我的思路这题其实不难，将他想象成一颗树，每当是字母的时候分叉，不是字母的时候就不分叉。把所有子树列出来就是每个的字符串了。下面是通过深搜来实现。 1234567891011121314151617181920212223242526public List&lt;String&gt; letterCasePermutation(String S) &#123; List&lt;String&gt; list = new LinkedList&lt;&gt;(); list.add(S); tolist(list, 0, S); return list;&#125;public void tolist(List&lt;String&gt; list, int i, String s) &#123; if (i == s.length()) &#123; return; &#125; Boolean isTrue = (s.charAt(i) &gt;= 'a' &amp;&amp; s.charAt(i) &lt;= 'z') || (s.charAt(i) &gt;= 'A' &amp;&amp; s.charAt(i) &lt;= 'Z'); if (isTrue) &#123; String s1; if (Character.isLowerCase(s.charAt(i))) &#123; s1 = s.substring(0, i) + Character.toUpperCase(s.charAt(i)) + s.substring(i + 1, s.length()); &#125; else &#123; s1 = s.substring(0, i) + Character.toLowerCase(s.charAt(i)) + s.substring(i + 1, s.length()); &#125; list.add(s1); tolist(list, i + 1, s); tolist(list, i + 1, s1); &#125; else &#123; tolist(list, i + 1, s); &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>DFS</tag>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[括号生成_22]]></title>
    <url>%2Fposts%2FgenerateParenthesis-22%2F</url>
    <content type="text"><![CDATA[难度：中等 这是该题的地址：https://leetcode-cn.com/problems/generate-parentheses/ 给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。 例如，给出 n = 3，生成结果为： 1234567[ "((()))", "(()())", "(())()", "()(())", "()()()"] 我的思路这题是我做回溯法的第一题，还是蛮有回溯的意思的 我觉得。 首先回溯法我觉得第一个特点就是将解答视为一个树，然后对它进行深度优先搜索。 然后通过剪枝，当违反条件的时候，该结点的子结点下的树都不进行考虑。来减少时间复杂度。 请看图！： 根据题干，第一个必须是左括号才能满足有效的括号组合。那么它的下一位就有两种选择方案，分别是左括号或者是右括号，这样进行深度优先搜索。如图：当进行到不符合条件的结点 ”（）） “ 这样是不符合的，那么就可以减掉该结点及其子节点，并返回上一层继续进行深度优先搜索。直到获取到所有答案。 123456789101112131415161718192021public List&lt;String&gt; generateParenthesis(int n) &#123; List list = new LinkedList(); backtarcking(list,"",n,n); return list;&#125;void backtarcking(List list,String s,int left,int right)&#123; if(left&gt;right)&#123; return; &#125; if(left==0&amp;&amp;right==0)&#123; list.add(s); return; &#125; if(left!=0)&#123; backtarcking(list,s+"(",left-1,right); &#125; if(right!=0)&#123; backtarcking(list,s+")",left,right-1); &#125;&#125; 总结做了这道题之后对回溯法有了更加深刻的理解，继续加油！]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[环形链表 II_142]]></title>
    <url>%2Fposts%2FdetectCycle-142%2F</url>
    <content type="text"><![CDATA[难度：中等 这是本题的地址：https://leetcode-cn.com/problems/linked-list-cycle-ii/ 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 说明：不允许修改给定的链表。 示例 1： 123输入：head = [3,2,0,-4], pos = 1输出：tail connects to node index 1解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 123输入：head = [1,2], pos = 0输出：tail connects to node index 0解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 123输入：head = [1], pos = -1输出：no cycle解释：链表中没有环。 进阶：你是否可以不用额外空间解决此题？ 我的思路这题是环形链表_141的加强版，他在找到循环的基础上增加了找到循环的入口。看似不难，其实是需要掌握一个诀窍的，通过网上查看别人的思路，大部分人的思路都是和下图一般。 x 是快指针和慢指针出发的位置，假设 y点是入口点，z点是快慢指针的相遇点。我们可以得出下面三个条件。 那么从初始点到入口点的距离假设为a，b为慢指针在循环中走的距离，那么我们可以假设出出b走的路程为a+b。 那么因为在z点进行相遇，所以快指针走的距离我们可以假设为 a+b+c+b（绕了一圈又走了b距离到z点相遇）。 还有最后一个条件，就是快指针走的速度是慢指针的2倍，也就是说 (a+b)*2 == a+b+c+b。 根据这三个条件，我们可以得出一个结论就是 a == c。 那么 a == c有什么用呢，我们可以从图上发现，a的距离是 x 点到 y 点，而c是z点到y点的距离。z点又是快慢指针相遇的点。那么这时候我们可以发现，从z点往y点走的指针和从x点往y点走的指针最终会在y点相遇。而y点就是我们题目所需要的答案。 1234567891011121314151617public ListNode detectCycle(ListNode head) &#123; ListNode fast = head; ListNode slow = head; while (fast != null &amp;&amp; fast.next!=null) &#123; fast = fast.next.next; slow = slow.next; if(fast==slow)&#123; ListNode newNode = head; while(slow!=newNode)&#123; newNode = newNode.next; slow = slow.next; &#125; return newNode; &#125; &#125; return null;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[买卖股票的最佳时机 II_122]]></title>
    <url>%2Fposts%2FmaxProfit-122%2F</url>
    <content type="text"><![CDATA[难度：简单 该题的地址：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/ 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 1234输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2: 12345输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3: 123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 我的思路这题与 买股票的 最佳时机 这题是类似的，不过这题有一个不同就在于 尽可能完成更多交易来获取最多利润，而不是只卖一次获取最大利润了。 我们可以使用 三个int 代表最低值价钱(min)、最高值价钱(max)和利润(value)，每当过了一天，如果当天的价格比最大价格大，那么最大价格就变为当天的价格。如果比最大价格小，那么就说明在上次最大价格的时候就可以卖了，利润=最高价格-最小价格。然后再把最小价格和最高价格定为当天的价格。 上述又会出现一个问题，假如是一直升的话，岂不是永远都不会判断了？，这时候我们需要在遍历完之后加一个判断，当max大于min的时候，value要加上（max-min）。 12345678910111213141516171819public int maxProfit(int[] prices) &#123; if(prices.length&lt;=1)&#123; return 0; &#125; int min = prices[0]; int max = prices[0]; int value = 0; for(int i =1;i&lt;prices.length;i++)&#123; if(max&gt;prices[i])&#123; value+=(max-min); min = prices[i]; &#125; max = prices[i]; &#125; if(max &gt; min)&#123; value+=(max-min); &#125; return value;&#125; 总结其实还有另一种思路，就是每当当天价格比最大价格大的时候，就增加利润，当小的时候，就不增加，并且重新定义最大最小价格。最后也能得出最大的利润。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[买卖股票的最佳时机_121]]></title>
    <url>%2Fposts%2FmaxProfit-121%2F</url>
    <content type="text"><![CDATA[难度：简单 这是本题的地址：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/ 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。 注意你不能在买入股票前卖出股票。 示例 1: 1234输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 示例 2: 123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 我的思路本题我觉得可以使用动态规划来做，通过动态规划得出第n天的最优解。但是做到最后感觉不使用动态规划也是一样的。。。 本题有一个特别的地方，它需要有两个点，一个代表当前的点，一个代表最小的点（在此点买入）。。 这时候可以用当前的点减去最小的点，这样得到最大的结果就是最大利润。 如下有两种写法：我觉得两种写法是一样的，时间复杂度也是O(n) 空间复杂度也是O(1),不知道为啥我跑的就比他的慢哈哈。 我的写法（稍丑）12345678910111213141516171819public int maxProfit(int[] prices) &#123; if(prices.length&lt;=1)&#123; return 0; &#125; int[] opt = new int[prices.length]; //我将opt[0] 定义为当前在prices数组中最小的点。（其实这句话没意义，因为它一开始就是0哈哈） opt[0] = 0; //对下个结点进行对比，哪个值更小则赋给opt[0]; opt[0] = prices[1]&lt;prices[opt[0]]?1:opt[0]; //假如当前结点的值比最小结点的大，则赋给当前结点利润（因为opt[0]代表最小值，所以1需要拿出来）。 opt[1] = Math.max(prices[1]-prices[opt[0]],opt[1]); int i=2; while(i&lt;prices.length)&#123; opt[0] = prices[i]&lt;prices[opt[0]]?i:opt[0]; opt[i] = Math.max(Math.max(prices[i]-prices[opt[0]],opt[i]),opt[i-1]); i++; &#125; return opt[prices.length-1];&#125; 官方写法（优雅）123456789101112131415public int maxProfit2(int[] prices) &#123; if(prices.length&lt;=1)&#123; return 0; &#125; int min = Integer.MAX_VALUE,max=0; for(int i=0;i&lt;prices.length;i++)&#123; if(prices[i]&lt;min)&#123; min = prices[i]; &#125; if((prices[i]-min)&gt;max)&#123; max = prices[i]-min; &#125; &#125; return max;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[环形链表_141]]></title>
    <url>%2Fposts%2FhasCycle-141%2F</url>
    <content type="text"><![CDATA[难度：简单 这是本题的地址：https://leetcode-cn.com/problems/linked-list-cycle/ 给定一个链表，判断链表中是否有环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 示例 1： 123输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 123输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 123输入：head = [1], pos = -1输出：false解释：链表中没有环。 进阶： 你能用 O(1)（即，常量）内存解决此问题吗？ 我的思路这题一开始觉得有点无从入手，而且题目给的测试数据和输入数据也有一些不同。不过在细细的看一遍，我们可以发现其中的诀窍。 因为题目的输入是一个ListNode 结点。我们可以通过这个发现，当没有“园”（循环）的时候，肯定有一个结点的next为空。所以我们可以以这个next为空作为我们遍历结点的终点。 因为可能有出现园的情况，我们可以用一个集合装下我们已遍历过的结点，然后每当到下一个结点的时候判断这个结点是否已经出现过了，如果没有则将这个结点放入集合中，如果有则返回true 通过这两点我们就可以得到一个正确的题解 12345678910111213public boolean hasCycle(ListNode head) &#123;// ArrayList&lt;ListNode&gt; ar = new ArrayList&lt;&gt;(); 一开始我是用的是arraylist也可以实现 Set&lt;ListNode&gt; ar = new HashSet&lt;&gt;(); while(head!=null)&#123; if(ar.contains(head))&#123; return true; &#125;else&#123; ar.add(head); &#125; head = head.next; &#125; return false;&#125; 进阶题目有进阶解法，使用O(1)的内存解决此问题。 根据官方的题解：可以使用快慢指针这种形式。快指针移动两步慢指针就只移动一步。 假如有一个圈的话，无论是跑得快还是跑的慢，他们都会在某个点相遇，这时候我们就可以返回false了。 快指针移动两步可以更快到达next=null的点，从而return false。 12345678910111213141516public boolean hasCycle2(ListNode head) &#123; ListNode fast = head; ListNode slow = head; while(fast!=null&amp;&amp;slow!=null)&#123; fast = fast.next; if(fast==null)&#123; return false; &#125; fast = fast.next; slow = slow.next; if(fast==slow)&#123; return true; &#125; &#125; return false;&#125; 总结这题做出第一个解并不难，进阶做法让我们更理解快慢指针的应用！]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在排序数组中查找元素的第一个和最后一个位置_34]]></title>
    <url>%2Fposts%2FsearchRange-34%2F</url>
    <content type="text"><![CDATA[难度：中等 这是本题的地址：https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/ 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 你的算法时间复杂度必须是 O(log n) 级别。 如果数组中不存在目标值，返回 [-1, -1]。 示例 1: 12输入: nums = [5,7,7,8,8,10], target = 8输出: [3,4] 示例 2: 12输入: nums = [5,7,7,8,8,10], target = 6输出: [-1,-1] 我的思路因为题干中说了复杂度必须是O(logN)级别，所以我们可以联想到使用二分查找来做这道题目。 一、二分查找通过题目我们可以发现，二分查找可以很快的确定target所在的区间。但是这里有一个小问题，当 mid 中间点和target相等时，你不仅要往左搜索 还要往右搜索。解决了这个就相当于解决了这个问题。 第一种写法（我的写法）： 1234567891011121314151617181920212223242526272829private int start=-1,end=-1;//定义类变量public int[] searchRange(int[] nums, int target) &#123; int left = 0,right = nums.length; digui(left,right,nums,target); return new int[]&#123;start,end&#125;;&#125;void digui(int left,int right,int[] nums,int target)&#123; int mid = (left+right)/2; if(left&gt;=right)&#123; return; &#125; if(nums[mid]==target)&#123; if(start ==-1)&#123; start = mid; &#125;else if(start&gt;mid)&#123; start = mid; &#125; if(mid&gt;end)&#123; end = mid; &#125; //如果是相同，则双方向都进行二分查找 digui(left,mid,nums,target); digui(mid+1,right,nums,target); &#125;else if(nums[mid]&lt;target)&#123; digui(mid+1,right,nums,target); &#125;else&#123; digui(left,mid,nums,target); &#125;&#125; 第二种写法：不使用类变量 它是先定位第一个target的位置，然后再散发查找。可能是测试用例的问题，这段代码跑的比我的快，但是后面的散发查找肯定也使用二分查找是更快的。代码的时间复杂度也是O(logN) 12345678910111213141516171819202122232425262728293031323334public int[] searchRange3(int[] nums, int target) &#123; int left =0,right = nums.length,mid = (left+right)/2; boolean flag = false; while(left&lt;right)&#123; mid = (left+right)/2; if(nums[mid]==target)&#123; flag = true; break; &#125;else if(nums[mid]&lt;target)&#123; left = mid+1; &#125;else&#123; right = mid; &#125; &#125; if(flag)&#123; int i = mid; while(i&gt;=0)&#123; if(nums[i]!=target)&#123; break; &#125; i--; &#125; int j = mid; while(j&lt;nums.length)&#123; if(nums[j]!=target)&#123; break; &#125; j++; &#125; return new int[]&#123;i+1,j-1&#125;; &#125;else &#123; return new int[]&#123;-1,-1&#125;; &#125;&#125; 二、双指针看到题目的评论中有人说使用双指针。 很显然，在这道题中双指针并不会让你更快，时间复杂度是O(N/2)，不符合题目要求。 123456789101112131415public int[] searchRange2(int[] nums, int target) &#123; int left =0,right = nums.length-1; while(left&lt;=right)&#123; if(nums[left]!=target&amp;&amp;nums[right]!=target)&#123; left++;right--; &#125;else if(nums[left]==target&amp;&amp;nums[right]==target)&#123; return new int[]&#123;left,right&#125;; &#125;else if(nums[left]==target)&#123; right--; &#125;else if(nums[right]==target)&#123; left++; &#125; &#125; return new int[]&#123;-1,-1&#125;;&#125; 总结二分搜索不是只有说使用模板的 while() 这样递归才行。使用递归函数递归也是一个好方法！做法有千万种，理解了思想最重要]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两数之和 II - 输入有序数组_167]]></title>
    <url>%2Fposts%2Ftwo-sum-ii-input-array-is-sorted-167%2F</url>
    <content type="text"><![CDATA[难度：简单 这是该题的地址：https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/ 给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。 函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。 说明: 返回的下标值（index1 和 index2）不是从零开始的。 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 示例: 123输入: numbers = [2, 7, 11, 15], target = 9输出: [1,2]解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 我的思路一、暴力破解暴力破解的代码好像和我们原来的 两数之和 的暴力是一样的。。。 这题其实大家一看到就知道如果暴力破解的话，代码写的应该是很简单的。时间复杂度应该是O(n^2)，但是很显然这样的做法是非常的低效的。。。 1234567891011public int[] twoSum3(int[] numbers, int target) &#123; for(int i=0;i&lt;numbers.length;i++)&#123; for(int j=i+1;j&lt;numbers.length;j++)&#123; if(numbers[i]+numbers[j]==target)&#123; return new int[]&#123;i+1,j+1&#125;; &#125; &#125; &#125; return null;&#125; 二、二分查找本题的题目就有二分搜索，其实一开始我是有点懵的，因为他有两个 index1和index2 两个点要确定，二分搜索好像不能一次性确定两个点呀。。。做法是用：一个index用for循环遍历所有点来确定第一个点，另一个 index 用二分查找来确定。时间复杂度为 O(nlongn) 12345678910111213141516171819202122232425 //二分查找 O(nlogn) 比暴力快public int[] twoSum(int[] numbers, int target) &#123; if(numbers.length&lt;2)&#123; return null; &#125; int[] result = new int[2]; int index1 = 0; int index2 = 0; for(int i=0;i&lt;numbers.length;i++)&#123; index1 = i; int left = i+1; int right = numbers.length; while(left&lt;right)&#123; int mid = (left+right)/2; if(numbers[mid]+numbers[index1]&lt;target)&#123; left = mid+1; &#125;else if(numbers[mid]+numbers[index1]&gt;target)&#123; right = mid; &#125;else&#123; return new int[]&#123;index1+1,mid+1&#125;; &#125; &#125; &#125; return null; &#125; ps:虽然用上了二分查找，但是因为外面有一层for循环遍历，时间复杂度仍然很高，感觉没必要为了使用二分查找而强行这么写。 三、双指针法定义两个指针分别从数组的头部和尾部开始遍历，假如头尾之和大于target，那么尾指针就向前移一位。假如头尾之和小于target，那么头指针就向后移一位，如果头尾指针大于了尾指针，则说明数组中没有这个数。 1234567891011121314public int[] twoSum2(int[] numbers, int target) &#123; int index1 = 0; int index2 = numbers.length-1; while(index1&lt;index2)&#123; if(numbers[index1]+numbers[index2]&gt;target)&#123; index2--; &#125;else if(numbers[index1]+numbers[index2]&lt;target)&#123; index1++; &#125;else&#123; return new int[]&#123;index1+1,index2+1&#125;; &#125; &#125; return null;&#125; 总结一个题目的做法有很多，没必要说我一定要用这种做法做出来才行。当然既然是练习，肯定就是抓住某一点来练啦哈哈。既然我们做到了两数之和II，那我觉得我们可以回顾一下leetcode的第一题 两数之和~]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三角形最小路径和_120]]></title>
    <url>%2Fposts%2Ftriangle-120%2F</url>
    <content type="text"><![CDATA[难度：中等 这是本题的地址：https://leetcode-cn.com/problems/triangle/ 给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。 例如，给定三角形： 123456[ [2], [3,4], [6,5,7], [4,1,8,3]] 自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。 说明： 如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。 我的思路该题应该使用动态规划求解的。但是一开始我写了一段应该是深搜遍历所有子节点的方案，最后超时了。这也证明了动态规划在解决这类重复子问题有很好的效果。 那么我们从题目中可以得知：自顶而下最小路径和无非就是最上层的结点无非就是 选则自己下面结点的值更小的那一个，然后再加上自己的值 就是最小路径和。 一、深搜遍历深搜的想法就是找到每一个最小的结点，然后再一层一层的慢慢往回加，得出的顶部元素就是最优解。这样的做法的问题就在于，每一次深搜都有相同的节点被搜索过了，在这些地方浪费了相当多的时间。 1234567891011121314151617 public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; if(triangle.size()==0||triangle==null||(triangle.size()==1&amp;&amp;triangle.get(0).size()==0))&#123; return 0; &#125; return getmini(0,0,triangle); &#125;//这里没有用上动态规划 很尴尬 只用上了递归去深搜。。。。。public int getmini(int i,int j,List&lt;List&lt;Integer&gt;&gt; triangle)&#123; if((i==triangle.size()-1)||(j==triangle.size()))&#123; return triangle.get(i).get(j); &#125; //获取两个子节点中小的一个 int key = Math.min(getmini(i+1,j,triangle),getmini(i+1,j+1,triangle)); return key+triangle.get(i).get(j);&#125; 二、动态规划动态规划就在于 用一个最优解数组 opt[i] [j] 来保存当前节点的最优解。我们可以将获得最优解的递归式写成这样： opt[i-1] [j] = opt[i-1] [j] = Math.min(opt[i] [j],opt[i] [j+1]) + triangle.get(i-1).get(j); 这样就可以得到上一层节点的最优解。 1234567891011121314151617181920public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; if(triangle.size()==0||triangle==null||(triangle.size()==1&amp;&amp;triangle.get(0).size()==0))&#123; return 0; &#125; int[][] opt = new int[triangle.size()][triangle.size()]; //初始化opt最下面一层的值 for(int j = 0;j&lt;triangle.size();j++)&#123; opt[triangle.size()-1][j] = triangle.get(triangle.size()-1).get(j); &#125; //从最底层开始 int i = triangle.size()-1; while(i!=0)&#123; for(int j=0;j&lt;i;j++)&#123; //上一层节点的值等于这一层两个节点的值小的哪个加上上一层的值。 opt[i-1][j] = Math.min(opt[i][j],opt[i][j+1]) + triangle.get(i-1).get(j); &#125; i--; &#125; return opt[0][0];&#125; 三、让我们的算法更加分题目说了如果我们能只用额外的O(n)空间解决这个问题就更好了。 那么n的空间就代表原来的List的空间。那么我们刚刚使用了二维数组opt[] [] 肯定是不能加分啦。通过分析别的的答案，我发现了加分解法是使用一维数组 opt[triangle.size()] 这样空间的问题解决了。但是如何获取解的呢？ 123456789101112131415public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; if(triangle.size()==0||triangle==null||(triangle.size()==1&amp;&amp;triangle.get(0).size()==0))&#123; return 0; &#125; int[] dp = new int[triangle.size()]; //从最底层往上遍历 for(int i=triangle.size()-1;i&gt;=0;i++)&#123; //当前层的结点和当前层的层数是一样的 for(int j=0;j&lt;=i;j++)&#123; //原来的dp[j]和dp[j+1]是下一层的，那么重新赋值现在这一层的dp[j]是不冲突的~ dp[j] = Math.min(dp[j],dp[j+1]) + triangle.get(i).get(j); &#125; &#125; return dp[0];&#125; 我的反思以后要向着做出最优解的方式来做！ 相似题目 967.连续相同数字 303.区域和检索 - 数组不可变]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最长有效括号_32]]></title>
    <url>%2Fposts%2Flongest-valid-parentheses-32%2F</url>
    <content type="text"><![CDATA[难度：困难 该题的地址是https://leetcode-cn.com/problems/longest-valid-parentheses/ 给定一个只包含 &#39;(&#39; 和 &#39;)&#39; 的字符串，找出最长的包含有效括号的子串的长度。 示例 1: 123输入: &quot;(()&quot;输出: 2解释: 最长有效括号子串为 &quot;()&quot; 示例 2: 123输入: ")()())"输出: 4解释: 最长有效括号子串为 "()()" 我的思路一、动态规划本题我一开始是想使用动态规划做的。opt[s.length()] 这个在当是右括号的时候记录长度。 例子: (()) 获取当前括号的长度就是前面括号的长度加上自己的长度 那么递归式就得出当前的括号长度 = 前一个括号长度 + 自己括号的长度：opt[i] = opt[i-1]+2 。 但是之前的例子： ()() 假如在当前括号之前有括号，长度也要计算进去。 其实我们很容易可以知道 当前括号的左括号的位置 = 我们当前括号的位置 - 中间括号的长度 即是 i - opt[i-1] -1 （如果再-1 就是前面括号的右括号的位置了） 那么 我们的递归式就要修改为 opt[i] = opt[i-1] + 2 + opt[i - opt[i-1] -2] 这样就可以将当前的括号长度与之前的括号长度加在一起。 12345678910111213141516171819202122232425262728public int longestValidParentheses(String s) &#123; if(s.length()&lt;2)&#123; return 0; &#125; int[] opt = new int[s.length()]; opt[0] = 0; int sum =0; for(int i = 1;i&lt;s.length();i++)&#123; //当是右括号的时候进入判断 if(s.charAt(i)==')')&#123; //获取前面的括号的位置 int key = i - opt[i-1] -1; if(key&gt;=0)&#123; if(s.charAt(key)=='(')&#123; if(key==0)&#123;//当是0时 说明没有前面的括号了 opt[i] = opt[i-1] + 2; &#125;else&#123;//不是0时 说明当前括号的位置之前还有括号，把他们的长度加上。 opt[i] = opt[i-1] + 2 + opt[key-1]; &#125; &#125; &#125; &#125; if(sum&lt;opt[i])&#123; sum = opt[i]; &#125; &#125; return sum;&#125; 二、栈做法栈做法的思路是用栈储存括号，每当匹配的时候，可以比较当前节点的位置和前一个未能出栈的节点的位置的距离。就可以得出最长的路径。 12345678910111213141516171819202122232425262728293031public int longestValidParentheses3(String s) &#123; int max = 0, start = 0; if(null == s) &#123; return 0; &#125; int len = s.length(); Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for(int index = 0; index &lt; len; index++)&#123; //遇左括号(，将当前元素的下表push进栈里 if('(' == s.charAt(index))&#123; stack.push(index); continue; &#125; else &#123; // 因为遇到右括号的时候是不会将他入栈的， //而且假如右括号前面没有节点的话肯定是不能通过的，不需要让他入站。将他的下标值记录下来。之后的获取长度都可以用它。 if(stack.isEmpty())&#123; start = index+1; continue; &#125; else &#123; stack.pop(); if(stack.isEmpty())&#123; max = Math.max(max, index-start+1); &#125; else &#123; max = Math.max(max, index-stack.peek()); &#125; &#125; &#125; &#125; return max;&#125; 我的反思我觉得这里的思路我一开始都不是很清晰，感觉还是蛮复杂的。我觉得我需要刷多点这些题，可以让我变得更好！ 该题的类似:20.有效的括号]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的最大深度_104]]></title>
    <url>%2Fposts%2Fmaximum-depth-of-binary-tree-104%2F</url>
    <content type="text"><![CDATA[难度：简单 我觉得这题与111最小深度相同，都是简单的DFS和BFS 这是本题的地址：https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/ 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例：给定二叉树 [3,9,20,null,null,15,7]， 12345 3 / \9 20 / \ 15 7 返回它的最大深度 3 。 我的思路这题可以使用DFS和BFS两种做法。 DFS：深度优先搜索，每次搜索都回搜索到最底层的叶子节点。这样可以可以很轻松的得到最长路径了。 BFS：广度优先搜索，一层一层的遍历所有的子节点。到最后一层就可以得出最长的路径。 123456789101112131415161718//DFS --这是我一开始的递归做法int max = 0;public int maxDepth(TreeNode root) &#123; dfs(root,1); return max;&#125;void dfs(TreeNode root,int now)&#123; if(root==null)&#123; return; &#125; if(max&lt;now)&#123; max = now; &#125; now++; dfs(root.left,now); dfs(root.right,now);&#125; 1234567891011121314151617181920212223//BFSpublic int maxDepth(TreeNode root)&#123; Queue&lt;TreeNode&gt; queue = new LinkedList(); if(root!=null)&#123; queue.add(root); &#125; int sum = 0; while(!queue.isEmpty())&#123; int size = queue.size(); while(size!=0)&#123; TreeNode tr = queue.poll(); if(tr.left!=null)&#123; queue.add(tr.left); &#125; if(tr.right!=null)&#123; queue.add(tr.right); &#125; size--; &#125; sum++; &#125; return sum;&#125; 我的反思我觉得我DFS的时候使用了类的局部变量，感觉这样做并不是很好。因为这样可能方法没有调用它，但是它在对象实例化的时候就会被初始化。应该修改成用到的时候再初始化会更好一点。 官方题解他也是用到了dfs 感觉比我的好多了 以后我使用dfs也尽量写成简洁的样式 123456789public int maxDepth3(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; else &#123; int left_height = maxDepth(root.left); int right_height = maxDepth(root.right); return java.lang.Math.max(left_height, right_height) + 1; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的层次遍历_102]]></title>
    <url>%2Fposts%2Fbinary-tree-level-order-traversal-102%2F</url>
    <content type="text"><![CDATA[难度：中等 我觉得这道题让我加深了对深搜和广搜的理解 在这道题之后、可以去看看题目103、107、111这几道都是很简单的广度优先搜索的题目 这是本题的地址：https://leetcode-cn.com/problems/binary-tree-level-order-traversal/ 给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。 例如:给定二叉树: [3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 返回其层次遍历结果： 12345[ [3], [9,20], [15,7]] 我的思路这道题也是用BFS广度优先搜索来做一下~。其实用广搜遍历完整棵树很简单，但是我们要做把每一层都装进list里面返回。所以重点在于装进每遍历完一层就将所有节点的值放进list里面。 我的做法是这样的，因为一开始需要用一个队列来装广搜的每一层的节点，假如用一个int 来区分一个队列里面子节点和父节点的分界线的话我觉得好像不太好，所以我用了两个队列来分开装父节点和子节点。然后再遍历，每当一个队列为空时将list数据装进总的list里面，最后返回总的list。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; ls = new ArrayList&lt;&gt;(); List&lt;Integer&gt; ls1 = new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; tr1= new LinkedList&lt;&gt;(); Queue&lt;TreeNode&gt; tr2= new LinkedList&lt;&gt;(); if(root!=null)&#123; tr1.add(root); &#125; //条件满足时说明已经没有子节点了 while(!tr1.isEmpty()||!tr2.isEmpty())&#123; //这一重判断是交替使用队列 if(tr2.isEmpty())&#123; //然后再将这条队列中的所有节点放进ls1子列表中。当结束时就把ls1放入总列表ls中 while(!tr1.isEmpty())&#123; TreeNode nowNode = tr1.poll(); ls1.add(nowNode.val); if(tr1.isEmpty())&#123; ls.add(ls1); ls1 = new ArrayList&lt;&gt;(); &#125; //将非空的节点放入队列 if(nowNode.left!=null)&#123; tr2.add(nowNode.left); &#125; if(nowNode.right!=null)&#123; tr2.add(nowNode.right); &#125; &#125; &#125;else&#123; while(!tr2.isEmpty())&#123; TreeNode nowNode = tr2.poll(); ls1.add(nowNode.val); if(tr2.isEmpty())&#123; ls.add(ls1); ls1 = new ArrayList&lt;&gt;(); &#125; if(nowNode.left!=null)&#123; tr1.add(nowNode.left); &#125; if(nowNode.right!=null)&#123; tr1.add(nowNode.right); &#125; &#125; &#125; &#125; return ls;&#125; 我的反思我的结果: 我觉得我的时间复杂度是O(n^2);但是我的代码好长，而且感觉我的重复代码有点多，官方虽然没有给出官方解答，但是我们不能失去追求优雅代码的意愿！那么就去看看别人的代码有什么好操作把！ PLAN A 改动改动计划：去掉多余的重复代码，去掉多余的队列，用int size 来记录父节点有多少个来区分一个队列中的父节点和子节点。 1234567891011121314151617181920212223242526public List&lt;List&lt;Integer&gt;&gt; levelOrder2(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; ls = new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; tr1= new LinkedList&lt;&gt;(); if(root!=null)&#123; tr1.add(root); &#125; while(!tr1.isEmpty())&#123; List&lt;Integer&gt; ls1 = new ArrayList&lt;&gt;(); //获取当前队列的大小作为当前层节点的个数 int size = tr1.size(); //当size为空时说明当前层的节点已经全部放入ls中了 while(size!=0)&#123; TreeNode t = tr1.poll(); ls1.add(t.val); if(t.left!=null)&#123; tr1.add(t.left); &#125; if(t.right!=null)&#123; tr1.add(t.right); &#125; size--; &#125; ls.add(ls1); &#125; return ls;&#125; 我的结果: PLAN B 改动使用DFS 深度优先遍历，当到达一个节点时，判断是否位空，位空则返回上一层，不为空，则判断当前的节点是否处于那一层，若超过了 总list 的size 则需要新建一个新的list来存新一层的节点数据。然后将当前节点存进对应的总list层数中。最后继续深搜 往下寻找 tr.left 和 tr.right; (ps:代码可以忽略=-= 毕竟是看了别人做法，所以基本写的也是一样的） 12345678910111213141516171819public List&lt;List&lt;Integer&gt;&gt; levelOrder3(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; ls = new ArrayList&lt;&gt;(); digui_3(root,0,ls); return ls;&#125;void digui_3(TreeNode tr,int level,List&lt;List&lt;Integer&gt;&gt; ls)&#123; //判断当前节点是否为空，作为结束递归的条件 if(tr==null)&#123; return; &#125; //当 当前层 比ls中的列表多，增加新一个列表来存储新的一层的节点 if(ls.size()-1&lt;level)&#123; ls.add(new ArrayList&lt;&gt;()); &#125; ls.get(level).add(tr.val); digui_3(tr.left,level+1,ls); digui_3(tr.right,level+1,ls);&#125; 我的结果： 最后的一点小疑问？通过改动PlAN B发现 在这次的题目中DFS比BFS速度要快一些。可以深入了解一下DFS和BFS的时间复杂度解析，增加对它们的了解。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>BFS</tag>
        <tag>树</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Queue队列-java源码了解]]></title>
    <url>%2Fposts%2FQueue%E9%98%9F%E5%88%97-java%2F</url>
    <content type="text"><![CDATA[ok 因为在题目里面遇到了Queue，所以我就来了解一下Queue这个接口的功效吧！ 来看看里面的注释是怎么说这个类的，英语四级启动！： 它说这是一个围在处理钱保存元素和设计的集合。基于util类库的操作，队列支持 额外的 插入、 提取 检查 操作。 每一个方法都存在两个形式： 1）在操作失败时抛出一个异常。 2）返回一个特殊值 null 或 false （取决于你的操作）。 第二种形式 在 插入操作中被特别设计成容量受限的情况。在大多数的情况下，插入操作不能出错。 来看看Queue接口的源码12public interface Queue&lt;E&gt; extends Collection&lt;E&gt; &#123;&#125; Queue从jdk1.5出现 继承Collection这个接口，方法一共有六个： add方法1boolean add(E e); 将指定的元素插入此队列，成功则返回true，如果没有足够的空间 则抛出一个异常。 可能的异常有4个IllegalStateException、ClassCastException、NullPointerException、IllegalArgumentException offer方法1boolean offer(E e); 这个方法和add方法一样时将元素插入队列中的，不同之处在于，当队列因为没有足够空间插入元素时，这个元素会返回false而不是抛出IllegalStateException异常。 可能的异常有3个ClassCastException、NullPointerException、IllegalArgumentException。 remove方法1E remove(); 检索并删除此队列的头部元素，这种方法在队列为空时会抛出异常 NoSuchElementException。 poll方法1E poll(); 这个方法和remove方法一样，不同之处在于在队列为空时 poll是返回一个null而不是抛出异常。 element方法1E element(); 检索但不删除队列的头部，如果队列为空则会抛出一个异常 NoSuchElementException。 peek方法1E peek(); 这个方法和element方法一样，不同之处在于如果队列位空，返回的是null而不是抛出异常。]]></content>
      <categories>
        <category>ThinkinJava</category>
      </categories>
      <tags>
        <tag>Java源码</tag>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对称二叉树_101]]></title>
    <url>%2Fposts%2FisSymmetric-101%2F</url>
    <content type="text"><![CDATA[难度：简单 这是本题的地址：https://leetcode-cn.com/problems/symmetric-tree/ 给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 12345 1 / \ 2 2 / \ / \3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 12345 1 / \2 2 \ \ 3 3 题目给出的树的结构： 123456class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125; &#125; 我的思路这题让我思路头大，因为之前还没有做过树的题目，深搜广搜虽然了解大概是怎么样的做法却没有实际使用上。 这道题一开始我是想着如果要证明它们是镜像对称的，那么树的left的left节点 应该和right的right节点相同，left的right节点应该和right的left节点相同。 那么每当 left.val 和 right.val 的值相等的时候。 就进行递归digui(left.left,right.right) 和 digui(left.right,right.left) 这两个递归。这里要注意的就是一开始是使用两个root进入从而避免了一开始就要写left和right。 123456789101112public boolean isSymmetric(TreeNode root) &#123; return digui(root,root);&#125;public Boolean digui(TreeNode t1,TreeNode t2)&#123; if(t1==null&amp;&amp;t2==null)&#123; return true; &#125;else if(t1==null||t2==null)&#123; return false; &#125; return(t1.val==t2.val) &amp;&amp; digui(t1.left,t2.right) &amp;&amp; digui(t1.right,t2.left);&#125; 官方思路除了第一个递归之外，官方还写出了迭代的思路，我来试一试。既然这里的代码用到了Queue(队列)，我就去对自己科普了一下java的Queue 代码可以忽略，列一下里面觉得有用的几个点。 123456789101112131415161718192021222324252627public boolean isSymmetric2(TreeNode root) &#123; Queue&lt;TreeNode&gt; ls = new &lt;TreeNode&gt;LinkedList(); ls.add(root); ls.add(root); while(ls.size()!=0)&#123; //poll函数 这个函数我很少用，用处是将队列里第一个元素取出，如果没有则返回null。 TreeNode t1 = ls.poll(); // 每次取出头两个来对比是否相同 TreeNode t2 = ls.poll(); // 判断是和上面的代码是一样的 if(t1==null&amp;&amp;t2==null)&#123; continue; &#125;else if(t1==null||t2==null)&#123; return false; &#125; if(t1.val!=t2.val)&#123; return false; &#125;else&#123; // 往队列里添加新的节点，t1 t2的顺序相反 因为它们是镜像。 ls.add(t1.left); ls.add(t2.right); ls.add(t1.right); ls.add(t2.left); &#125; &#125; return true;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>BFS</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解码方法_91]]></title>
    <url>%2Fposts%2FnumDecodings-91%2F</url>
    <content type="text"><![CDATA[难度：中等 终于，感觉这道题不是那么的水了~** 这是本题的地址：https://leetcode-cn.com/problems/decode-ways/ 一条包含字母 A-Z 的消息通过以下方式进行了编码： 1234'A' -&gt; 1'B' -&gt; 2...'Z' -&gt; 26 给定一个只包含数字的非空字符串，请计算解码方法的总数。 示例 1: 123输入: "12"输出: 2解释: 它可以解码为 "AB"（1 2）或者 "L"（12）。 示例 2: 123输入: "226"输出: 3解释: 它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。 我的思路这道题是真的挺多坑的。让我头大得很。从题目中的A B ….Z 这个其实可以不用管。这道题也是采用动态规划来做，因为他是从1-26的数字，所以最多只会有2个数字连在一起。不会出现3个数字连在一起的情况。所以而且我们可以发现 12345678910例如字符串："123"。opt[0] = 1; 也就是字符串"1"处的最优解码是1opt[1] = 2; 也就是字符串"2"处的最优解码是2, 他的解码方式是 1 2和 12 其实这时候还不是很好看出递归式。opt[3] = 3; 为什么呢 其实这个我们可以拆解出来。123 可以拆解为：1 2 312 31 23三种。这时候我们可以发现一些有意思的东西，假如把 3 拿出来 1 2和12 这两个不就是opt[1]的值吗？把 23 拿出来剩下的 1 不就是opt[0]的值吗。 这时候我们就可以得出我们的递归式 ： opt[n] = opt[n-1]+opt[n-2] 突然发现这样的递归式不是很常见吗哈哈~ 得到了递归式 其实还有一个很重要的坑那就是：当有一个值为0的时候，我们会发现题目中没有给出0。但是却有10 和 20 这两个符合解码的数。但假如是0开头的是不能解码的。所以我们就要对0这个字符进行判断。如果是有0出现，假如出现了不能解码的情况，那整个字符串都不能解码。 123456789101112131415161718192021222324252627282930public int numDecodings(String s) &#123; int n = s.length(); int[] opt = new int[n]; opt[0] = s.charAt(0)=='0'?0:1; for(int i=1;i&lt;n;i++)&#123; int sum =Integer.parseInt(s.substring(i-1,i+1)); if(s.charAt(i)=='0')&#123; if(sum&lt;10||sum&gt;26)&#123; opt[i] = 0; &#125;else&#123; if(i&lt;2)&#123; opt[i] = opt[i-1]; &#125;else&#123; opt[i] = opt[i-2]; &#125; &#125; &#125;else&#123; if(sum&lt;=26&amp;&amp;sum&gt;=10)&#123; if(i&lt;2)&#123; opt[i] = opt[i-1] + 1; &#125;else&#123; opt[i] = opt[i-1] + opt[i-2]; &#125; &#125; else&#123; opt[i] = opt[i-1]; &#125; &#125; &#125; return opt[n-1];&#125; 我的反思虽然用上了动态规划 但是我觉得里面的if else 也还是有点多….. 别人的速度虽然比我快一点，但是看起来我们的时间复杂度都是O(n)呀。。。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小路径和_64]]></title>
    <url>%2Fposts%2FminPathSum-64%2F</url>
    <content type="text"><![CDATA[这是本题的地址https://leetcode-cn.com/problems/minimum-path-sum/ 给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例: 12345678输入:[ [1,3,1], [1,5,1], [4,2,1]]输出: 7解释: 因为路径 1→3→1→1→1 的总和最小。 我的思路感觉62 63 64 都是连续的题目 都是使用动态规划来做这道题。都是一些很简单的动态规划。 从题目中我们可以了解递归式： 1opt[i][j] = (opt[i-1][j]&lt;opt[i][j-1]?opt[i-1][j]:opt[i][j-1]) + grid[i][j]; 通过使用这个递归式最终我们可以得出我们想要的结果 12345678910111213141516171819202122public int minPathSum(int[][] grid) &#123; if(grid==null || grid.length==0 ||(grid.length==1&amp;&amp;grid[0].length==0))&#123; return 0; &#125; int n = grid.length; int m = grid[0].length; int[][] opt = new int[n][m]; for(int i = 0;i&lt;n;i++)&#123; for(int j =0;j&lt;m;j++)&#123; if (i == 0 &amp;&amp; j == 0) &#123; opt[i][j] = grid[i][j]; &#125;else if(i == 0)&#123; opt[i][j] = grid[i][j]+opt[i][j-1]; &#125;else if(j == 0)&#123; opt[i][j] = grid[i][j]+opt[i-1][j]; &#125;else&#123; opt[i][j] = (opt[i-1][j]&lt;opt[i][j-1]?opt[i-1][j]:opt[i][j-1]) + grid[i][j]; &#125; &#125; &#125; return opt[n-1][m-1];&#125; 我的反思最终跑出来的速度比别人的慢很多，但是我看了下别人的范例代码。我觉得我们的代码好像都是一样的呀？有的人也用递归来做，也不知道是不是更好一些。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不同路径II_63]]></title>
    <url>%2Fposts%2FuniquePathsWithObstacles-63%2F</url>
    <content type="text"><![CDATA[这是本题的地址：https://leetcode-cn.com/problems/unique-paths-ii/ 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ 网格中的障碍物和空位置分别用 1 和 0 来表示。 说明：*m 和 n* 的值均不超过 100。 示例 1: 123456789101112输入:[ [0,0,0], [0,1,0], [0,0,0]]输出: 2解释:3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 2 条不同的路径：1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右 我的思路这道题和uniquePaths-62 类似。但是增加了一个障碍的条件。我的做法其实和之前的差不多，但是增加了一些关于遇到“障碍”时的判断。这道题也是使用动态规划~，有一个问题在于假如传入的是空的数组。获取第二维的长度的时候会报错。 判断二维数组是否位空： if ( array == null || array.length == 0 || ( array.length == 1 &amp;&amp; array[0].length == 0 ) ) 1234567891011121314151617181920212223public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; int n = obstacleGrid.length; int m = obstacleGrid[0].length; int[][] opt = new int[n][m]; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++)&#123; if(obstacleGrid[i][j]==1)&#123; opt[i][j] = 0; &#125;else&#123; if(i==0&amp;&amp;j==0)&#123; opt[i][j] =1; &#125;else if(i==0)&#123; opt[i][j] = opt[i][j-1]; &#125;else if(j==0)&#123; opt[i][j] = opt[i-1][j]; &#125;else&#123; opt[i][j] = opt[i][j-1]+opt[i-1][j]; &#125; &#125; &#125; &#125; return opt[n-1][m-1];&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不同路径_62(java)]]></title>
    <url>%2Fposts%2FuniquePaths-62%2F</url>
    <content type="text"><![CDATA[这是本题的地址:https://leetcode-cn.com/problems/unique-paths/ 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 问总共有多少条不同的路径？ 例如，上图是一个7 x 3 的网格。有多少可能的路径？ 说明：*m 和 n* 的值均不超过 100。 示例 1: 1234567输入: m = 3, n = 2输出: 3解释:从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -&gt; 向右 -&gt; 向下2. 向右 -&gt; 向下 -&gt; 向右3. 向下 -&gt; 向右 -&gt; 向右 示例 2: 12输入: m = 7, n = 3输出: 28 我的思路这题我是想着使用动态规划来做的，这个与之前动态规划不同的是 他是一个二维数组。这样的话最优解opt的数组也是一个二维数组。且题目中说明每次只能向下或向右移动一步。这样的话，递归式应该是这样：opt [n] [m] = opt[n-1] [m] + opt[n] [m-1]。得到了递归式，我们就可以开始进行操作了。 12345678910111213141516public int uniquePaths(int m, int n) &#123; if(m==0||n==0)&#123; return 0; &#125; int[][] opt = new int[m][n]; for(int i=0;i&lt;m;i++)&#123; for(int j=0;j&lt;n;j++)&#123; if(i==0||j==0)&#123; opt[i][j]=1; &#125;else&#123; opt[i][j] = opt[i][j-1]+opt[i-1][j]; &#125; &#125; &#125; return opt[m-1][n-1];&#125; 我感觉不太好，因为要使用两个for 但是好像必须这样，因为是一个二维数组。时间复杂度：O(n^2)。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加一_66(java)]]></title>
    <url>%2Fposts%2FplusOne-66%2F</url>
    <content type="text"><![CDATA[这是本题的地址https://leetcode-cn.com/problems/plus-one/ 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1: 123输入: [1,2,3]输出: [1,2,4]解释: 输入数组表示数字 123。 示例 2: 123输入: [4,3,2,1]输出: [4,3,2,2]解释: 输入数组表示数字 4321。 我的思路这道题我觉得同 addTwoNumbers-2-两数之和 题有一点点类似，但是一个是链表一个是数组 我的做法是这样的。从数组最后一个数字进行遍历，将其+1。若果超过了10。那么当前的数就要%10。并且flag=1。 通过flag来查看是否需要添加一位最新的数。如需要 就用for循环新建一个数组。如不需要就直接返回当前数组。 123456789101112131415161718192021public int[] plusOne(int[] digits) &#123; int flag =0; for(int i=digits.length-1;i&gt;=0;i--)&#123; digits[i]+=1; if(digits[i]&gt;=10)&#123; flag =1; digits[i] = digits[i]%10; &#125;else&#123; flag =0; &#125; if(flag==0)&#123;break;&#125; &#125; int[] a = new int[digits.length+1]; if(flag==1)&#123; a[0] = 1; for(int i=1;i&lt;=digits.length;i++)&#123; a[i] = digits[i-1]; &#125; &#125; return flag==1?a:digits;&#125; 时间复杂度为 ：O(n) n为数组的长度。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最后一个单词长度_58(java)]]></title>
    <url>%2Fposts%2FlengthOfLastWord-58%2F</url>
    <content type="text"><![CDATA[这是本题的地址：https://leetcode-cn.com/problems/length-of-last-word/ 给定一个仅包含大小写字母和空格 &#39; &#39; 的字符串，返回其最后一个单词的长度。 如果不存在最后一个单词，请返回 0 。 说明：一个单词是指由字母组成，但不包含任何空格的字符串。 示例: 12输入: "Hello World"输出: 5 我的思路：一开始想着用lastindexof来做，但是不行。因为假如是”a b “ 这样的字符串。用lastindexof是行不通的。那么我们就用for循环开始遍历整个字符串。获取字符的长度。每当是’ ‘的时候，就将长度值设为0。lastlength用于记录上个字符的长度。length记录当前字符的长度。当length为0时 说明 ‘ ’符后面没有字符了。这时候就需要返回lastlength 12345678910111213public int lengthOfLastWord(String s) &#123; int length=0; int lastlength=0; for(int i=0;i&lt;s.length();i++)&#123; if(s.charAt(i)==' ')&#123; lastlength = length==0?lastlength:length; length = 0; &#125;else&#123; length++; &#125; &#125; return length==0?lastlength:length;&#125; 官方思路没有，让我们来看看别人的做法是怎么样的 看了一下范例，发现其实大多数都是用for循环的。它们从最后开始往回找，这样循环的遍历就少多了。但既然都是用for循环。就不列出来了。有一个蛮有意思的： 他的做法是用trim去掉首尾的 “ “空格符，通过寻找剩下的” “空格符。如果没有就返回整体的长度。如果有就判断是否有字符串，没有就返回0。最后再返回原长度-i-1。 i就是倒数的” “空格符的位置。那么减去它就相当于减掉了前面的长度。再-1就是把” “空格符所占的1个位置给减掉了~。 123456789101112public int lengthOfLastWord2(String s) &#123; s = s.trim(); int i = s.lastIndexOf(" "); if (i == -1)&#123; return s.length(); &#125; if (i == s.length()-1)&#123; return 0; &#125;else &#123; return s.length()-i-1; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[weekgame_122]]></title>
    <url>%2Fposts%2Fweekgame-122%2F</url>
    <content type="text"><![CDATA[这是该题的地址：https://leetcode-cn.com/contest/weekly-contest-122/problems/sum-of-even-numbers-after-queries/ 给出一个整数数组 A 和一个查询数组 queries。 对于第 i 次查询，有 val = queries[i][0], index = queries[i][1]，我们会把 val 加到 A[index] 上。然后，第 i 次查询的答案是 A中偶数值的和。 （此处给定的 index = queries[i][1] 是从 0 开始的索引，每次查询都会永久修改数组 A。） 返回所有查询的答案。你的答案应当以数组 answer 给出，answer[i] 为第 i 次查询的答案。 示例： 12345678输入：A = [1,2,3,4], queries = [[1,0],[-3,1],[-4,0],[2,3]]输出：[8,6,2,4]解释：开始时，数组为 [1,2,3,4]。将 1 加到 A[0] 上之后，数组为 [2,2,3,4]，偶数值之和为 2 + 2 + 4 = 8。将 -3 加到 A[1] 上之后，数组为 [2,-1,3,4]，偶数值之和为 2 + 4 = 6。将 -4 加到 A[0] 上之后，数组为 [-2,-1,3,4]，偶数值之和为 -2 + 4 = 2。将 2 加到 A[3] 上之后，数组为 [-2,-1,3,6]，偶数值之和为 -2 + 6 = 4。 提示： 1 &lt;= A.length &lt;= 10000 -10000 &lt;= A[i] &lt;= 10000 1 &lt;= queries.length &lt;= 10000 -10000 &lt;= queries[i][0] &lt;= 10000 0 &lt;= queries[i][1] &lt; A.length 我的思路根据题目，我们可以得知，answer的长度为i 而i的值则是queries的长度。那么我们可以通过遍历queries数组。然后对数组A进行操作。之后通过遍历数组A 找出偶数，并相加求出和。然后得出一个值，放进anwser数组里。 1234567891011121314public int[] sumEvenAfterQueries(int[] A, int[][] queries) &#123; int [] answer = new int[queries.length]; for(int i=0;i&lt;queries.length;i++)&#123; A[queries[i][1]] += queries[i][0]; int sum =0; for(int j=0;j&lt;A.length;j++)&#123; if(A[j]%2==0)&#123; sum+=A[j]; &#125; &#125; answer[i] = sum; &#125; return answer;&#125; 缺点：使用了暴力破解。时间复杂度增高。 官方思路感觉官方的思路比较聪明，通过先找出A数组中的偶数和。然后再通过添加的操作判断当前数是否还是偶数。这样的话只需要通过单个循环就可以实现了。 https://leetcode-cn.com/articles/sum-of-even-numbers-after-queries/]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬楼梯-70(java)]]></title>
    <url>%2Fposts%2FclimbStairs-70%2F</url>
    <content type="text"><![CDATA[这是本题的地址https://leetcode-cn.com/problems/climbing-stairs/ 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 12345输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1. 1 阶 + 1 阶2. 2 阶 示例 2： 123456输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1. 1 阶 + 1 阶 + 1 阶2. 1 阶 + 2 阶3. 2 阶 + 1 阶 我的思路：其实这个仔细的看一下就会发现和哪个斐波那契数列第n项问题很像。主要的递归式就是 f[n] = f[n-1]+f[n-2]。 通过这个式子我们就可以得出第n个梯子有多少种变化啦~最后返回数组的n-1即可。 1234567891011121314public int climbStairs(int n) &#123; if(n==1)&#123; return 1; &#125;else if(n==2)&#123; return 2; &#125; int[] foot = new int[n]; foot[0] = 1; foot[1] = 2; for(int i=2;i&lt;n;i++)&#123; foot[i] = foot[i-1]+foot[i-2]; &#125; return foot[n-1];&#125; 我的结果]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大子序和-53]]></title>
    <url>%2Fposts%2FmaxSubArray-53%2F</url>
    <content type="text"><![CDATA[这是本题的地址：https://leetcode-cn.com/problems/maximum-subarray/ 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 123输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 我的思路1、暴力： 循环遍历当前数组的每个节点，设定一个int sum值来记录最长的子字符串的长度。 123456789101112public int maxSubArray(int[] nums) &#123; int n = nums.length; int sum=nums[0]; for(int i=0;i&lt;n;i++)&#123; int sum1 =0; for(int j=i;j&gt;=0;j--)&#123; sum1 += nums[j]; sum = sum&gt;sum1?sum:sum1; &#125; &#125; return sum;&#125; 缺点： 慢。能不用就不用 2、动态规划： 进行一次遍历： 每当前面的子序之和为负值时，也就证明了有没有前面的数字都是无所谓的，这时候，就可以重新记录子序和了~。然后将这些进行比较，最大的就返回出来。 12345678910111213public int maxSubArray2(int[] nums) &#123; int max= nums[0]; int sum=0; for(int i=0;i&lt;nums.length;i++)&#123; if(sum&gt;0 )&#123; sum+=nums[i]; &#125;else&#123; sum=nums[i]; &#125; max = Math.max(sum,max); &#125; return max;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最长回文子串_5]]></title>
    <url>%2Fposts%2FlongestPalindrome-5%2F</url>
    <content type="text"><![CDATA[这是本题的地址：https://leetcode-cn.com/problems/longest-palindromic-substring/ 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 123输入: "babad"输出: "bab"注意: "aba" 也是一个有效答案。 示例 2： 12输入: "cbbd"输出: "bb" 我的思路：有一个String sum =”” 来保存最大的回文。 有第一个for(int i=0)循环遍历整个字符串。然后第二个字符串由j=i 开始，判断这i j之间是否是回文。如果是，那么j-i+1(加1是因为j和i相同时，也是有一个字符的)是否大于sum的长度。如果大于，那么他们就是最大的回文。 那么用于判断ij之间是否为回文的方法我是这样做的：先判断当前i j的字符是否相同，如果相同则判断 i j 是否相等或相邻，如果是那么就返回true。如果不是那么进行 i+1 和 j-1的递归。若果i j的字符不相同，则返回false；这样是暴力解法。时间复杂度 n3次方。 123456789101112131415161718192021222324public String longestPalindrome(String s) &#123; String sum = ""; for(int i=0;i&lt;s.length();i++)&#123; for(int j=i;j&lt;s.length();j++)&#123; if(Panduan(i,j,s))&#123; if(j-i+1&gt;sum.length())&#123; sum = s.substring(i,j+1); &#125; &#125; &#125; &#125; return sum;&#125;boolean Panduan(int a,int b,String s)&#123; if(s.charAt(a)==s.charAt(b))&#123; if(a==b||a==b-1||a-1==b)&#123; return true; &#125; return Panduan(++a,--b,s); &#125;else&#123; return false; &#125;&#125; 我的结果： 特别的慢：这也是暴力解法的问题所在！ 在官方的解答中：有动态规划和中心扩展算法这两个。等我看懂了再补充上来！~]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清理：终结处理和垃圾回收]]></title>
    <url>%2Fposts%2F%E6%B8%85%E7%90%86%EF%BC%9A%E7%BB%88%E7%BB%93%E5%A4%84%E7%90%86%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%2F</url>
    <content type="text"><![CDATA[清理：终结处理和垃圾回收垃圾回收的三个要点 1、对象可能不被垃圾回收 2、垃圾回收并不等于“析构” 3、垃圾回收只和内存有关 java 中允许调用finalize方法，这个方法却不能作为通用的清理方法。因为程序没有濒临储存空间用完，那么就不需要释放内存。因为垃圾回收也是需要开销的，如果不用它，那么这部分开销就省下来了。那么finalize方法在什么时候可以调用呢：在通过某种创建对象方式以外的方式为对象分配了储存空间，但是java一切皆为对象。。。this is special！ *java中有一种“本地方法”，它是一种在java中调用的非java代码，在jdk1.5时是只支持c/c++的，它可能会调用c的函数来分配对象，也可能调用任何其他语言。so，这些都需要特定的储存释放方法来释放。这时候finalize就有用武之地了。 垃圾回收机制1、引用计数这是一种很简单但是很慢的垃圾回收技术，每个对象都有一个引用计数器，当有引用链接到对象时，引用计数+1，当引用离开作用域或被置为null，引用计数就会-1，当引用计数=0的时候就回回收对象。 缺陷：当对象之前存在循环引用，引用计数不为0时但又要被回收的时候，这样对于垃圾回收工作量非常大。引用计数常用来说明垃圾收集的工作方式，没有被应用于任何java虚拟机实现。 2、自适应垃圾回收技术：停止-复制暂停程序的运行，将当前堆所有存活的对象复制到另一个堆，没有被复制的都会被垃圾回收。当对象被复制到新的堆中的时候，它们时一个挨着一个的。所以新堆抱持紧凑排列，以后的分配空间也很简单。 缺点： –1 效率低，需要有两个堆。维护比实际需要多一倍的空间。 某些java虚拟机的处理方式：按需从内存中分配较大块的内存，复制动作发生在他们里面。 –2 程序进入稳定状态之后可能只会产生少量的垃圾，但是如果用这个还是会将内存从一处复制到另外一处。 3、自适应垃圾回收技术：标记-清扫基于上一份放的问题2，产生了新的垃圾回收机制：标记-清扫。遍历所有的引用，找出活对象并标记，在全部标记完成之后，才会进行清扫工作。把没有标记的对象都进行垃圾回收。这样下来，剩下的空间是不连续的。 小总结java虚拟机会进行监视，如果所有对象都稳定，垃圾回收效率降低的话。就使用“标记-清扫”方式，当碎片过多就会使用“停止-复制”，这就是“自适应”垃圾回收机制。 LAST最后 java虚拟机中有许多附加技术用以提升速度，叫做just in time “即时”编译器技术。 当需要装载某些类的时候（通常是为该类创建第一个对象），编译器先找到.class文件。然后将该类的字节码装入内存。之后会有两种做法： 1、让即时编辑器编译所有代码。 这种方式有两种缺陷：一、加载动作散落在整个程序生命周期内，累加起来要花更多时间。二、增加可执行代码的长度，降低了程序速度。 2、让即时编辑器载必要时候才编译。 也称为惰性评估。这样不会被执行的代码也不会倍jit编译。在java HotSpot技术中采用了此操作。代码每次被执行都会做一些优化。执行的越多跑的越快。]]></content>
      <categories>
        <category>ThinkinJava</category>
      </categories>
      <tags>
        <tag>ThinkinJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[报数_38(java)]]></title>
    <url>%2Fposts%2FcountAndSay-38%2F</url>
    <content type="text"><![CDATA[这是该题的地址https://leetcode-cn.com/problems/count-and-say/ 报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下： 123451. 12. 113. 214. 12115. 111221 1 被读作 &quot;one 1&quot; (&quot;一个一&quot;) , 即 11。11 被读作 &quot;two 1s&quot; (&quot;两个一&quot;）, 即 21。21 被读作 &quot;one 2&quot;, “one 1&quot; （&quot;一个二&quot; , &quot;一个一&quot;) , 即 1211。 给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。 注意：整数顺序将表示为一个字符串。 示例 1: 12输入: 1输出: &quot;1&quot; 示例 2: 12输入: 4输出: &quot;1211&quot; 我的思路因为题目给了整数n,所以我们应该进行遍历，直到为n的时候输出字符串。 在遍历中，我设定了3个遍历。一个是int sum （用来保存当前字符出现的数量） string now （现在这个字符是怎么样的 例如：11，21 ） string newstr （用来保存字符串的主体 几个now加起来 就是newstr） 通过遍历当前str的值。生成 now 和 newstr。 123456789101112131415161718192021222324252627public String countAndSay(int n) &#123; int i=1; String str = &quot;1&quot;; String now ; String newstr ; int sum; while(i&lt;n)&#123; sum = 1; now = &quot;&quot;; newstr = &quot;&quot;; for(int j=0;j&lt;str.length();j++)&#123; if(j==0)&#123; now = &quot;&quot;+sum+str.charAt(j); &#125; else if(str.charAt(j)==str.charAt(j-1))&#123; sum++; now = &quot;&quot;+ sum+str.charAt(j); &#125; else&#123; sum = 1; newstr = newstr + now; now = &quot;&quot;+sum+str.charAt(j); &#125; &#125; str = newstr + now; i++; &#125; return str; &#125; 这是我的结果： 虽然通过了 但是我觉得很慢，这时候我看了看别人的代码，我觉得我们的时间复杂度差不多啊….. 之后我就发现他们用的是stringbuilder 而我用的是string 所以我对我的代码进行了改版： 使用Stringbuilder12345678910111213141516171819202122232425public String countAndSay2(int n) &#123; int i=1; StringBuilder str = new StringBuilder("1"); int sum; while(i&lt;n)&#123; sum = 1; StringBuilder now = new StringBuilder(); StringBuilder newstr = new StringBuilder(); for(int j=0;j&lt;str.length();j++)&#123; if(j==0)&#123; now = new StringBuilder(""+sum+str.charAt(j)); &#125; else if(str.charAt(j)==str.charAt(j-1))&#123; sum++; now = new StringBuilder(""+ sum+str.charAt(j)); &#125; else&#123; sum = 1; newstr = newstr.append(now); now = new StringBuilder(""+sum+str.charAt(j)); &#125; &#125; str = newstr.append(now); i++; &#125; return str.toString();&#125; 结果：]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无重复字符的最长字串_3(java)]]></title>
    <url>%2Fposts%2FlengthOfLongestSubstring-3%2F</url>
    <content type="text"><![CDATA[这是本题的地址：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/ 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。示例 1:输入: “abcabcbb”输出: 3解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。示例 2: 输入: “bbbbb”输出: 1解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。示例 3: 输入: “pwwkew”输出: 3解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。 我的思路：一开始我的思路也是使用类似于“滑动窗口”，但是应该是用到了双循环。所以，超时了不行。很难受，最后看了一下题目的解法。使用“滑动数组”。用int i , j 分别表示窗口的左右边[i,j)。创建一个hashset，用于储存字符。然后通过遍历，每当不相同时，通过判断，给maxlength 赋值给 i-j的长度。 每当有相同的时候，把hashset 里面和 s.charAt(i)相等的字符删除。然后把i往右边移动一位。 public int lengthOfLongestSubstring(String s) { int maxlength = 0; int i=0,j=0; HashSet hs = new HashSet(); while(i&lt;s.length()&amp;&amp;j&lt;s.length()){ if(!hs.contains(s.charAt(j))){ hs.add(s.charAt(j++)); int value = j-i; maxlength = maxlength&gt;value?maxlength:value; }else{ hs.remove(s.charAt(i++)); } } return maxlength; } 优化：答案中的优化时这样的。使用了hashmap()，遍历时，当不相等，判断sum和j-i+1的长度，（因为i j是2个字符了，所以需要+1长度）。然后给hashmap put一个值 key是当前的字符 value是j+1 代表当前这个字符现在在字符串中的哪个位置。 每当相等时，从hashmap里将这个字符拿出来。对比它和i哪个比较大。如果。然后将值赋给i。相当于i（左边界）右移到了第一个相同字符处。这样就形成了一个“滑动窗口拉”！ public int lengthOfLongestSubstring2(String s) { int sum =0; HashMap&lt;Character,Integer&gt; hm = new HashMap(); for(int i=0,j=0;j&lt;s.length();j++){ if(hm.containsKey(s.charAt(j))){ i = hm.get(s.charAt(j))&gt;i?hm.get(s.charAt(j)):i; } sum = sum&gt;j-i+1?sum:j-i+1; hm.put(s.charAt(j),j+1); } return sum; }]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Weekly_competition_121(java)]]></title>
    <url>%2Fposts%2Fweekgame-121%2F</url>
    <content type="text"><![CDATA[这是我第一次参加周竞赛，只做对了一题。好垃圾。。。 第一题： 这是原题的地址：https://leetcode-cn.com/contest/weekly-contest-121/problems/string-without-aaa-or-bbb/ 我的思路：用一个flaga flagb 判断a b 是否已经到了2个。然后再通过循环遍历将每一个字符输入进去。最后返回string public String strWithout3a3b(int A, int B) { int longa =0; int longb =0; StringBuffer sb = new StringBuffer(); while(A&gt;0||B&gt;0){ if(A&gt;B){ if(longa&lt;2){ longa++; longb=0; sb.append(&apos;a&apos;); A--; }else{ longa=0; sb.append(&apos;b&apos;); B--; } }else if(B&gt;A){ if(longb&lt;2){ longb++; longa=0; sb.append(&apos;b&apos;); B--; }else{ longb=0; sb.append(&apos;a&apos;); A--; } }else if(A==B){ if(longa&lt;2){ sb.append(&apos;a&apos;); sb.append(&apos;b&apos;); }else{ sb.append(&apos;b&apos;); sb.append(&apos;a&apos;); } A--;B--; } } return sb.toString(); } 官方解答：用贪心，先选择当前较多得字母写入字符串中。如果前面两个字符是一样的，下一个写入的字符就不应该相同。地址：https://leetcode-cn.com/articles/string-without-aaa-or-bbb/ 我的反思：官方比我的代码减少了很多代码量，也不用新建对象。so 要向着简洁前进！！！！]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[珠海扬名广场海底捞食记]]></title>
    <url>%2Fposts%2Fzh-food1%2F</url>
    <content type="text"><![CDATA[hi，这里是何嘉晨的食记，记录一下我每次去吃的餐厅。然后将我的感想在这里抒发出来！ 这次去的是珠海扬名广场的餐厅。因为是一次写所以没有准备拍很多照片。 这是这次去点的菜：牛肉 血旺 下滑 鸭肠 毛肚 娃娃菜 金针菇 两个人吃 一共261元： 我的评价：我觉得这几个菜里 牛肉：火锅点牛肉也是很平常的一件事 ，所以我们就点了一份牛肉其他的都是半份，牛肉很滑煮久了也不会老，听服务员说他们的牛肉是经过腌制的前腿肉和后腿肉。虽然我并不知道前腿肉和后腿肉本来是不是就是这么嫩。。。 虾滑：我就虾滑也很滑很好吃。没什么特别的吧，感觉大部分的虾滑都差不多。 血旺就一般般 可能是我不吃辣，服务员说用辣锅煮好吃些。当然他也会给你一叠干辣椒面。 鸭肠：不用煮很久，吃起来爽爽的，还不错吧。 毛肚：不用煮很久，感觉吃起来就是有点脆脆的，口感很不错。 金针菇和娃娃菜：就很普通。。。 我的总结价格：偏贵 味道：一般 服务：挺好的。 我的觉得海底捞的服务还是很不错的，反正大家都说他们是卖服务的。可能是这次一起吃的人少，所以没有点很多菜色。但是如果你问我是否会有很强烈的意愿再来一次的话：没有。]]></content>
      <categories>
        <category>食记</category>
      </categories>
      <tags>
        <tag>food</tag>
        <tag>珠海</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两数相加_2(java)]]></title>
    <url>%2Fposts%2FaddTwoNumbers-2%2F</url>
    <content type="text"><![CDATA[这是该题的地址：https://leetcode-cn.com/problems/add-two-numbers/ 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以 0 开头。示例： 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 我的思路： 链表是倒序的 所以我们可以从个位开始相加。 然后用一个int flag 来代表进位+1。 有一个firstnode 和一个 endnode 用于判断链表的第一个和最后一个节点。 当一条链为空时，将它与另一条链相等。 这样循环就不用很快跳出了。最后判断最后一位是否有进位，来新增一个节点。最后返回first节点的next。 public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int flag =0; ListNode firstNo = new ListNode(0); firstNo.next = l1; ListNode EndNode = new ListNode(0); while(l1!=null||l2!=null){ int sum; if(l1==null){ l1=l2; }else if(l2==null){ l2=l1; } if(l1==l2){ sum = l1.val +flag; }else{ sum = l1.val + l2.val +flag; } flag=0; if(sum&gt;=10){ sum-=10; flag++; } l1.val = sum; l2.val = sum; EndNode.next = l1; EndNode = l1; l1 = l1.next; l2 = l2.next; } if(flag!=0){ EndNode.next = new ListNode(1); } return firstNo.next; } 我的结果： 官方解答： 官方题解地址：https://leetcode-cn.com/problems/add-two-numbers/solution/ 我的反思：看了官方题解之后，我觉得我的和他的思路差不多。不过他是每次都新增一个，而我则是在原有的节点上进行修改 然后最后再考虑新增。不过不知道为什么他的比我快哈哈~可能是官方的代码更加简洁吧。以后我的代码也要越来越简洁！]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索插入位置-35(java)]]></title>
    <url>%2Fposts%2Fleetcode-searchInsert-35%2F</url>
    <content type="text"><![CDATA[难度：简单 这是该题的地址：https://leetcode-cn.com/problems/search-insert-position/ 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。你可以假设数组中无重复元素。 示例 1: 输入: [1,3,5,6], 5输出: 2示例 2: 输入: [1,3,5,6], 2输出: 1示例 3: 输入: [1,3,5,6], 7输出: 4示例 4: 输入: [1,3,5,6], 0输出: 0 我的思路：一、暴力从数组第一个数i=0开始遍历。将val和nums[]的值进行比较。假如值超过了或者相等了。那么就将i返回。如果遍历完了都没有返回 就将数组的长度返回 12345678public int searchInsert(int[] nums, int target) &#123; for(int i=0;i&lt;nums.length;i++)&#123; if(target==nums[i] || target&lt;nums[i])&#123; return i; &#125; &#125; return nums.length; &#125; 最终的速度： 二、二分查找因为数组是有序的，我们可以使用二分查找来搞定这个问题。二分查找就是将数组对半分开，每次和中间的点进行比较，这样第一遍循环的时候就减少了一半的长度，以此类推~。 123456789101112131415//二分查找public int searchInsert2(int[] nums, int target) &#123; int min = 0,max = nums.length; while(min&lt;max)&#123; int mid = (max + min)/2; if(nums[mid]&lt;target)&#123; min = mid+1; &#125;else if(nums[mid]&gt;target)&#123; max = mid; &#125;else&#123; return mid; &#125; &#125; return min;&#125; 题目总结当数组短target的值比较小的时候，可能暴力的方法会快一些。但假如数组变长了，target的值大了，二分查找的速度就会快很多。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello-hexo]]></title>
    <url>%2Fposts%2Fhello-hexo%2F</url>
    <content type="text"><![CDATA[我终于开始了我的hexo博客之旅。非常的开心。希望我能够一直坚持下去！！！！！]]></content>
  </entry>
  <entry>
    <title><![CDATA[移除元素-27(java)]]></title>
    <url>%2Fposts%2Fleetcode-removeElement-27%2F</url>
    <content type="text"><![CDATA[这是该题的地址：https://leetcode-cn.com/problems/remove-element 给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。示例: 给定 nums = [3,2,2,3], val = 3,函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。元素可为任意顺序。 我的思路： 写一个变量flag赋值数组的长度-1。从最后开始遍历数组。当前数=val时。将当前数和flag处的数位置进行调换。然后flag–最终减剩下的flag+1就是我们要返回的数字。数值=val的数也放到了数组的末端。这样就可以得到我们的想要的结果了！ public int removeElement(int[] nums, int val) { if(nums.length==0){ return 0; } int flag = nums.length-1; for(int i=nums.length-1;i&gt;=0;i--){ if(nums[i]==val){ int temp = nums[flag]; nums[flag] = nums[i]; nums[i] = temp; flag--; } } return flag +1; } 最终的速度： 范例代码： 我可改进之处： 不需要判断长度是否位空，也不需要多创建一个temp对象占用空间。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
</search>
