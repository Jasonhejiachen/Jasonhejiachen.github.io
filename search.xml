<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[lengthOfLongestSubstring_3(java)]]></title>
    <url>%2F2019%2F01%2F28%2FlengthOfLongestSubstring-3%2F</url>
    <content type="text"><![CDATA[这是本题的地址：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/ 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。示例 1:输入: “abcabcbb”输出: 3解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。示例 2: 输入: “bbbbb”输出: 1解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。示例 3: 输入: “pwwkew”输出: 3解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。 我的思路：一开始我的思路也是使用类似于“滑动窗口”，但是应该是用到了双循环。所以，超时了不行。很难受，最后看了一下题目的解法。使用“滑动数组”。用int i , j 分别表示窗口的左右边[i,j)。创建一个hashset，用于储存字符。然后通过遍历，每当不相同时，通过判断，给maxlength 赋值给 i-j的长度。 每当有相同的时候，把hashset 里面和 s.charAt(i)相等的字符删除。然后把i往右边移动一位。 public int lengthOfLongestSubstring(String s) { int maxlength = 0; int i=0,j=0; HashSet hs = new HashSet(); while(i&lt;s.length()&amp;&amp;j&lt;s.length()){ if(!hs.contains(s.charAt(j))){ hs.add(s.charAt(j++)); int value = j-i; maxlength = maxlength&gt;value?maxlength:value; }else{ hs.remove(s.charAt(i++)); } } return maxlength; } 优化：答案中的优化时这样的。使用了hashmap()，遍历时，当不相等，判断sum和j-i+1的长度，（因为i j是2个字符了，所以需要+1长度）。然后给hashmap put一个值 key是当前的字符 value是j+1 代表当前这个字符现在在字符串中的哪个位置。 每当相等时，从hashmap里将这个字符拿出来。对比它和i哪个比较大。如果。然后将值赋给i。相当于i（左边界）右移到了第一个相同字符处。这样就形成了一个“滑动窗口拉”！ public int lengthOfLongestSubstring2(String s) { int sum =0; HashMap&lt;Character,Integer&gt; hm = new HashMap(); for(int i=0,j=0;j&lt;s.length();j++){ if(hm.containsKey(s.charAt(j))){ i = hm.get(s.charAt(j))&gt;i?hm.get(s.charAt(j)):i; } sum = sum&gt;j-i+1?sum:j-i+1; hm.put(s.charAt(j),j+1); } return sum; }]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Weekly_competition_121(java)]]></title>
    <url>%2F2019%2F01%2F27%2Fweekgame-121%2F</url>
    <content type="text"><![CDATA[这是我第一次参加周竞赛，只做对了一题。好垃圾。。。 第一题： 这是原题的地址：https://leetcode-cn.com/contest/weekly-contest-121/problems/string-without-aaa-or-bbb/ 我的思路：用一个flaga flagb 判断a b 是否已经到了2个。然后再通过循环遍历将每一个字符输入进去。最后返回string public String strWithout3a3b(int A, int B) { int longa =0; int longb =0; StringBuffer sb = new StringBuffer(); while(A&gt;0||B&gt;0){ if(A&gt;B){ if(longa&lt;2){ longa++; longb=0; sb.append(&apos;a&apos;); A--; }else{ longa=0; sb.append(&apos;b&apos;); B--; } }else if(B&gt;A){ if(longb&lt;2){ longb++; longa=0; sb.append(&apos;b&apos;); B--; }else{ longb=0; sb.append(&apos;a&apos;); A--; } }else if(A==B){ if(longa&lt;2){ sb.append(&apos;a&apos;); sb.append(&apos;b&apos;); }else{ sb.append(&apos;b&apos;); sb.append(&apos;a&apos;); } A--;B--; } } return sb.toString(); } 官方解答：用贪心，先选择当前较多得字母写入字符串中。如果前面两个字符是一样的，下一个写入的字符就不应该相同。地址：https://leetcode-cn.com/articles/string-without-aaa-or-bbb/ 我的反思：官方比我的代码减少了很多代码量，也不用新建对象。so 要向着简洁前进！！！！]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[珠海扬名广场海底捞食记]]></title>
    <url>%2F2019%2F01%2F26%2Fzh-food1%2F</url>
    <content type="text"><![CDATA[hi，这里是何嘉晨的食记，记录一下我每次去吃的餐厅。然后将我的感想在这里抒发出来！ 这次去的是珠海扬名广场的餐厅。因为是一次写所以没有准备拍很多照片。 这是这次去点的菜：牛肉 血旺 下滑 鸭肠 毛肚 娃娃菜 金针菇 两个人吃 一共261元： 我的评价：我觉得这几个菜里 牛肉：火锅点牛肉也是很平常的一件事 ，所以我们就点了一份牛肉其他的都是半份，牛肉很滑煮久了也不会老，听服务员说他们的牛肉是经过腌制的前腿肉和后腿肉。虽然我并不知道前腿肉和后腿肉本来是不是就是这么嫩。。。 虾滑：我就虾滑也很滑很好吃。没什么特别的吧，感觉大部分的虾滑都差不多。 血旺就一般般 可能是我不吃辣，服务员说用辣锅煮好吃些。当然他也会给你一叠干辣椒面。 鸭肠：不用煮很久，吃起来爽爽的，还不错吧。 毛肚：不用煮很久，感觉吃起来就是有点脆脆的，口感很不错。 金针菇和娃娃菜：就很普通。。。 我的总结价格：偏贵 味道：一般 服务：挺好的。 我的觉得海底捞的服务还是很不错的，反正大家都说他们是卖服务的。可能是这次一起吃的人少，所以没有点很多菜色。但是如果你问我是否会有很强烈的意愿再来一次的话：没有。]]></content>
      <categories>
        <category>食记</category>
      </categories>
      <tags>
        <tag>food</tag>
        <tag>珠海</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[addTwoNumbers_2(java)]]></title>
    <url>%2F2019%2F01%2F26%2FaddTwoNumbers-2%2F</url>
    <content type="text"><![CDATA[这是该题的地址：https://leetcode-cn.com/problems/add-two-numbers/ 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以 0 开头。示例： 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 我的思路： 链表是倒序的 所以我们可以从个位开始相加。 然后用一个int flag 来代表进位+1。 有一个firstnode 和一个 endnode 用于判断链表的第一个和最后一个节点。 当一条链为空时，将它与另一条链相等。 这样循环就不用很快跳出了。最后判断最后一位是否有进位，来新增一个节点。最后返回first节点的next。 public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int flag =0; ListNode firstNo = new ListNode(0); firstNo.next = l1; ListNode EndNode = new ListNode(0); while(l1!=null||l2!=null){ int sum; if(l1==null){ l1=l2; }else if(l2==null){ l2=l1; } if(l1==l2){ sum = l1.val +flag; }else{ sum = l1.val + l2.val +flag; } flag=0; if(sum&gt;=10){ sum-=10; flag++; } l1.val = sum; l2.val = sum; EndNode.next = l1; EndNode = l1; l1 = l1.next; l2 = l2.next; } if(flag!=0){ EndNode.next = new ListNode(1); } return firstNo.next; } 我的结果： 官方解答： 官方题解地址：https://leetcode-cn.com/problems/add-two-numbers/solution/ 我的反思：看了官方题解之后，我觉得我的和他的思路差不多。不过他是每次都新增一个，而我则是在原有的节点上进行修改 然后最后再考虑新增。不过不知道为什么他的比我快哈哈~可能是官方的代码更加简洁吧。以后我的代码也要越来越简洁！]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-searchInsert-35(java)]]></title>
    <url>%2F2019%2F01%2F25%2Fleetcode-searchInsert-35%2F</url>
    <content type="text"><![CDATA[这是该题的地址：https://leetcode-cn.com/problems/search-insert-position/ 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。你可以假设数组中无重复元素。 示例 1: 输入: [1,3,5,6], 5输出: 2示例 2: 输入: [1,3,5,6], 2输出: 1示例 3: 输入: [1,3,5,6], 7输出: 4示例 4: 输入: [1,3,5,6], 0输出: 0 我的思路： 从数组第一个数i=0开始遍历。将val和nums[]的值进行比较。假如值超过了或者相等了。那么就将i返回。如果遍历完了都没有返回 就将数组的长度返回 public int searchInsert(int[] nums, int target) { for(int i=0;i&lt;nums.length;i++){ if(target==nums[i] || target&lt;nums[i]){ return i; } } return nums.length; } 最终的速度：]]></content>
  </entry>
  <entry>
    <title><![CDATA[hello-hexo]]></title>
    <url>%2F2019%2F01%2F24%2Fhello-hexo%2F</url>
    <content type="text"><![CDATA[我终于开始了我的hexo博客之旅。非常的开心。希望我能够一直坚持下去！！！！！]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode-removeElement-27(java)]]></title>
    <url>%2F2019%2F01%2F24%2Fleetcode-removeElement-27%2F</url>
    <content type="text"><![CDATA[这是该题的地址：https://leetcode-cn.com/problems/remove-element 给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。示例: 给定 nums = [3,2,2,3], val = 3,函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。元素可为任意顺序。 我的思路： 写一个变量flag赋值数组的长度-1。从最后开始遍历数组。当前数=val时。将当前数和flag处的数位置进行调换。然后flag–最终减剩下的flag+1就是我们要返回的数字。数值=val的数也放到了数组的末端。这样就可以得到我们的想要的结果了！ public int removeElement(int[] nums, int val) { if(nums.length==0){ return 0; } int flag = nums.length-1; for(int i=nums.length-1;i&gt;=0;i--){ if(nums[i]==val){ int temp = nums[flag]; nums[flag] = nums[i]; nums[i] = temp; flag--; } } return flag +1; } 最终的速度： 范例代码： 我可改进之处： 不需要判断长度是否位空，也不需要多创建一个temp对象占用空间。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
</search>
