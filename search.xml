<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[买卖股票的最佳时机 II_122]]></title>
    <url>%2Fposts%2FmaxProfit-122%2F</url>
    <content type="text"><![CDATA[难度：简单 该题的地址：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/ 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 1234输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2: 12345输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3: 123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 我的思路这题与 买股票的 最佳时机 这题是类似的，不过这题有一个不同就在于 尽可能完成更多交易来获取最多利润，而不是只卖一次获取最大利润了。 我们可以使用 三个int 代表最低值价钱(min)、最高值价钱(max)和利润(value)，每当过了一天，如果当天的价格比最大价格大，那么最大价格就变为当天的价格。如果比最大价格小，那么就说明在上次最大价格的时候就可以卖了，利润=最高价格-最小价格。然后再把最小价格和最高价格定为当天的价格。 上述又会出现一个问题，假如是一直升的话，岂不是永远都不会判断了？，这时候我们需要在遍历完之后加一个判断，当max大于min的时候，value要加上（max-min）。 12345678910111213141516171819public int maxProfit(int[] prices) &#123; if(prices.length&lt;=1)&#123; return 0; &#125; int min = prices[0]; int max = prices[0]; int value = 0; for(int i =1;i&lt;prices.length;i++)&#123; if(max&gt;prices[i])&#123; value+=(max-min); min = prices[i]; &#125; max = prices[i]; &#125; if(max &gt; min)&#123; value+=(max-min); &#125; return value;&#125; 总结其实还有另一种思路，就是每当当天价格比最大价格大的时候，就增加利润，当小的时候，就不增加，并且重新定义最大最小价格。最后也能得出最大的利润。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[买卖股票的最佳时机_121]]></title>
    <url>%2Fposts%2FmaxProfit-121%2F</url>
    <content type="text"><![CDATA[难度：简单 这是本题的地址：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/ 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。 注意你不能在买入股票前卖出股票。 示例 1: 1234输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 示例 2: 123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 我的思路本题我觉得可以使用动态规划来做，通过动态规划得出第n天的最优解。但是做到最后感觉不使用动态规划也是一样的。。。 本题有一个特别的地方，它需要有两个点，一个代表当前的点，一个代表最小的点（在此点买入）。。 这时候可以用当前的点减去最小的点，这样得到最大的结果就是最大利润。 如下有两种写法：我觉得两种写法是一样的，时间复杂度也是O(n) 空间复杂度也是O(1),不知道为啥我跑的就比他的慢哈哈。 我的写法（稍丑）12345678910111213141516171819public int maxProfit(int[] prices) &#123; if(prices.length&lt;=1)&#123; return 0; &#125; int[] opt = new int[prices.length]; //我将opt[0] 定义为当前在prices数组中最小的点。（其实这句话没意义，因为它一开始就是0哈哈） opt[0] = 0; //对下个结点进行对比，哪个值更小则赋给opt[0]; opt[0] = prices[1]&lt;prices[opt[0]]?1:opt[0]; //假如当前结点的值比最小结点的大，则赋给当前结点利润（因为opt[0]代表最小值，所以1需要拿出来）。 opt[1] = Math.max(prices[1]-prices[opt[0]],opt[1]); int i=2; while(i&lt;prices.length)&#123; opt[0] = prices[i]&lt;prices[opt[0]]?i:opt[0]; opt[i] = Math.max(Math.max(prices[i]-prices[opt[0]],opt[i]),opt[i-1]); i++; &#125; return opt[prices.length-1];&#125; 官方写法（优雅）123456789101112131415public int maxProfit2(int[] prices) &#123; if(prices.length&lt;=1)&#123; return 0; &#125; int min = Integer.MAX_VALUE,max=0; for(int i=0;i&lt;prices.length;i++)&#123; if(prices[i]&lt;min)&#123; min = prices[i]; &#125; if((prices[i]-min)&gt;max)&#123; max = prices[i]-min; &#125; &#125; return max;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[环形链表_141]]></title>
    <url>%2Fposts%2FhasCycle-141%2F</url>
    <content type="text"><![CDATA[难度：简单 这是本题的地址：https://leetcode-cn.com/problems/linked-list-cycle/ 给定一个链表，判断链表中是否有环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 示例 1： 123输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。 示例 2：** 123输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 123输入：head = [1], pos = -1输出：false解释：链表中没有环。 进阶： 你能用 O(1)（即，常量）内存解决此问题吗？ 我的思路这题一开始觉得有点无从入手，而且题目给的测试数据和输入数据也有一些不同。不过在细细的看一遍，我们可以发现其中的诀窍。 因为题目的输入是一个ListNode 结点。我们可以通过这个发现，当没有“园”（循环）的时候，肯定有一个结点的next为空。所以我们可以以这个next为空作为我们遍历结点的终点。 因为可能有出现园的情况，我们可以用一个集合装下我们已遍历过的结点，然后每当到下一个结点的时候判断这个结点是否已经出现过了，如果没有则将这个结点放入集合中，如果有则返回true 通过这两点我们就可以得到一个正确的题解 12345678910111213public boolean hasCycle(ListNode head) &#123;// ArrayList&lt;ListNode&gt; ar = new ArrayList&lt;&gt;(); 一开始我是用的是arraylist也可以实现 Set&lt;ListNode&gt; ar = new HashSet&lt;&gt;(); while(head!=null)&#123; if(ar.contains(head))&#123; return true; &#125;else&#123; ar.add(head); &#125; head = head.next; &#125; return false;&#125; 进阶题目有进阶解法，使用O(1)的内存解决此问题。 根据官方的题解：可以使用快慢指针这种形式。快指针移动两步慢指针就只移动一步。 假如有一个圈的话，无论是跑得快还是跑的慢，他们都会在某个点相遇，这时候我们就可以返回false了。 快指针移动两步可以更快到达next=null的点，从而return false。 12345678910111213141516public boolean hasCycle2(ListNode head) &#123; ListNode fast = head; ListNode slow = head; while(fast!=null&amp;&amp;slow!=null)&#123; fast = fast.next; if(fast==null)&#123; return false; &#125; fast = fast.next; slow = slow.next; if(fast==slow)&#123; return true; &#125; &#125; return false;&#125; 总结这题做出第一个解并不难，进阶做法让我们更理解快慢指针的应用！]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在排序数组中查找元素的第一个和最后一个位置_34]]></title>
    <url>%2Fposts%2FsearchRange-34%2F</url>
    <content type="text"><![CDATA[难度：中等 这是本题的地址：https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/ 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 你的算法时间复杂度必须是 O(log n) 级别。 如果数组中不存在目标值，返回 [-1, -1]。 示例 1: 12输入: nums = [5,7,7,8,8,10], target = 8输出: [3,4] 示例 2: 12输入: nums = [5,7,7,8,8,10], target = 6输出: [-1,-1] 我的思路因为题干中说了复杂度必须是O(logN)级别，所以我们可以联想到使用二分查找来做这道题目。 一、二分查找通过题目我们可以发现，二分查找可以很快的确定target所在的区间。但是这里有一个小问题，当 mid 中间点和target相等时，你不仅要往左搜索 还要往右搜索。解决了这个就相当于解决了这个问题。 第一种写法（我的写法）： 1234567891011121314151617181920212223242526272829private int start=-1,end=-1;//定义类变量public int[] searchRange(int[] nums, int target) &#123; int left = 0,right = nums.length; digui(left,right,nums,target); return new int[]&#123;start,end&#125;;&#125;void digui(int left,int right,int[] nums,int target)&#123; int mid = (left+right)/2; if(left&gt;=right)&#123; return; &#125; if(nums[mid]==target)&#123; if(start ==-1)&#123; start = mid; &#125;else if(start&gt;mid)&#123; start = mid; &#125; if(mid&gt;end)&#123; end = mid; &#125; //如果是相同，则双方向都进行二分查找 digui(left,mid,nums,target); digui(mid+1,right,nums,target); &#125;else if(nums[mid]&lt;target)&#123; digui(mid+1,right,nums,target); &#125;else&#123; digui(left,mid,nums,target); &#125;&#125; 第二种写法：不使用类变量 它是先定位第一个target的位置，然后再散发查找。可能是测试用例的问题，这段代码跑的比我的快，但是后面的散发查找肯定也使用二分查找是更快的。代码的时间复杂度也是O(logN) 12345678910111213141516171819202122232425262728293031323334public int[] searchRange3(int[] nums, int target) &#123; int left =0,right = nums.length,mid = (left+right)/2; boolean flag = false; while(left&lt;right)&#123; mid = (left+right)/2; if(nums[mid]==target)&#123; flag = true; break; &#125;else if(nums[mid]&lt;target)&#123; left = mid+1; &#125;else&#123; right = mid; &#125; &#125; if(flag)&#123; int i = mid; while(i&gt;=0)&#123; if(nums[i]!=target)&#123; break; &#125; i--; &#125; int j = mid; while(j&lt;nums.length)&#123; if(nums[j]!=target)&#123; break; &#125; j++; &#125; return new int[]&#123;i+1,j-1&#125;; &#125;else &#123; return new int[]&#123;-1,-1&#125;; &#125;&#125; 二、双指针看到题目的评论中有人说使用双指针。 很显然，在这道题中双指针并不会让你更快，时间复杂度是O(N/2)，不符合题目要求。 123456789101112131415public int[] searchRange2(int[] nums, int target) &#123; int left =0,right = nums.length-1; while(left&lt;=right)&#123; if(nums[left]!=target&amp;&amp;nums[right]!=target)&#123; left++;right--; &#125;else if(nums[left]==target&amp;&amp;nums[right]==target)&#123; return new int[]&#123;left,right&#125;; &#125;else if(nums[left]==target)&#123; right--; &#125;else if(nums[right]==target)&#123; left++; &#125; &#125; return new int[]&#123;-1,-1&#125;;&#125; 总结二分搜索不是只有说使用模板的 while() 这样递归才行。使用递归函数递归也是一个好方法！做法有千万种，理解了思想最重要]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两数之和 II - 输入有序数组_167]]></title>
    <url>%2Fposts%2Ftwo-sum-ii-input-array-is-sorted-167%2F</url>
    <content type="text"><![CDATA[难度：简单 这是该题的地址：https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/ 给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。 函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。 说明: 返回的下标值（index1 和 index2）不是从零开始的。 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 示例: 123输入: numbers = [2, 7, 11, 15], target = 9输出: [1,2]解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 我的思路一、暴力破解暴力破解的代码好像和我们原来的 两数之和 的暴力是一样的。。。 这题其实大家一看到就知道如果暴力破解的话，代码写的应该是很简单的。时间复杂度应该是O(n^2)，但是很显然这样的做法是非常的低效的。。。 1234567891011public int[] twoSum3(int[] numbers, int target) &#123; for(int i=0;i&lt;numbers.length;i++)&#123; for(int j=i+1;j&lt;numbers.length;j++)&#123; if(numbers[i]+numbers[j]==target)&#123; return new int[]&#123;i+1,j+1&#125;; &#125; &#125; &#125; return null;&#125; 二、二分查找本题的题目就有二分搜索，其实一开始我是有点懵的，因为他有两个 index1和index2 两个点要确定，二分搜索好像不能一次性确定两个点呀。。。做法是用：一个index用for循环遍历所有点来确定第一个点，另一个 index 用二分查找来确定。时间复杂度为 O(nlongn) 12345678910111213141516171819202122232425 //二分查找 O(nlogn) 比暴力快public int[] twoSum(int[] numbers, int target) &#123; if(numbers.length&lt;2)&#123; return null; &#125; int[] result = new int[2]; int index1 = 0; int index2 = 0; for(int i=0;i&lt;numbers.length;i++)&#123; index1 = i; int left = i+1; int right = numbers.length; while(left&lt;right)&#123; int mid = (left+right)/2; if(numbers[mid]+numbers[index1]&lt;target)&#123; left = mid+1; &#125;else if(numbers[mid]+numbers[index1]&gt;target)&#123; right = mid; &#125;else&#123; return new int[]&#123;index1+1,mid+1&#125;; &#125; &#125; &#125; return null; &#125; ps:虽然用上了二分查找，但是因为外面有一层for循环遍历，时间复杂度仍然很高，感觉没必要为了使用二分查找而强行这么写。 三、双指针法定义两个指针分别从数组的头部和尾部开始遍历，假如头尾之和大于target，那么尾指针就向前移一位。假如头尾之和小于target，那么头指针就向后移一位，如果头尾指针大于了尾指针，则说明数组中没有这个数。 1234567891011121314public int[] twoSum2(int[] numbers, int target) &#123; int index1 = 0; int index2 = numbers.length-1; while(index1&lt;index2)&#123; if(numbers[index1]+numbers[index2]&gt;target)&#123; index2--; &#125;else if(numbers[index1]+numbers[index2]&lt;target)&#123; index1++; &#125;else&#123; return new int[]&#123;index1+1,index2+1&#125;; &#125; &#125; return null;&#125; 总结一个题目的做法有很多，没必要说我一定要用这种做法做出来才行。当然既然是练习，肯定就是抓住某一点来练啦哈哈。既然我们做到了两数之和II，那我觉得我们可以回顾一下leetcode的第一题 两数之和~]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三角形最小路径和_120]]></title>
    <url>%2Fposts%2Ftriangle-120%2F</url>
    <content type="text"><![CDATA[难度：中等 这是本题的地址：https://leetcode-cn.com/problems/triangle/ 给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。 例如，给定三角形： 123456[ [2], [3,4], [6,5,7], [4,1,8,3]] 自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。 说明： 如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。 我的思路该题应该使用动态规划求解的。但是一开始我写了一段应该是深搜遍历所有子节点的方案，最后超时了。这也证明了动态规划在解决这类重复子问题有很好的效果。 那么我们从题目中可以得知：自顶而下最小路径和无非就是最上层的结点无非就是 选则自己下面结点的值更小的那一个，然后再加上自己的值 就是最小路径和。 一、深搜遍历深搜的想法就是找到每一个最小的结点，然后再一层一层的慢慢往回加，得出的顶部元素就是最优解。这样的做法的问题就在于，每一次深搜都有相同的节点被搜索过了，在这些地方浪费了相当多的时间。 1234567891011121314151617 public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; if(triangle.size()==0||triangle==null||(triangle.size()==1&amp;&amp;triangle.get(0).size()==0))&#123; return 0; &#125; return getmini(0,0,triangle); &#125;//这里没有用上动态规划 很尴尬 只用上了递归去深搜。。。。。public int getmini(int i,int j,List&lt;List&lt;Integer&gt;&gt; triangle)&#123; if((i==triangle.size()-1)||(j==triangle.size()))&#123; return triangle.get(i).get(j); &#125; //获取两个子节点中小的一个 int key = Math.min(getmini(i+1,j,triangle),getmini(i+1,j+1,triangle)); return key+triangle.get(i).get(j);&#125; 二、动态规划动态规划就在于 用一个最优解数组 opt[i] [j] 来保存当前节点的最优解。我们可以将获得最优解的递归式写成这样： opt[i-1] [j] = opt[i-1] [j] = Math.min(opt[i] [j],opt[i] [j+1]) + triangle.get(i-1).get(j); 这样就可以得到上一层节点的最优解。 1234567891011121314151617181920public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; if(triangle.size()==0||triangle==null||(triangle.size()==1&amp;&amp;triangle.get(0).size()==0))&#123; return 0; &#125; int[][] opt = new int[triangle.size()][triangle.size()]; //初始化opt最下面一层的值 for(int j = 0;j&lt;triangle.size();j++)&#123; opt[triangle.size()-1][j] = triangle.get(triangle.size()-1).get(j); &#125; //从最底层开始 int i = triangle.size()-1; while(i!=0)&#123; for(int j=0;j&lt;i;j++)&#123; //上一层节点的值等于这一层两个节点的值小的哪个加上上一层的值。 opt[i-1][j] = Math.min(opt[i][j],opt[i][j+1]) + triangle.get(i-1).get(j); &#125; i--; &#125; return opt[0][0];&#125; 三、让我们的算法更加分题目说了如果我们能只用额外的O(n)空间解决这个问题就更好了。 那么n的空间就代表原来的List的空间。那么我们刚刚使用了二维数组opt[] [] 肯定是不能加分啦。通过分析别的的答案，我发现了加分解法是使用一维数组 opt[triangle.size()] 这样空间的问题解决了。但是如何获取解的呢？ 123456789101112131415public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; if(triangle.size()==0||triangle==null||(triangle.size()==1&amp;&amp;triangle.get(0).size()==0))&#123; return 0; &#125; int[] dp = new int[triangle.size()]; //从最底层往上遍历 for(int i=triangle.size()-1;i&gt;=0;i++)&#123; //当前层的结点和当前层的层数是一样的 for(int j=0;j&lt;=i;j++)&#123; //原来的dp[j]和dp[j+1]是下一层的，那么重新赋值现在这一层的dp[j]是不冲突的~ dp[j] = Math.min(dp[j],dp[j+1]) + triangle.get(i).get(j); &#125; &#125; return dp[0];&#125; 我的反思以后要向着做出最优解的方式来做！ 相似题目 967.连续相同数字 303.区域和检索 - 数组不可变]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最长有效括号_32]]></title>
    <url>%2Fposts%2Flongest-valid-parentheses-32%2F</url>
    <content type="text"><![CDATA[难度：困难 该题的地址是https://leetcode-cn.com/problems/longest-valid-parentheses/ 给定一个只包含 &#39;(&#39; 和 &#39;)&#39; 的字符串，找出最长的包含有效括号的子串的长度。 示例 1: 123输入: &quot;(()&quot;输出: 2解释: 最长有效括号子串为 &quot;()&quot; 示例 2: 123输入: ")()())"输出: 4解释: 最长有效括号子串为 "()()" 我的思路一、动态规划本题我一开始是想使用动态规划做的。opt[s.length()] 这个在当是右括号的时候记录长度。 例子: (()) 获取当前括号的长度就是前面括号的长度加上自己的长度 那么递归式就得出当前的括号长度 = 前一个括号长度 + 自己括号的长度：opt[i] = opt[i-1]+2 。 但是之前的例子： ()() 假如在当前括号之前有括号，长度也要计算进去。 其实我们很容易可以知道 当前括号的左括号的位置 = 我们当前括号的位置 - 中间括号的长度 即是 i - opt[i-1] -1 （如果再-1 就是前面括号的右括号的位置了） 那么 我们的递归式就要修改为 opt[i] = opt[i-1] + 2 + opt[i - opt[i-1] -2] 这样就可以将当前的括号长度与之前的括号长度加在一起。 12345678910111213141516171819202122232425262728public int longestValidParentheses(String s) &#123; if(s.length()&lt;2)&#123; return 0; &#125; int[] opt = new int[s.length()]; opt[0] = 0; int sum =0; for(int i = 1;i&lt;s.length();i++)&#123; //当是右括号的时候进入判断 if(s.charAt(i)==')')&#123; //获取前面的括号的位置 int key = i - opt[i-1] -1; if(key&gt;=0)&#123; if(s.charAt(key)=='(')&#123; if(key==0)&#123;//当是0时 说明没有前面的括号了 opt[i] = opt[i-1] + 2; &#125;else&#123;//不是0时 说明当前括号的位置之前还有括号，把他们的长度加上。 opt[i] = opt[i-1] + 2 + opt[key-1]; &#125; &#125; &#125; &#125; if(sum&lt;opt[i])&#123; sum = opt[i]; &#125; &#125; return sum;&#125; 二、栈做法栈做法的思路是用栈储存括号，每当匹配的时候，可以比较当前节点的位置和前一个未能出栈的节点的位置的距离。就可以得出最长的路径。 12345678910111213141516171819202122232425262728293031public int longestValidParentheses3(String s) &#123; int max = 0, start = 0; if(null == s) &#123; return 0; &#125; int len = s.length(); Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for(int index = 0; index &lt; len; index++)&#123; //遇左括号(，将当前元素的下表push进栈里 if('(' == s.charAt(index))&#123; stack.push(index); continue; &#125; else &#123; // 因为遇到右括号的时候是不会将他入栈的， //而且假如右括号前面没有节点的话肯定是不能通过的，不需要让他入站。将他的下标值记录下来。之后的获取长度都可以用它。 if(stack.isEmpty())&#123; start = index+1; continue; &#125; else &#123; stack.pop(); if(stack.isEmpty())&#123; max = Math.max(max, index-start+1); &#125; else &#123; max = Math.max(max, index-stack.peek()); &#125; &#125; &#125; &#125; return max;&#125; 我的反思我觉得这里的思路我一开始都不是很清晰，感觉还是蛮复杂的。我觉得我需要刷多点这些题，可以让我变得更好！ 该题的类似:20.有效的括号]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的最大深度_104]]></title>
    <url>%2Fposts%2Fmaximum-depth-of-binary-tree-104%2F</url>
    <content type="text"><![CDATA[难度：简单 我觉得这题与111最小深度相同，都是简单的DFS和BFS 这是本题的地址：https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/ 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例：给定二叉树 [3,9,20,null,null,15,7]， 12345 3 / \9 20 / \ 15 7 返回它的最大深度 3 。 我的思路这题可以使用DFS和BFS两种做法。 DFS：深度优先搜索，每次搜索都回搜索到最底层的叶子节点。这样可以可以很轻松的得到最长路径了。 BFS：广度优先搜索，一层一层的遍历所有的子节点。到最后一层就可以得出最长的路径。 123456789101112131415161718//DFS --这是我一开始的递归做法int max = 0;public int maxDepth(TreeNode root) &#123; dfs(root,1); return max;&#125;void dfs(TreeNode root,int now)&#123; if(root==null)&#123; return; &#125; if(max&lt;now)&#123; max = now; &#125; now++; dfs(root.left,now); dfs(root.right,now);&#125; 1234567891011121314151617181920212223//BFSpublic int maxDepth(TreeNode root)&#123; Queue&lt;TreeNode&gt; queue = new LinkedList(); if(root!=null)&#123; queue.add(root); &#125; int sum = 0; while(!queue.isEmpty())&#123; int size = queue.size(); while(size!=0)&#123; TreeNode tr = queue.poll(); if(tr.left!=null)&#123; queue.add(tr.left); &#125; if(tr.right!=null)&#123; queue.add(tr.right); &#125; size--; &#125; sum++; &#125; return sum;&#125; 我的反思我觉得我DFS的时候使用了类的局部变量，感觉这样做并不是很好。因为这样可能方法没有调用它，但是它在对象实例化的时候就会被初始化。应该修改成用到的时候再初始化会更好一点。 官方题解他也是用到了dfs 感觉比我的好多了 以后我使用dfs也尽量写成简洁的样式 123456789public int maxDepth3(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; else &#123; int left_height = maxDepth(root.left); int right_height = maxDepth(root.right); return java.lang.Math.max(left_height, right_height) + 1; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的层次遍历_102]]></title>
    <url>%2Fposts%2Fbinary-tree-level-order-traversal-102%2F</url>
    <content type="text"><![CDATA[难度：中等 我觉得这道题让我加深了对深搜和广搜的理解 在这道题之后、可以去看看题目103、107、111这几道都是很简单的广度优先搜索的题目 这是本题的地址：https://leetcode-cn.com/problems/binary-tree-level-order-traversal/ 给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。 例如:给定二叉树: [3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 返回其层次遍历结果： 12345[ [3], [9,20], [15,7]] 我的思路这道题也是用BFS广度优先搜索来做一下~。其实用广搜遍历完整棵树很简单，但是我们要做把每一层都装进list里面返回。所以重点在于装进每遍历完一层就将所有节点的值放进list里面。 我的做法是这样的，因为一开始需要用一个队列来装广搜的每一层的节点，假如用一个int 来区分一个队列里面子节点和父节点的分界线的话我觉得好像不太好，所以我用了两个队列来分开装父节点和子节点。然后再遍历，每当一个队列为空时将list数据装进总的list里面，最后返回总的list。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; ls = new ArrayList&lt;&gt;(); List&lt;Integer&gt; ls1 = new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; tr1= new LinkedList&lt;&gt;(); Queue&lt;TreeNode&gt; tr2= new LinkedList&lt;&gt;(); if(root!=null)&#123; tr1.add(root); &#125; //条件满足时说明已经没有子节点了 while(!tr1.isEmpty()||!tr2.isEmpty())&#123; //这一重判断是交替使用队列 if(tr2.isEmpty())&#123; //然后再将这条队列中的所有节点放进ls1子列表中。当结束时就把ls1放入总列表ls中 while(!tr1.isEmpty())&#123; TreeNode nowNode = tr1.poll(); ls1.add(nowNode.val); if(tr1.isEmpty())&#123; ls.add(ls1); ls1 = new ArrayList&lt;&gt;(); &#125; //将非空的节点放入队列 if(nowNode.left!=null)&#123; tr2.add(nowNode.left); &#125; if(nowNode.right!=null)&#123; tr2.add(nowNode.right); &#125; &#125; &#125;else&#123; while(!tr2.isEmpty())&#123; TreeNode nowNode = tr2.poll(); ls1.add(nowNode.val); if(tr2.isEmpty())&#123; ls.add(ls1); ls1 = new ArrayList&lt;&gt;(); &#125; if(nowNode.left!=null)&#123; tr1.add(nowNode.left); &#125; if(nowNode.right!=null)&#123; tr1.add(nowNode.right); &#125; &#125; &#125; &#125; return ls;&#125; 我的反思我的结果: 我觉得我的时间复杂度是O(n^2);但是我的代码好长，而且感觉我的重复代码有点多，官方虽然没有给出官方解答，但是我们不能失去追求优雅代码的意愿！那么就去看看别人的代码有什么好操作把！ PLAN A 改动改动计划：去掉多余的重复代码，去掉多余的队列，用int size 来记录父节点有多少个来区分一个队列中的父节点和子节点。 1234567891011121314151617181920212223242526public List&lt;List&lt;Integer&gt;&gt; levelOrder2(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; ls = new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; tr1= new LinkedList&lt;&gt;(); if(root!=null)&#123; tr1.add(root); &#125; while(!tr1.isEmpty())&#123; List&lt;Integer&gt; ls1 = new ArrayList&lt;&gt;(); //获取当前队列的大小作为当前层节点的个数 int size = tr1.size(); //当size为空时说明当前层的节点已经全部放入ls中了 while(size!=0)&#123; TreeNode t = tr1.poll(); ls1.add(t.val); if(t.left!=null)&#123; tr1.add(t.left); &#125; if(t.right!=null)&#123; tr1.add(t.right); &#125; size--; &#125; ls.add(ls1); &#125; return ls;&#125; 我的结果: PLAN B 改动使用DFS 深度优先遍历，当到达一个节点时，判断是否位空，位空则返回上一层，不为空，则判断当前的节点是否处于那一层，若超过了 总list 的size 则需要新建一个新的list来存新一层的节点数据。然后将当前节点存进对应的总list层数中。最后继续深搜 往下寻找 tr.left 和 tr.right; (ps:代码可以忽略=-= 毕竟是看了别人做法，所以基本写的也是一样的） 12345678910111213141516171819public List&lt;List&lt;Integer&gt;&gt; levelOrder3(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; ls = new ArrayList&lt;&gt;(); digui_3(root,0,ls); return ls;&#125;void digui_3(TreeNode tr,int level,List&lt;List&lt;Integer&gt;&gt; ls)&#123; //判断当前节点是否为空，作为结束递归的条件 if(tr==null)&#123; return; &#125; //当 当前层 比ls中的列表多，增加新一个列表来存储新的一层的节点 if(ls.size()-1&lt;level)&#123; ls.add(new ArrayList&lt;&gt;()); &#125; ls.get(level).add(tr.val); digui_3(tr.left,level+1,ls); digui_3(tr.right,level+1,ls);&#125; 我的结果： 最后的一点小疑问？通过改动PlAN B发现 在这次的题目中DFS比BFS速度要快一些。可以深入了解一下DFS和BFS的时间复杂度解析，增加对它们的了解。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>树</tag>
        <tag>BFS</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Queue队列-java源码了解]]></title>
    <url>%2Fposts%2FQueue%E9%98%9F%E5%88%97-java%2F</url>
    <content type="text"><![CDATA[ok 因为在题目里面遇到了Queue，所以我就来了解一下Queue这个接口的功效吧！ 来看看里面的注释是怎么说这个类的，英语四级启动！： 它说这是一个围在处理钱保存元素和设计的集合。基于util类库的操作，队列支持 额外的 插入、 提取 检查 操作。 每一个方法都存在两个形式： 1）在操作失败时抛出一个异常。 2）返回一个特殊值 null 或 false （取决于你的操作）。 第二种形式 在 插入操作中被特别设计成容量受限的情况。在大多数的情况下，插入操作不能出错。 来看看Queue接口的源码12public interface Queue&lt;E&gt; extends Collection&lt;E&gt; &#123;&#125; Queue从jdk1.5出现 继承Collection这个接口，方法一共有六个： add方法1boolean add(E e); 将指定的元素插入此队列，成功则返回true，如果没有足够的空间 则抛出一个异常。 可能的异常有4个IllegalStateException、ClassCastException、NullPointerException、IllegalArgumentException offer方法1boolean offer(E e); 这个方法和add方法一样时将元素插入队列中的，不同之处在于，当队列因为没有足够空间插入元素时，这个元素会返回false而不是抛出IllegalStateException异常。 可能的异常有3个ClassCastException、NullPointerException、IllegalArgumentException。 remove方法1E remove(); 检索并删除此队列的头部元素，这种方法在队列为空时会抛出异常 NoSuchElementException。 poll方法1E poll(); 这个方法和remove方法一样，不同之处在于在队列为空时 poll是返回一个null而不是抛出异常。 element方法1E element(); 检索但不删除队列的头部，如果队列为空则会抛出一个异常 NoSuchElementException。 peek方法1E peek(); 这个方法和element方法一样，不同之处在于如果队列位空，返回的是null而不是抛出异常。]]></content>
      <categories>
        <category>ThinkinJava</category>
      </categories>
      <tags>
        <tag>Java源码</tag>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对称二叉树_101]]></title>
    <url>%2Fposts%2FisSymmetric-101%2F</url>
    <content type="text"><![CDATA[难度：简单 这是本题的地址：https://leetcode-cn.com/problems/symmetric-tree/ 给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 12345 1 / \ 2 2 / \ / \3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 12345 1 / \2 2 \ \ 3 3 题目给出的树的结构： 123456class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125; &#125; 我的思路这题让我思路头大，因为之前还没有做过树的题目，深搜广搜虽然了解大概是怎么样的做法却没有实际使用上。 这道题一开始我是想着如果要证明它们是镜像对称的，那么树的left的left节点 应该和right的right节点相同，left的right节点应该和right的left节点相同。 那么每当 left.val 和 right.val 的值相等的时候。 就进行递归digui(left.left,right.right) 和 digui(left.right,right.left) 这两个递归。这里要注意的就是一开始是使用两个root进入从而避免了一开始就要写left和right。 123456789101112public boolean isSymmetric(TreeNode root) &#123; return digui(root,root);&#125;public Boolean digui(TreeNode t1,TreeNode t2)&#123; if(t1==null&amp;&amp;t2==null)&#123; return true; &#125;else if(t1==null||t2==null)&#123; return false; &#125; return(t1.val==t2.val) &amp;&amp; digui(t1.left,t2.right) &amp;&amp; digui(t1.right,t2.left);&#125; 官方思路除了第一个递归之外，官方还写出了迭代的思路，我来试一试。既然这里的代码用到了Queue(队列)，我就去对自己科普了一下java的Queue 代码可以忽略，列一下里面觉得有用的几个点。 123456789101112131415161718192021222324252627public boolean isSymmetric2(TreeNode root) &#123; Queue&lt;TreeNode&gt; ls = new &lt;TreeNode&gt;LinkedList(); ls.add(root); ls.add(root); while(ls.size()!=0)&#123; //poll函数 这个函数我很少用，用处是将队列里第一个元素取出，如果没有则返回null。 TreeNode t1 = ls.poll(); // 每次取出头两个来对比是否相同 TreeNode t2 = ls.poll(); // 判断是和上面的代码是一样的 if(t1==null&amp;&amp;t2==null)&#123; continue; &#125;else if(t1==null||t2==null)&#123; return false; &#125; if(t1.val!=t2.val)&#123; return false; &#125;else&#123; // 往队列里添加新的节点，t1 t2的顺序相反 因为它们是镜像。 ls.add(t1.left); ls.add(t2.right); ls.add(t1.right); ls.add(t2.left); &#125; &#125; return true;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>树</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解码方法_91]]></title>
    <url>%2Fposts%2FnumDecodings-91%2F</url>
    <content type="text"><![CDATA[难度：中等 终于，感觉这道题不是那么的水了~** 这是本题的地址：https://leetcode-cn.com/problems/decode-ways/ 一条包含字母 A-Z 的消息通过以下方式进行了编码： 1234'A' -&gt; 1'B' -&gt; 2...'Z' -&gt; 26 给定一个只包含数字的非空字符串，请计算解码方法的总数。 示例 1: 123输入: "12"输出: 2解释: 它可以解码为 "AB"（1 2）或者 "L"（12）。 示例 2: 123输入: "226"输出: 3解释: 它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。 我的思路这道题是真的挺多坑的。让我头大得很。从题目中的A B ….Z 这个其实可以不用管。这道题也是采用动态规划来做，因为他是从1-26的数字，所以最多只会有2个数字连在一起。不会出现3个数字连在一起的情况。所以而且我们可以发现 12345678910例如字符串："123"。opt[0] = 1; 也就是字符串"1"处的最优解码是1opt[1] = 2; 也就是字符串"2"处的最优解码是2, 他的解码方式是 1 2和 12 其实这时候还不是很好看出递归式。opt[3] = 3; 为什么呢 其实这个我们可以拆解出来。123 可以拆解为：1 2 312 31 23三种。这时候我们可以发现一些有意思的东西，假如把 3 拿出来 1 2和12 这两个不就是opt[1]的值吗？把 23 拿出来剩下的 1 不就是opt[0]的值吗。 这时候我们就可以得出我们的递归式 ： opt[n] = opt[n-1]+opt[n-2] 突然发现这样的递归式不是很常见吗哈哈~ 得到了递归式 其实还有一个很重要的坑那就是：当有一个值为0的时候，我们会发现题目中没有给出0。但是却有10 和 20 这两个符合解码的数。但假如是0开头的是不能解码的。所以我们就要对0这个字符进行判断。如果是有0出现，假如出现了不能解码的情况，那整个字符串都不能解码。 123456789101112131415161718192021222324252627282930public int numDecodings(String s) &#123; int n = s.length(); int[] opt = new int[n]; opt[0] = s.charAt(0)=='0'?0:1; for(int i=1;i&lt;n;i++)&#123; int sum =Integer.parseInt(s.substring(i-1,i+1)); if(s.charAt(i)=='0')&#123; if(sum&lt;10||sum&gt;26)&#123; opt[i] = 0; &#125;else&#123; if(i&lt;2)&#123; opt[i] = opt[i-1]; &#125;else&#123; opt[i] = opt[i-2]; &#125; &#125; &#125;else&#123; if(sum&lt;=26&amp;&amp;sum&gt;=10)&#123; if(i&lt;2)&#123; opt[i] = opt[i-1] + 1; &#125;else&#123; opt[i] = opt[i-1] + opt[i-2]; &#125; &#125; else&#123; opt[i] = opt[i-1]; &#125; &#125; &#125; return opt[n-1];&#125; 我的反思虽然用上了动态规划 但是我觉得里面的if else 也还是有点多….. 别人的速度虽然比我快一点，但是看起来我们的时间复杂度都是O(n)呀。。。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小路径和_64]]></title>
    <url>%2Fposts%2FminPathSum-64%2F</url>
    <content type="text"><![CDATA[这是本题的地址https://leetcode-cn.com/problems/minimum-path-sum/ 给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例: 12345678输入:[ [1,3,1], [1,5,1], [4,2,1]]输出: 7解释: 因为路径 1→3→1→1→1 的总和最小。 我的思路感觉62 63 64 都是连续的题目 都是使用动态规划来做这道题。都是一些很简单的动态规划。 从题目中我们可以了解递归式： 1opt[i][j] = (opt[i-1][j]&lt;opt[i][j-1]?opt[i-1][j]:opt[i][j-1]) + grid[i][j]; 通过使用这个递归式最终我们可以得出我们想要的结果 12345678910111213141516171819202122public int minPathSum(int[][] grid) &#123; if(grid==null || grid.length==0 ||(grid.length==1&amp;&amp;grid[0].length==0))&#123; return 0; &#125; int n = grid.length; int m = grid[0].length; int[][] opt = new int[n][m]; for(int i = 0;i&lt;n;i++)&#123; for(int j =0;j&lt;m;j++)&#123; if (i == 0 &amp;&amp; j == 0) &#123; opt[i][j] = grid[i][j]; &#125;else if(i == 0)&#123; opt[i][j] = grid[i][j]+opt[i][j-1]; &#125;else if(j == 0)&#123; opt[i][j] = grid[i][j]+opt[i-1][j]; &#125;else&#123; opt[i][j] = (opt[i-1][j]&lt;opt[i][j-1]?opt[i-1][j]:opt[i][j-1]) + grid[i][j]; &#125; &#125; &#125; return opt[n-1][m-1];&#125; 我的反思最终跑出来的速度比别人的慢很多，但是我看了下别人的范例代码。我觉得我们的代码好像都是一样的呀？有的人也用递归来做，也不知道是不是更好一些。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不同路径II_63]]></title>
    <url>%2Fposts%2FuniquePathsWithObstacles-63%2F</url>
    <content type="text"><![CDATA[这是本题的地址：https://leetcode-cn.com/problems/unique-paths-ii/ 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ 网格中的障碍物和空位置分别用 1 和 0 来表示。 说明：*m 和 n* 的值均不超过 100。 示例 1: 123456789101112输入:[ [0,0,0], [0,1,0], [0,0,0]]输出: 2解释:3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 2 条不同的路径：1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右 我的思路这道题和uniquePaths-62 类似。但是增加了一个障碍的条件。我的做法其实和之前的差不多，但是增加了一些关于遇到“障碍”时的判断。这道题也是使用动态规划~，有一个问题在于假如传入的是空的数组。获取第二维的长度的时候会报错。 判断二维数组是否位空： if ( array == null || array.length == 0 || ( array.length == 1 &amp;&amp; array[0].length == 0 ) ) 1234567891011121314151617181920212223public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; int n = obstacleGrid.length; int m = obstacleGrid[0].length; int[][] opt = new int[n][m]; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++)&#123; if(obstacleGrid[i][j]==1)&#123; opt[i][j] = 0; &#125;else&#123; if(i==0&amp;&amp;j==0)&#123; opt[i][j] =1; &#125;else if(i==0)&#123; opt[i][j] = opt[i][j-1]; &#125;else if(j==0)&#123; opt[i][j] = opt[i-1][j]; &#125;else&#123; opt[i][j] = opt[i][j-1]+opt[i-1][j]; &#125; &#125; &#125; &#125; return opt[n-1][m-1];&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不同路径_62(java)]]></title>
    <url>%2Fposts%2FuniquePaths-62%2F</url>
    <content type="text"><![CDATA[这是本题的地址:https://leetcode-cn.com/problems/unique-paths/ 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 问总共有多少条不同的路径？ 例如，上图是一个7 x 3 的网格。有多少可能的路径？ 说明：*m 和 n* 的值均不超过 100。 示例 1: 1234567输入: m = 3, n = 2输出: 3解释:从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -&gt; 向右 -&gt; 向下2. 向右 -&gt; 向下 -&gt; 向右3. 向下 -&gt; 向右 -&gt; 向右 示例 2: 12输入: m = 7, n = 3输出: 28 我的思路这题我是想着使用动态规划来做的，这个与之前动态规划不同的是 他是一个二维数组。这样的话最优解opt的数组也是一个二维数组。且题目中说明每次只能向下或向右移动一步。这样的话，递归式应该是这样：opt [n] [m] = opt[n-1] [m] + opt[n] [m-1]。得到了递归式，我们就可以开始进行操作了。 12345678910111213141516public int uniquePaths(int m, int n) &#123; if(m==0||n==0)&#123; return 0; &#125; int[][] opt = new int[m][n]; for(int i=0;i&lt;m;i++)&#123; for(int j=0;j&lt;n;j++)&#123; if(i==0||j==0)&#123; opt[i][j]=1; &#125;else&#123; opt[i][j] = opt[i][j-1]+opt[i-1][j]; &#125; &#125; &#125; return opt[m-1][n-1];&#125; 我感觉不太好，因为要使用两个for 但是好像必须这样，因为是一个二维数组。时间复杂度：O(n^2)。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加一_66(java)]]></title>
    <url>%2Fposts%2FplusOne-66%2F</url>
    <content type="text"><![CDATA[这是本题的地址https://leetcode-cn.com/problems/plus-one/ 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1: 123输入: [1,2,3]输出: [1,2,4]解释: 输入数组表示数字 123。 示例 2: 123输入: [4,3,2,1]输出: [4,3,2,2]解释: 输入数组表示数字 4321。 我的思路这道题我觉得同 addTwoNumbers-2-两数之和 题有一点点类似，但是一个是链表一个是数组 我的做法是这样的。从数组最后一个数字进行遍历，将其+1。若果超过了10。那么当前的数就要%10。并且flag=1。 通过flag来查看是否需要添加一位最新的数。如需要 就用for循环新建一个数组。如不需要就直接返回当前数组。 123456789101112131415161718192021public int[] plusOne(int[] digits) &#123; int flag =0; for(int i=digits.length-1;i&gt;=0;i--)&#123; digits[i]+=1; if(digits[i]&gt;=10)&#123; flag =1; digits[i] = digits[i]%10; &#125;else&#123; flag =0; &#125; if(flag==0)&#123;break;&#125; &#125; int[] a = new int[digits.length+1]; if(flag==1)&#123; a[0] = 1; for(int i=1;i&lt;=digits.length;i++)&#123; a[i] = digits[i-1]; &#125; &#125; return flag==1?a:digits;&#125; 时间复杂度为 ：O(n) n为数组的长度。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最后一个单词长度_58(java)]]></title>
    <url>%2Fposts%2FlengthOfLastWord-58%2F</url>
    <content type="text"><![CDATA[这是本题的地址：https://leetcode-cn.com/problems/length-of-last-word/ 给定一个仅包含大小写字母和空格 &#39; &#39; 的字符串，返回其最后一个单词的长度。 如果不存在最后一个单词，请返回 0 。 说明：一个单词是指由字母组成，但不包含任何空格的字符串。 示例: 12输入: "Hello World"输出: 5 我的思路：一开始想着用lastindexof来做，但是不行。因为假如是”a b “ 这样的字符串。用lastindexof是行不通的。那么我们就用for循环开始遍历整个字符串。获取字符的长度。每当是’ ‘的时候，就将长度值设为0。lastlength用于记录上个字符的长度。length记录当前字符的长度。当length为0时 说明 ‘ ’符后面没有字符了。这时候就需要返回lastlength 12345678910111213public int lengthOfLastWord(String s) &#123; int length=0; int lastlength=0; for(int i=0;i&lt;s.length();i++)&#123; if(s.charAt(i)==' ')&#123; lastlength = length==0?lastlength:length; length = 0; &#125;else&#123; length++; &#125; &#125; return length==0?lastlength:length;&#125; 官方思路没有，让我们来看看别人的做法是怎么样的 看了一下范例，发现其实大多数都是用for循环的。它们从最后开始往回找，这样循环的遍历就少多了。但既然都是用for循环。就不列出来了。有一个蛮有意思的： 他的做法是用trim去掉首尾的 “ “空格符，通过寻找剩下的” “空格符。如果没有就返回整体的长度。如果有就判断是否有字符串，没有就返回0。最后再返回原长度-i-1。 i就是倒数的” “空格符的位置。那么减去它就相当于减掉了前面的长度。再-1就是把” “空格符所占的1个位置给减掉了~。 123456789101112public int lengthOfLastWord2(String s) &#123; s = s.trim(); int i = s.lastIndexOf(" "); if (i == -1)&#123; return s.length(); &#125; if (i == s.length()-1)&#123; return 0; &#125;else &#123; return s.length()-i-1; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[weekgame_122]]></title>
    <url>%2Fposts%2Fweekgame-122%2F</url>
    <content type="text"><![CDATA[这是该题的地址：https://leetcode-cn.com/contest/weekly-contest-122/problems/sum-of-even-numbers-after-queries/ 给出一个整数数组 A 和一个查询数组 queries。 对于第 i 次查询，有 val = queries[i][0], index = queries[i][1]，我们会把 val 加到 A[index] 上。然后，第 i 次查询的答案是 A中偶数值的和。 （此处给定的 index = queries[i][1] 是从 0 开始的索引，每次查询都会永久修改数组 A。） 返回所有查询的答案。你的答案应当以数组 answer 给出，answer[i] 为第 i 次查询的答案。 示例： 12345678输入：A = [1,2,3,4], queries = [[1,0],[-3,1],[-4,0],[2,3]]输出：[8,6,2,4]解释：开始时，数组为 [1,2,3,4]。将 1 加到 A[0] 上之后，数组为 [2,2,3,4]，偶数值之和为 2 + 2 + 4 = 8。将 -3 加到 A[1] 上之后，数组为 [2,-1,3,4]，偶数值之和为 2 + 4 = 6。将 -4 加到 A[0] 上之后，数组为 [-2,-1,3,4]，偶数值之和为 -2 + 4 = 2。将 2 加到 A[3] 上之后，数组为 [-2,-1,3,6]，偶数值之和为 -2 + 6 = 4。 提示： 1 &lt;= A.length &lt;= 10000 -10000 &lt;= A[i] &lt;= 10000 1 &lt;= queries.length &lt;= 10000 -10000 &lt;= queries[i][0] &lt;= 10000 0 &lt;= queries[i][1] &lt; A.length 我的思路根据题目，我们可以得知，answer的长度为i 而i的值则是queries的长度。那么我们可以通过遍历queries数组。然后对数组A进行操作。之后通过遍历数组A 找出偶数，并相加求出和。然后得出一个值，放进anwser数组里。 1234567891011121314public int[] sumEvenAfterQueries(int[] A, int[][] queries) &#123; int [] answer = new int[queries.length]; for(int i=0;i&lt;queries.length;i++)&#123; A[queries[i][1]] += queries[i][0]; int sum =0; for(int j=0;j&lt;A.length;j++)&#123; if(A[j]%2==0)&#123; sum+=A[j]; &#125; &#125; answer[i] = sum; &#125; return answer;&#125; 缺点：使用了暴力破解。时间复杂度增高。 官方思路感觉官方的思路比较聪明，通过先找出A数组中的偶数和。然后再通过添加的操作判断当前数是否还是偶数。这样的话只需要通过单个循环就可以实现了。 https://leetcode-cn.com/articles/sum-of-even-numbers-after-queries/]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬楼梯-70(java)]]></title>
    <url>%2Fposts%2FclimbStairs-70%2F</url>
    <content type="text"><![CDATA[这是本题的地址https://leetcode-cn.com/problems/climbing-stairs/ 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 12345输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1. 1 阶 + 1 阶2. 2 阶 示例 2： 123456输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1. 1 阶 + 1 阶 + 1 阶2. 1 阶 + 2 阶3. 2 阶 + 1 阶 我的思路：其实这个仔细的看一下就会发现和哪个斐波那契数列第n项问题很像。主要的递归式就是 f[n] = f[n-1]+f[n-2]。 通过这个式子我们就可以得出第n个梯子有多少种变化啦~最后返回数组的n-1即可。 1234567891011121314public int climbStairs(int n) &#123; if(n==1)&#123; return 1; &#125;else if(n==2)&#123; return 2; &#125; int[] foot = new int[n]; foot[0] = 1; foot[1] = 2; for(int i=2;i&lt;n;i++)&#123; foot[i] = foot[i-1]+foot[i-2]; &#125; return foot[n-1];&#125; 我的结果]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大子序和-53]]></title>
    <url>%2Fposts%2FmaxSubArray-53%2F</url>
    <content type="text"><![CDATA[这是本题的地址：https://leetcode-cn.com/problems/maximum-subarray/ 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 123输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 我的思路1、暴力： 循环遍历当前数组的每个节点，设定一个int sum值来记录最长的子字符串的长度。 123456789101112public int maxSubArray(int[] nums) &#123; int n = nums.length; int sum=nums[0]; for(int i=0;i&lt;n;i++)&#123; int sum1 =0; for(int j=i;j&gt;=0;j--)&#123; sum1 += nums[j]; sum = sum&gt;sum1?sum:sum1; &#125; &#125; return sum;&#125; 缺点： 慢。能不用就不用 2、动态规划： 进行一次遍历： 每当前面的子序之和为负值时，也就证明了有没有前面的数字都是无所谓的，这时候，就可以重新记录子序和了~。然后将这些进行比较，最大的就返回出来。 12345678910111213public int maxSubArray2(int[] nums) &#123; int max= nums[0]; int sum=0; for(int i=0;i&lt;nums.length;i++)&#123; if(sum&gt;0 )&#123; sum+=nums[i]; &#125;else&#123; sum=nums[i]; &#125; max = Math.max(sum,max); &#125; return max;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最长回文子串_5]]></title>
    <url>%2Fposts%2FlongestPalindrome-5%2F</url>
    <content type="text"><![CDATA[这是本题的地址：https://leetcode-cn.com/problems/longest-palindromic-substring/ 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 123输入: "babad"输出: "bab"注意: "aba" 也是一个有效答案。 示例 2： 12输入: "cbbd"输出: "bb" 我的思路：有一个String sum =”” 来保存最大的回文。 有第一个for(int i=0)循环遍历整个字符串。然后第二个字符串由j=i 开始，判断这i j之间是否是回文。如果是，那么j-i+1(加1是因为j和i相同时，也是有一个字符的)是否大于sum的长度。如果大于，那么他们就是最大的回文。 那么用于判断ij之间是否为回文的方法我是这样做的：先判断当前i j的字符是否相同，如果相同则判断 i j 是否相等或相邻，如果是那么就返回true。如果不是那么进行 i+1 和 j-1的递归。若果i j的字符不相同，则返回false；这样是暴力解法。时间复杂度 n3次方。 123456789101112131415161718192021222324public String longestPalindrome(String s) &#123; String sum = ""; for(int i=0;i&lt;s.length();i++)&#123; for(int j=i;j&lt;s.length();j++)&#123; if(Panduan(i,j,s))&#123; if(j-i+1&gt;sum.length())&#123; sum = s.substring(i,j+1); &#125; &#125; &#125; &#125; return sum;&#125;boolean Panduan(int a,int b,String s)&#123; if(s.charAt(a)==s.charAt(b))&#123; if(a==b||a==b-1||a-1==b)&#123; return true; &#125; return Panduan(++a,--b,s); &#125;else&#123; return false; &#125;&#125; 我的结果： 特别的慢：这也是暴力解法的问题所在！ 在官方的解答中：有动态规划和中心扩展算法这两个。等我看懂了再补充上来！~]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清理：终结处理和垃圾回收]]></title>
    <url>%2Fposts%2F%E6%B8%85%E7%90%86%EF%BC%9A%E7%BB%88%E7%BB%93%E5%A4%84%E7%90%86%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%2F</url>
    <content type="text"><![CDATA[清理：终结处理和垃圾回收垃圾回收的三个要点 1、对象可能不被垃圾回收 2、垃圾回收并不等于“析构” 3、垃圾回收只和内存有关 java 中允许调用finalize方法，这个方法却不能作为通用的清理方法。因为程序没有濒临储存空间用完，那么就不需要释放内存。因为垃圾回收也是需要开销的，如果不用它，那么这部分开销就省下来了。那么finalize方法在什么时候可以调用呢：在通过某种创建对象方式以外的方式为对象分配了储存空间，但是java一切皆为对象。。。this is special！ *java中有一种“本地方法”，它是一种在java中调用的非java代码，在jdk1.5时是只支持c/c++的，它可能会调用c的函数来分配对象，也可能调用任何其他语言。so，这些都需要特定的储存释放方法来释放。这时候finalize就有用武之地了。 垃圾回收机制1、引用计数这是一种很简单但是很慢的垃圾回收技术，每个对象都有一个引用计数器，当有引用链接到对象时，引用计数+1，当引用离开作用域或被置为null，引用计数就会-1，当引用计数=0的时候就回回收对象。 缺陷：当对象之前存在循环引用，引用计数不为0时但又要被回收的时候，这样对于垃圾回收工作量非常大。引用计数常用来说明垃圾收集的工作方式，没有被应用于任何java虚拟机实现。 2、自适应垃圾回收技术：停止-复制暂停程序的运行，将当前堆所有存活的对象复制到另一个堆，没有被复制的都会被垃圾回收。当对象被复制到新的堆中的时候，它们时一个挨着一个的。所以新堆抱持紧凑排列，以后的分配空间也很简单。 缺点： –1 效率低，需要有两个堆。维护比实际需要多一倍的空间。 某些java虚拟机的处理方式：按需从内存中分配较大块的内存，复制动作发生在他们里面。 –2 程序进入稳定状态之后可能只会产生少量的垃圾，但是如果用这个还是会将内存从一处复制到另外一处。 3、自适应垃圾回收技术：标记-清扫基于上一份放的问题2，产生了新的垃圾回收机制：标记-清扫。遍历所有的引用，找出活对象并标记，在全部标记完成之后，才会进行清扫工作。把没有标记的对象都进行垃圾回收。这样下来，剩下的空间是不连续的。 小总结java虚拟机会进行监视，如果所有对象都稳定，垃圾回收效率降低的话。就使用“标记-清扫”方式，当碎片过多就会使用“停止-复制”，这就是“自适应”垃圾回收机制。 LAST最后 java虚拟机中有许多附加技术用以提升速度，叫做just in time “即时”编译器技术。 当需要装载某些类的时候（通常是为该类创建第一个对象），编译器先找到.class文件。然后将该类的字节码装入内存。之后会有两种做法： 1、让即时编辑器编译所有代码。 这种方式有两种缺陷：一、加载动作散落在整个程序生命周期内，累加起来要花更多时间。二、增加可执行代码的长度，降低了程序速度。 2、让即时编辑器载必要时候才编译。 也称为惰性评估。这样不会被执行的代码也不会倍jit编译。在java HotSpot技术中采用了此操作。代码每次被执行都会做一些优化。执行的越多跑的越快。]]></content>
      <categories>
        <category>ThinkinJava</category>
      </categories>
      <tags>
        <tag>ThinkinJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[报数_38(java)]]></title>
    <url>%2Fposts%2FcountAndSay-38%2F</url>
    <content type="text"><![CDATA[这是该题的地址https://leetcode-cn.com/problems/count-and-say/ 报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下： 123451. 12. 113. 214. 12115. 111221 1 被读作 &quot;one 1&quot; (&quot;一个一&quot;) , 即 11。11 被读作 &quot;two 1s&quot; (&quot;两个一&quot;）, 即 21。21 被读作 &quot;one 2&quot;, “one 1&quot; （&quot;一个二&quot; , &quot;一个一&quot;) , 即 1211。 给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。 注意：整数顺序将表示为一个字符串。 示例 1: 12输入: 1输出: &quot;1&quot; 示例 2: 12输入: 4输出: &quot;1211&quot; 我的思路因为题目给了整数n,所以我们应该进行遍历，直到为n的时候输出字符串。 在遍历中，我设定了3个遍历。一个是int sum （用来保存当前字符出现的数量） string now （现在这个字符是怎么样的 例如：11，21 ） string newstr （用来保存字符串的主体 几个now加起来 就是newstr） 通过遍历当前str的值。生成 now 和 newstr。 123456789101112131415161718192021222324252627public String countAndSay(int n) &#123; int i=1; String str = &quot;1&quot;; String now ; String newstr ; int sum; while(i&lt;n)&#123; sum = 1; now = &quot;&quot;; newstr = &quot;&quot;; for(int j=0;j&lt;str.length();j++)&#123; if(j==0)&#123; now = &quot;&quot;+sum+str.charAt(j); &#125; else if(str.charAt(j)==str.charAt(j-1))&#123; sum++; now = &quot;&quot;+ sum+str.charAt(j); &#125; else&#123; sum = 1; newstr = newstr + now; now = &quot;&quot;+sum+str.charAt(j); &#125; &#125; str = newstr + now; i++; &#125; return str; &#125; 这是我的结果： 虽然通过了 但是我觉得很慢，这时候我看了看别人的代码，我觉得我们的时间复杂度差不多啊….. 之后我就发现他们用的是stringbuilder 而我用的是string 所以我对我的代码进行了改版： 使用Stringbuilder12345678910111213141516171819202122232425public String countAndSay2(int n) &#123; int i=1; StringBuilder str = new StringBuilder("1"); int sum; while(i&lt;n)&#123; sum = 1; StringBuilder now = new StringBuilder(); StringBuilder newstr = new StringBuilder(); for(int j=0;j&lt;str.length();j++)&#123; if(j==0)&#123; now = new StringBuilder(""+sum+str.charAt(j)); &#125; else if(str.charAt(j)==str.charAt(j-1))&#123; sum++; now = new StringBuilder(""+ sum+str.charAt(j)); &#125; else&#123; sum = 1; newstr = newstr.append(now); now = new StringBuilder(""+sum+str.charAt(j)); &#125; &#125; str = newstr.append(now); i++; &#125; return str.toString();&#125; 结果：]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无重复字符的最长字串_3(java)]]></title>
    <url>%2Fposts%2FlengthOfLongestSubstring-3%2F</url>
    <content type="text"><![CDATA[这是本题的地址：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/ 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。示例 1:输入: “abcabcbb”输出: 3解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。示例 2: 输入: “bbbbb”输出: 1解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。示例 3: 输入: “pwwkew”输出: 3解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。 我的思路：一开始我的思路也是使用类似于“滑动窗口”，但是应该是用到了双循环。所以，超时了不行。很难受，最后看了一下题目的解法。使用“滑动数组”。用int i , j 分别表示窗口的左右边[i,j)。创建一个hashset，用于储存字符。然后通过遍历，每当不相同时，通过判断，给maxlength 赋值给 i-j的长度。 每当有相同的时候，把hashset 里面和 s.charAt(i)相等的字符删除。然后把i往右边移动一位。 public int lengthOfLongestSubstring(String s) { int maxlength = 0; int i=0,j=0; HashSet hs = new HashSet(); while(i&lt;s.length()&amp;&amp;j&lt;s.length()){ if(!hs.contains(s.charAt(j))){ hs.add(s.charAt(j++)); int value = j-i; maxlength = maxlength&gt;value?maxlength:value; }else{ hs.remove(s.charAt(i++)); } } return maxlength; } 优化：答案中的优化时这样的。使用了hashmap()，遍历时，当不相等，判断sum和j-i+1的长度，（因为i j是2个字符了，所以需要+1长度）。然后给hashmap put一个值 key是当前的字符 value是j+1 代表当前这个字符现在在字符串中的哪个位置。 每当相等时，从hashmap里将这个字符拿出来。对比它和i哪个比较大。如果。然后将值赋给i。相当于i（左边界）右移到了第一个相同字符处。这样就形成了一个“滑动窗口拉”！ public int lengthOfLongestSubstring2(String s) { int sum =0; HashMap&lt;Character,Integer&gt; hm = new HashMap(); for(int i=0,j=0;j&lt;s.length();j++){ if(hm.containsKey(s.charAt(j))){ i = hm.get(s.charAt(j))&gt;i?hm.get(s.charAt(j)):i; } sum = sum&gt;j-i+1?sum:j-i+1; hm.put(s.charAt(j),j+1); } return sum; }]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Weekly_competition_121(java)]]></title>
    <url>%2Fposts%2Fweekgame-121%2F</url>
    <content type="text"><![CDATA[这是我第一次参加周竞赛，只做对了一题。好垃圾。。。 第一题： 这是原题的地址：https://leetcode-cn.com/contest/weekly-contest-121/problems/string-without-aaa-or-bbb/ 我的思路：用一个flaga flagb 判断a b 是否已经到了2个。然后再通过循环遍历将每一个字符输入进去。最后返回string public String strWithout3a3b(int A, int B) { int longa =0; int longb =0; StringBuffer sb = new StringBuffer(); while(A&gt;0||B&gt;0){ if(A&gt;B){ if(longa&lt;2){ longa++; longb=0; sb.append(&apos;a&apos;); A--; }else{ longa=0; sb.append(&apos;b&apos;); B--; } }else if(B&gt;A){ if(longb&lt;2){ longb++; longa=0; sb.append(&apos;b&apos;); B--; }else{ longb=0; sb.append(&apos;a&apos;); A--; } }else if(A==B){ if(longa&lt;2){ sb.append(&apos;a&apos;); sb.append(&apos;b&apos;); }else{ sb.append(&apos;b&apos;); sb.append(&apos;a&apos;); } A--;B--; } } return sb.toString(); } 官方解答：用贪心，先选择当前较多得字母写入字符串中。如果前面两个字符是一样的，下一个写入的字符就不应该相同。地址：https://leetcode-cn.com/articles/string-without-aaa-or-bbb/ 我的反思：官方比我的代码减少了很多代码量，也不用新建对象。so 要向着简洁前进！！！！]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[珠海扬名广场海底捞食记]]></title>
    <url>%2Fposts%2Fzh-food1%2F</url>
    <content type="text"><![CDATA[hi，这里是何嘉晨的食记，记录一下我每次去吃的餐厅。然后将我的感想在这里抒发出来！ 这次去的是珠海扬名广场的餐厅。因为是一次写所以没有准备拍很多照片。 这是这次去点的菜：牛肉 血旺 下滑 鸭肠 毛肚 娃娃菜 金针菇 两个人吃 一共261元： 我的评价：我觉得这几个菜里 牛肉：火锅点牛肉也是很平常的一件事 ，所以我们就点了一份牛肉其他的都是半份，牛肉很滑煮久了也不会老，听服务员说他们的牛肉是经过腌制的前腿肉和后腿肉。虽然我并不知道前腿肉和后腿肉本来是不是就是这么嫩。。。 虾滑：我就虾滑也很滑很好吃。没什么特别的吧，感觉大部分的虾滑都差不多。 血旺就一般般 可能是我不吃辣，服务员说用辣锅煮好吃些。当然他也会给你一叠干辣椒面。 鸭肠：不用煮很久，吃起来爽爽的，还不错吧。 毛肚：不用煮很久，感觉吃起来就是有点脆脆的，口感很不错。 金针菇和娃娃菜：就很普通。。。 我的总结价格：偏贵 味道：一般 服务：挺好的。 我的觉得海底捞的服务还是很不错的，反正大家都说他们是卖服务的。可能是这次一起吃的人少，所以没有点很多菜色。但是如果你问我是否会有很强烈的意愿再来一次的话：没有。]]></content>
      <categories>
        <category>食记</category>
      </categories>
      <tags>
        <tag>food</tag>
        <tag>珠海</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两数相加_2(java)]]></title>
    <url>%2Fposts%2FaddTwoNumbers-2%2F</url>
    <content type="text"><![CDATA[这是该题的地址：https://leetcode-cn.com/problems/add-two-numbers/ 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以 0 开头。示例： 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 我的思路： 链表是倒序的 所以我们可以从个位开始相加。 然后用一个int flag 来代表进位+1。 有一个firstnode 和一个 endnode 用于判断链表的第一个和最后一个节点。 当一条链为空时，将它与另一条链相等。 这样循环就不用很快跳出了。最后判断最后一位是否有进位，来新增一个节点。最后返回first节点的next。 public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int flag =0; ListNode firstNo = new ListNode(0); firstNo.next = l1; ListNode EndNode = new ListNode(0); while(l1!=null||l2!=null){ int sum; if(l1==null){ l1=l2; }else if(l2==null){ l2=l1; } if(l1==l2){ sum = l1.val +flag; }else{ sum = l1.val + l2.val +flag; } flag=0; if(sum&gt;=10){ sum-=10; flag++; } l1.val = sum; l2.val = sum; EndNode.next = l1; EndNode = l1; l1 = l1.next; l2 = l2.next; } if(flag!=0){ EndNode.next = new ListNode(1); } return firstNo.next; } 我的结果： 官方解答： 官方题解地址：https://leetcode-cn.com/problems/add-two-numbers/solution/ 我的反思：看了官方题解之后，我觉得我的和他的思路差不多。不过他是每次都新增一个，而我则是在原有的节点上进行修改 然后最后再考虑新增。不过不知道为什么他的比我快哈哈~可能是官方的代码更加简洁吧。以后我的代码也要越来越简洁！]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索插入位置-35(java)]]></title>
    <url>%2Fposts%2Fleetcode-searchInsert-35%2F</url>
    <content type="text"><![CDATA[难度：简单 这是该题的地址：https://leetcode-cn.com/problems/search-insert-position/ 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。你可以假设数组中无重复元素。 示例 1: 输入: [1,3,5,6], 5输出: 2示例 2: 输入: [1,3,5,6], 2输出: 1示例 3: 输入: [1,3,5,6], 7输出: 4示例 4: 输入: [1,3,5,6], 0输出: 0 我的思路：一、暴力从数组第一个数i=0开始遍历。将val和nums[]的值进行比较。假如值超过了或者相等了。那么就将i返回。如果遍历完了都没有返回 就将数组的长度返回 12345678public int searchInsert(int[] nums, int target) &#123; for(int i=0;i&lt;nums.length;i++)&#123; if(target==nums[i] || target&lt;nums[i])&#123; return i; &#125; &#125; return nums.length; &#125; 最终的速度： 二、二分查找因为数组是有序的，我们可以使用二分查找来搞定这个问题。二分查找就是将数组对半分开，每次和中间的点进行比较，这样第一遍循环的时候就减少了一半的长度，以此类推~。 123456789101112131415//二分查找public int searchInsert2(int[] nums, int target) &#123; int min = 0,max = nums.length; while(min&lt;max)&#123; int mid = (max + min)/2; if(nums[mid]&lt;target)&#123; min = mid+1; &#125;else if(nums[mid]&gt;target)&#123; max = mid; &#125;else&#123; return mid; &#125; &#125; return min;&#125; 题目总结当数组短target的值比较小的时候，可能暴力的方法会快一些。但假如数组变长了，target的值大了，二分查找的速度就会快很多。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello-hexo]]></title>
    <url>%2Fposts%2Fhello-hexo%2F</url>
    <content type="text"><![CDATA[我终于开始了我的hexo博客之旅。非常的开心。希望我能够一直坚持下去！！！！！]]></content>
  </entry>
  <entry>
    <title><![CDATA[移除元素-27(java)]]></title>
    <url>%2Fposts%2Fleetcode-removeElement-27%2F</url>
    <content type="text"><![CDATA[这是该题的地址：https://leetcode-cn.com/problems/remove-element 给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。示例: 给定 nums = [3,2,2,3], val = 3,函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。元素可为任意顺序。 我的思路： 写一个变量flag赋值数组的长度-1。从最后开始遍历数组。当前数=val时。将当前数和flag处的数位置进行调换。然后flag–最终减剩下的flag+1就是我们要返回的数字。数值=val的数也放到了数组的末端。这样就可以得到我们的想要的结果了！ public int removeElement(int[] nums, int val) { if(nums.length==0){ return 0; } int flag = nums.length-1; for(int i=nums.length-1;i&gt;=0;i--){ if(nums[i]==val){ int temp = nums[flag]; nums[flag] = nums[i]; nums[i] = temp; flag--; } } return flag +1; } 最终的速度： 范例代码： 我可改进之处： 不需要判断长度是否位空，也不需要多创建一个temp对象占用空间。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
</search>
