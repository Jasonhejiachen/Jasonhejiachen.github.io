<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[numDecodings_91]]></title>
    <url>%2F2019%2F02%2F13%2FnumDecodings-91%2F</url>
    <content type="text"><![CDATA[终于，感觉这道题不是那么的水了~ 这是本题的地址：https://leetcode-cn.com/problems/decode-ways/ 一条包含字母 A-Z 的消息通过以下方式进行了编码： 1234'A' -&gt; 1'B' -&gt; 2...'Z' -&gt; 26 给定一个只包含数字的非空字符串，请计算解码方法的总数。 示例 1: 123输入: "12"输出: 2解释: 它可以解码为 "AB"（1 2）或者 "L"（12）。 示例 2: 123输入: "226"输出: 3解释: 它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。 我的思路这道题是真的挺多坑的。让我头大得很。从题目中的A B ….Z 这个其实可以不用管。这道题也是采用动态规划来做，因为他是从1-26的数字，所以最多只会有2个数字连在一起。不会出现3个数字连在一起的情况。所以而且我们可以发现 12345678910例如字符串："123"。opt[0] = 1; 也就是字符串"1"处的最优解码是1opt[1] = 2; 也就是字符串"2"处的最优解码是2, 他的解码方式是 1 2和 12 其实这时候还不是很好看出递归式。opt[3] = 3; 为什么呢 其实这个我们可以拆解出来。123 可以拆解为：1 2 312 31 23三种。这时候我们可以发现一些有意思的东西，假如把 3 拿出来 1 2和12 这两个不就是opt[1]的值吗？把 23 拿出来剩下的 1 不就是opt[0]的值吗。 这时候我们就可以得出我们的递归式 ： opt[n] = opt[n-1]+opt[n-2] 突然发现这样的递归式不是很常见吗哈哈~ 得到了递归式 其实还有一个很重要的坑那就是：当有一个值为0的时候，我们会发现题目中没有给出0。但是却有10 和 20 这两个符合解码的数。但假如是0开头的是不能解码的。所以我们就要对0这个字符进行判断。如果是有0出现，假如出现了不能解码的情况，那整个字符串都不能解码。 123456789101112131415161718192021222324252627282930public int numDecodings(String s) &#123; int n = s.length(); int[] opt = new int[n]; opt[0] = s.charAt(0)=='0'?0:1; for(int i=1;i&lt;n;i++)&#123; int sum =Integer.parseInt(s.substring(i-1,i+1)); if(s.charAt(i)=='0')&#123; if(sum&lt;10||sum&gt;26)&#123; opt[i] = 0; &#125;else&#123; if(i&lt;2)&#123; opt[i] = opt[i-1]; &#125;else&#123; opt[i] = opt[i-2]; &#125; &#125; &#125;else&#123; if(sum&lt;=26&amp;&amp;sum&gt;=10)&#123; if(i&lt;2)&#123; opt[i] = opt[i-1] + 1; &#125;else&#123; opt[i] = opt[i-1] + opt[i-2]; &#125; &#125; else&#123; opt[i] = opt[i-1]; &#125; &#125; &#125; return opt[n-1];&#125; 我的反思虽然用上了动态规划 但是我觉得里面的if else 也还是有点多….. 别人的速度虽然比我快一点，但是看起来我们的时间复杂度都是O(n)呀。。。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[minPathSum_64]]></title>
    <url>%2F2019%2F02%2F13%2FminPathSum-64%2F</url>
    <content type="text"><![CDATA[这是本题的地址https://leetcode-cn.com/problems/minimum-path-sum/ 给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例: 12345678输入:[ [1,3,1], [1,5,1], [4,2,1]]输出: 7解释: 因为路径 1→3→1→1→1 的总和最小。 我的思路感觉62 63 64 都是连续的题目 都是使用动态规划来做这道题。都是一些很简单的动态规划。 从题目中我们可以了解递归式： 1opt[i][j] = (opt[i-1][j]&lt;opt[i][j-1]?opt[i-1][j]:opt[i][j-1]) + grid[i][j]; 通过使用这个递归式最终我们可以得出我们想要的结果 12345678910111213141516171819202122public int minPathSum(int[][] grid) &#123; if(grid==null || grid.length==0 ||(grid.length==1&amp;&amp;grid[0].length==0))&#123; return 0; &#125; int n = grid.length; int m = grid[0].length; int[][] opt = new int[n][m]; for(int i = 0;i&lt;n;i++)&#123; for(int j =0;j&lt;m;j++)&#123; if (i == 0 &amp;&amp; j == 0) &#123; opt[i][j] = grid[i][j]; &#125;else if(i == 0)&#123; opt[i][j] = grid[i][j]+opt[i][j-1]; &#125;else if(j == 0)&#123; opt[i][j] = grid[i][j]+opt[i-1][j]; &#125;else&#123; opt[i][j] = (opt[i-1][j]&lt;opt[i][j-1]?opt[i-1][j]:opt[i][j-1]) + grid[i][j]; &#125; &#125; &#125; return opt[n-1][m-1];&#125; 我的反思最终跑出来的速度比别人的慢很多，但是我看了下别人的范例代码。我觉得我们的代码好像都是一样的呀？有的人也用递归来做，也不知道是不是更好一些。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[uniquePathsWithObstacles_63]]></title>
    <url>%2F2019%2F02%2F12%2FuniquePathsWithObstacles-63%2F</url>
    <content type="text"><![CDATA[这是本题的地址：https://leetcode-cn.com/problems/unique-paths-ii/ 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ 网格中的障碍物和空位置分别用 1 和 0 来表示。 说明：*m 和 n* 的值均不超过 100。 示例 1: 123456789101112输入:[ [0,0,0], [0,1,0], [0,0,0]]输出: 2解释:3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 2 条不同的路径：1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右 我的思路这道题和uniquePaths-62 类似。但是增加了一个障碍的条件。我的做法其实和之前的差不多，但是增加了一些关于遇到“障碍”时的判断。这道题也是使用动态规划~，有一个问题在于假如传入的是空的数组。获取第二维的长度的时候会报错。 判断二维数组是否位空： if ( array == null || array.length == 0 || ( array.length == 1 &amp;&amp; array[0].length == 0 ) ) 1234567891011121314151617181920212223public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123; int n = obstacleGrid.length; int m = obstacleGrid[0].length; int[][] opt = new int[n][m]; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++)&#123; if(obstacleGrid[i][j]==1)&#123; opt[i][j] = 0; &#125;else&#123; if(i==0&amp;&amp;j==0)&#123; opt[i][j] =1; &#125;else if(i==0)&#123; opt[i][j] = opt[i][j-1]; &#125;else if(j==0)&#123; opt[i][j] = opt[i-1][j]; &#125;else&#123; opt[i][j] = opt[i][j-1]+opt[i-1][j]; &#125; &#125; &#125; &#125; return opt[n-1][m-1];&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[uniquePaths_62(java)]]></title>
    <url>%2F2019%2F02%2F11%2FuniquePaths-62%2F</url>
    <content type="text"><![CDATA[这是本题的地址:https://leetcode-cn.com/problems/unique-paths/ 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 问总共有多少条不同的路径？ 例如，上图是一个7 x 3 的网格。有多少可能的路径？ 说明：*m 和 n* 的值均不超过 100。 示例 1: 1234567输入: m = 3, n = 2输出: 3解释:从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -&gt; 向右 -&gt; 向下2. 向右 -&gt; 向下 -&gt; 向右3. 向下 -&gt; 向右 -&gt; 向右 示例 2: 12输入: m = 7, n = 3输出: 28 我的思路这题我是想着使用动态规划来做的，这个与之前动态规划不同的是 他是一个二维数组。这样的话最优解opt的数组也是一个二维数组。且题目中说明每次只能向下或向右移动一步。这样的话，递归式应该是这样：opt [n] [m] = opt[n-1] [m] + opt[n] [m-1]。得到了递归式，我们就可以开始进行操作了。 12345678910111213141516public int uniquePaths(int m, int n) &#123; if(m==0||n==0)&#123; return 0; &#125; int[][] opt = new int[m][n]; for(int i=0;i&lt;m;i++)&#123; for(int j=0;j&lt;n;j++)&#123; if(i==0||j==0)&#123; opt[i][j]=1; &#125;else&#123; opt[i][j] = opt[i][j-1]+opt[i-1][j]; &#125; &#125; &#125; return opt[m-1][n-1];&#125; 我感觉不太好，因为要使用两个for 但是好像必须这样，因为是一个二维数组。时间复杂度：O(n^2)。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[plusOne_66(java)]]></title>
    <url>%2F2019%2F02%2F10%2FplusOne-66%2F</url>
    <content type="text"><![CDATA[这是本题的地址https://leetcode-cn.com/problems/plus-one/ 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1: 123输入: [1,2,3]输出: [1,2,4]解释: 输入数组表示数字 123。 示例 2: 123输入: [4,3,2,1]输出: [4,3,2,2]解释: 输入数组表示数字 4321。 我的思路这道题我觉得同 addTwoNumbers-2-两数之和 题有一点点类似，但是一个是链表一个是数组 我的做法是这样的。从数组最后一个数字进行遍历，将其+1。若果超过了10。那么当前的数就要%10。并且flag=1。 通过flag来查看是否需要添加一位最新的数。如需要 就用for循环新建一个数组。如不需要就直接返回当前数组。 123456789101112131415161718192021public int[] plusOne(int[] digits) &#123; int flag =0; for(int i=digits.length-1;i&gt;=0;i--)&#123; digits[i]+=1; if(digits[i]&gt;=10)&#123; flag =1; digits[i] = digits[i]%10; &#125;else&#123; flag =0; &#125; if(flag==0)&#123;break;&#125; &#125; int[] a = new int[digits.length+1]; if(flag==1)&#123; a[0] = 1; for(int i=1;i&lt;=digits.length;i++)&#123; a[i] = digits[i-1]; &#125; &#125; return flag==1?a:digits;&#125; 时间复杂度为 ：O(n) n为数组的长度。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lengthOfLastWord_58(java)]]></title>
    <url>%2F2019%2F02%2F07%2FlengthOfLastWord-58%2F</url>
    <content type="text"><![CDATA[这是本题的地址：https://leetcode-cn.com/problems/length-of-last-word/ 给定一个仅包含大小写字母和空格 &#39; &#39; 的字符串，返回其最后一个单词的长度。 如果不存在最后一个单词，请返回 0 。 说明：一个单词是指由字母组成，但不包含任何空格的字符串。 示例: 12输入: "Hello World"输出: 5 我的思路：一开始想着用lastindexof来做，但是不行。因为假如是”a b “ 这样的字符串。用lastindexof是行不通的。那么我们就用for循环开始遍历整个字符串。获取字符的长度。每当是’ ‘的时候，就将长度值设为0。lastlength用于记录上个字符的长度。length记录当前字符的长度。当length为0时 说明 ‘ ’符后面没有字符了。这时候就需要返回lastlength 12345678910111213public int lengthOfLastWord(String s) &#123; int length=0; int lastlength=0; for(int i=0;i&lt;s.length();i++)&#123; if(s.charAt(i)==' ')&#123; lastlength = length==0?lastlength:length; length = 0; &#125;else&#123; length++; &#125; &#125; return length==0?lastlength:length;&#125; 官方思路没有，让我们来看看别人的做法是怎么样的 看了一下范例，发现其实大多数都是用for循环的。它们从最后开始往回找，这样循环的遍历就少多了。但既然都是用for循环。就不列出来了。有一个蛮有意思的： 他的做法是用trim去掉首尾的 “ “空格符，通过寻找剩下的” “空格符。如果没有就返回整体的长度。如果有就判断是否有字符串，没有就返回0。最后再返回原长度-i-1。 i就是倒数的” “空格符的位置。那么减去它就相当于减掉了前面的长度。再-1就是把” “空格符所占的1个位置给减掉了~。 123456789101112public int lengthOfLastWord2(String s) &#123; s = s.trim(); int i = s.lastIndexOf(" "); if (i == -1)&#123; return s.length(); &#125; if (i == s.length()-1)&#123; return 0; &#125;else &#123; return s.length()-i-1; &#125;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[weekgame_122]]></title>
    <url>%2F2019%2F02%2F03%2Fweekgame-122%2F</url>
    <content type="text"><![CDATA[这是该题的地址：https://leetcode-cn.com/contest/weekly-contest-122/problems/sum-of-even-numbers-after-queries/ 给出一个整数数组 A 和一个查询数组 queries。 对于第 i 次查询，有 val = queries[i][0], index = queries[i][1]，我们会把 val 加到 A[index] 上。然后，第 i 次查询的答案是 A中偶数值的和。 （此处给定的 index = queries[i][1] 是从 0 开始的索引，每次查询都会永久修改数组 A。） 返回所有查询的答案。你的答案应当以数组 answer 给出，answer[i] 为第 i 次查询的答案。 示例： 12345678输入：A = [1,2,3,4], queries = [[1,0],[-3,1],[-4,0],[2,3]]输出：[8,6,2,4]解释：开始时，数组为 [1,2,3,4]。将 1 加到 A[0] 上之后，数组为 [2,2,3,4]，偶数值之和为 2 + 2 + 4 = 8。将 -3 加到 A[1] 上之后，数组为 [2,-1,3,4]，偶数值之和为 2 + 4 = 6。将 -4 加到 A[0] 上之后，数组为 [-2,-1,3,4]，偶数值之和为 -2 + 4 = 2。将 2 加到 A[3] 上之后，数组为 [-2,-1,3,6]，偶数值之和为 -2 + 6 = 4。 提示： 1 &lt;= A.length &lt;= 10000 -10000 &lt;= A[i] &lt;= 10000 1 &lt;= queries.length &lt;= 10000 -10000 &lt;= queries[i][0] &lt;= 10000 0 &lt;= queries[i][1] &lt; A.length 我的思路根据题目，我们可以得知，answer的长度为i 而i的值则是queries的长度。那么我们可以通过遍历queries数组。然后对数组A进行操作。之后通过遍历数组A 找出偶数，并相加求出和。然后得出一个值，放进anwser数组里。 1234567891011121314public int[] sumEvenAfterQueries(int[] A, int[][] queries) &#123; int [] answer = new int[queries.length]; for(int i=0;i&lt;queries.length;i++)&#123; A[queries[i][1]] += queries[i][0]; int sum =0; for(int j=0;j&lt;A.length;j++)&#123; if(A[j]%2==0)&#123; sum+=A[j]; &#125; &#125; answer[i] = sum; &#125; return answer;&#125; 缺点：使用了暴力破解。时间复杂度增高。 官方思路感觉官方的思路比较聪明，通过先找出A数组中的偶数和。然后再通过添加的操作判断当前数是否还是偶数。这样的话只需要通过单个循环就可以实现了。 https://leetcode-cn.com/articles/sum-of-even-numbers-after-queries/]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[climbStairs-70(java)]]></title>
    <url>%2F2019%2F02%2F01%2FclimbStairs-70%2F</url>
    <content type="text"><![CDATA[这是本题的地址https://leetcode-cn.com/problems/climbing-stairs/ 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 12345输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1. 1 阶 + 1 阶2. 2 阶 示例 2： 123456输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1. 1 阶 + 1 阶 + 1 阶2. 1 阶 + 2 阶3. 2 阶 + 1 阶 我的思路：其实这个仔细的看一下就会发现和哪个斐波那契数列第n项问题很像。主要的递归式就是 f[n] = f[n-1]+f[n-2]。 通过这个式子我们就可以得出第n个梯子有多少种变化啦~最后返回数组的n-1即可。 1234567891011121314public int climbStairs(int n) &#123; if(n==1)&#123; return 1; &#125;else if(n==2)&#123; return 2; &#125; int[] foot = new int[n]; foot[0] = 1; foot[1] = 2; for(int i=2;i&lt;n;i++)&#123; foot[i] = foot[i-1]+foot[i-2]; &#125; return foot[n-1];&#125; 我的结果]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maxSubArray-53]]></title>
    <url>%2F2019%2F02%2F01%2FmaxSubArray-53%2F</url>
    <content type="text"><![CDATA[这是本题的地址：https://leetcode-cn.com/problems/maximum-subarray/ 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 123输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 我的思路1、暴力： 循环遍历当前数组的每个节点，设定一个int sum值来记录最长的子字符串的长度。 123456789101112public int maxSubArray(int[] nums) &#123; int n = nums.length; int sum=nums[0]; for(int i=0;i&lt;n;i++)&#123; int sum1 =0; for(int j=i;j&gt;=0;j--)&#123; sum1 += nums[j]; sum = sum&gt;sum1?sum:sum1; &#125; &#125; return sum;&#125; 缺点： 慢。能不用就不用 2、动态规划： 进行一次遍历： 每当前面的子序之和为负值时，也就证明了有没有前面的数字都是无所谓的，这时候，就可以重新记录子序和了~。然后将这些进行比较，最大的就返回出来。 12345678910111213public int maxSubArray2(int[] nums) &#123; int max= nums[0]; int sum=0; for(int i=0;i&lt;nums.length;i++)&#123; if(sum&gt;0 )&#123; sum+=nums[i]; &#125;else&#123; sum=nums[i]; &#125; max = Math.max(sum,max); &#125; return max;&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[longestPalindrome_5]]></title>
    <url>%2F2019%2F01%2F30%2FlongestPalindrome-5%2F</url>
    <content type="text"><![CDATA[这是本题的地址：https://leetcode-cn.com/problems/longest-palindromic-substring/ 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 123输入: "babad"输出: "bab"注意: "aba" 也是一个有效答案。 示例 2： 12输入: "cbbd"输出: "bb" 我的思路：有一个String sum =”” 来保存最大的回文。 有第一个for(int i=0)循环遍历整个字符串。然后第二个字符串由j=i 开始，判断这i j之间是否是回文。如果是，那么j-i+1(加1是因为j和i相同时，也是有一个字符的)是否大于sum的长度。如果大于，那么他们就是最大的回文。 那么用于判断ij之间是否为回文的方法我是这样做的：先判断当前i j的字符是否相同，如果相同则判断 i j 是否相等或相邻，如果是那么就返回true。如果不是那么进行 i+1 和 j-1的递归。若果i j的字符不相同，则返回false；这样是暴力解法。时间复杂度 n3次方。 123456789101112131415161718192021222324public String longestPalindrome(String s) &#123; String sum = ""; for(int i=0;i&lt;s.length();i++)&#123; for(int j=i;j&lt;s.length();j++)&#123; if(Panduan(i,j,s))&#123; if(j-i+1&gt;sum.length())&#123; sum = s.substring(i,j+1); &#125; &#125; &#125; &#125; return sum;&#125;boolean Panduan(int a,int b,String s)&#123; if(s.charAt(a)==s.charAt(b))&#123; if(a==b||a==b-1||a-1==b)&#123; return true; &#125; return Panduan(++a,--b,s); &#125;else&#123; return false; &#125;&#125; 我的结果： 特别的慢：这也是暴力解法的问题所在！ 在官方的解答中：有动态规划和中心扩展算法这两个。等我看懂了再补充上来！~]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清理：终结处理和垃圾回收]]></title>
    <url>%2F2019%2F01%2F29%2F%E6%B8%85%E7%90%86%EF%BC%9A%E7%BB%88%E7%BB%93%E5%A4%84%E7%90%86%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%2F</url>
    <content type="text"><![CDATA[清理：终结处理和垃圾回收垃圾回收的三个要点 1、对象可能不被垃圾回收 2、垃圾回收并不等于“析构” 3、垃圾回收只和内存有关 java 中允许调用finalize方法，这个方法却不能作为通用的清理方法。因为程序没有濒临储存空间用完，那么就不需要释放内存。因为垃圾回收也是需要开销的，如果不用它，那么这部分开销就省下来了。那么finalize方法在什么时候可以调用呢：在通过某种创建对象方式以外的方式为对象分配了储存空间，但是java一切皆为对象。。。this is special！ *java中有一种“本地方法”，它是一种在java中调用的非java代码，在jdk1.5时是只支持c/c++的，它可能会调用c的函数来分配对象，也可能调用任何其他语言。so，这些都需要特定的储存释放方法来释放。这时候finalize就有用武之地了。 垃圾回收机制1、引用计数这是一种很简单但是很慢的垃圾回收技术，每个对象都有一个引用计数器，当有引用链接到对象时，引用计数+1，当引用离开作用域或被置为null，引用计数就会-1，当引用计数=0的时候就回回收对象。 缺陷：当对象之前存在循环引用，引用计数不为0时但又要被回收的时候，这样对于垃圾回收工作量非常大。引用计数常用来说明垃圾收集的工作方式，没有被应用于任何java虚拟机实现。 2、自适应垃圾回收技术：停止-复制暂停程序的运行，将当前堆所有存活的对象复制到另一个堆，没有被复制的都会被垃圾回收。当对象被复制到新的堆中的时候，它们时一个挨着一个的。所以新堆抱持紧凑排列，以后的分配空间也很简单。 缺点： –1 效率低，需要有两个堆。维护比实际需要多一倍的空间。 某些java虚拟机的处理方式：按需从内存中分配较大块的内存，复制动作发生在他们里面。 –2 程序进入稳定状态之后可能只会产生少量的垃圾，但是如果用这个还是会将内存从一处复制到另外一处。 3、自适应垃圾回收技术：标记-清扫基于上一份放的问题2，产生了新的垃圾回收机制：标记-清扫。遍历所有的引用，找出活对象并标记，在全部标记完成之后，才会进行清扫工作。把没有标记的对象都进行垃圾回收。这样下来，剩下的空间是不连续的。 小总结java虚拟机会进行监视，如果所有对象都稳定，垃圾回收效率降低的话。就使用“标记-清扫”方式，当碎片过多就会使用“停止-复制”，这就是“自适应”垃圾回收机制。 LAST最后 java虚拟机中有许多附加技术用以提升速度，叫做just in time “即时”编译器技术。 当需要装载某些类的时候（通常是为该类创建第一个对象），编译器先找到.class文件。然后将该类的字节码装入内存。之后会有两种做法： 1、让即时编辑器编译所有代码。 这种方式有两种缺陷：一、加载动作散落在整个程序生命周期内，累加起来要花更多时间。二、增加可执行代码的长度，降低了程序速度。 2、让即时编辑器载必要时候才编译。 也称为惰性评估。这样不会被执行的代码也不会倍jit编译。在java HotSpot技术中采用了此操作。代码每次被执行都会做一些优化。执行的越多跑的越快。]]></content>
      <categories>
        <category>ThinkinJava</category>
      </categories>
      <tags>
        <tag>ThinkinJava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[countAndSay_38(java)]]></title>
    <url>%2F2019%2F01%2F29%2FcountAndSay-38%2F</url>
    <content type="text"><![CDATA[这是该题的地址https://leetcode-cn.com/problems/count-and-say/ 报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下： 123451. 12. 113. 214. 12115. 111221 1 被读作 &quot;one 1&quot; (&quot;一个一&quot;) , 即 11。11 被读作 &quot;two 1s&quot; (&quot;两个一&quot;）, 即 21。21 被读作 &quot;one 2&quot;, “one 1&quot; （&quot;一个二&quot; , &quot;一个一&quot;) , 即 1211。 给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。 注意：整数顺序将表示为一个字符串。 示例 1: 12输入: 1输出: &quot;1&quot; 示例 2: 12输入: 4输出: &quot;1211&quot; 我的思路因为题目给了整数n,所以我们应该进行遍历，直到为n的时候输出字符串。 在遍历中，我设定了3个遍历。一个是int sum （用来保存当前字符出现的数量） string now （现在这个字符是怎么样的 例如：11，21 ） string newstr （用来保存字符串的主体 几个now加起来 就是newstr） 通过遍历当前str的值。生成 now 和 newstr。 123456789101112131415161718192021222324252627public String countAndSay(int n) &#123; int i=1; String str = &quot;1&quot;; String now ; String newstr ; int sum; while(i&lt;n)&#123; sum = 1; now = &quot;&quot;; newstr = &quot;&quot;; for(int j=0;j&lt;str.length();j++)&#123; if(j==0)&#123; now = &quot;&quot;+sum+str.charAt(j); &#125; else if(str.charAt(j)==str.charAt(j-1))&#123; sum++; now = &quot;&quot;+ sum+str.charAt(j); &#125; else&#123; sum = 1; newstr = newstr + now; now = &quot;&quot;+sum+str.charAt(j); &#125; &#125; str = newstr + now; i++; &#125; return str; &#125; 这是我的结果： 虽然通过了 但是我觉得很慢，这时候我看了看别人的代码，我觉得我们的时间复杂度差不多啊….. 之后我就发现他们用的是stringbuilder 而我用的是string 所以我对我的代码进行了改版： 使用Stringbuilder12345678910111213141516171819202122232425public String countAndSay2(int n) &#123; int i=1; StringBuilder str = new StringBuilder("1"); int sum; while(i&lt;n)&#123; sum = 1; StringBuilder now = new StringBuilder(); StringBuilder newstr = new StringBuilder(); for(int j=0;j&lt;str.length();j++)&#123; if(j==0)&#123; now = new StringBuilder(""+sum+str.charAt(j)); &#125; else if(str.charAt(j)==str.charAt(j-1))&#123; sum++; now = new StringBuilder(""+ sum+str.charAt(j)); &#125; else&#123; sum = 1; newstr = newstr.append(now); now = new StringBuilder(""+sum+str.charAt(j)); &#125; &#125; str = newstr.append(now); i++; &#125; return str.toString();&#125; 结果：]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lengthOfLongestSubstring_3(java)]]></title>
    <url>%2F2019%2F01%2F28%2FlengthOfLongestSubstring-3%2F</url>
    <content type="text"><![CDATA[这是本题的地址：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/ 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。示例 1:输入: “abcabcbb”输出: 3解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。示例 2: 输入: “bbbbb”输出: 1解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。示例 3: 输入: “pwwkew”输出: 3解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。 我的思路：一开始我的思路也是使用类似于“滑动窗口”，但是应该是用到了双循环。所以，超时了不行。很难受，最后看了一下题目的解法。使用“滑动数组”。用int i , j 分别表示窗口的左右边[i,j)。创建一个hashset，用于储存字符。然后通过遍历，每当不相同时，通过判断，给maxlength 赋值给 i-j的长度。 每当有相同的时候，把hashset 里面和 s.charAt(i)相等的字符删除。然后把i往右边移动一位。 public int lengthOfLongestSubstring(String s) { int maxlength = 0; int i=0,j=0; HashSet hs = new HashSet(); while(i&lt;s.length()&amp;&amp;j&lt;s.length()){ if(!hs.contains(s.charAt(j))){ hs.add(s.charAt(j++)); int value = j-i; maxlength = maxlength&gt;value?maxlength:value; }else{ hs.remove(s.charAt(i++)); } } return maxlength; } 优化：答案中的优化时这样的。使用了hashmap()，遍历时，当不相等，判断sum和j-i+1的长度，（因为i j是2个字符了，所以需要+1长度）。然后给hashmap put一个值 key是当前的字符 value是j+1 代表当前这个字符现在在字符串中的哪个位置。 每当相等时，从hashmap里将这个字符拿出来。对比它和i哪个比较大。如果。然后将值赋给i。相当于i（左边界）右移到了第一个相同字符处。这样就形成了一个“滑动窗口拉”！ public int lengthOfLongestSubstring2(String s) { int sum =0; HashMap&lt;Character,Integer&gt; hm = new HashMap(); for(int i=0,j=0;j&lt;s.length();j++){ if(hm.containsKey(s.charAt(j))){ i = hm.get(s.charAt(j))&gt;i?hm.get(s.charAt(j)):i; } sum = sum&gt;j-i+1?sum:j-i+1; hm.put(s.charAt(j),j+1); } return sum; }]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Weekly_competition_121(java)]]></title>
    <url>%2F2019%2F01%2F27%2Fweekgame-121%2F</url>
    <content type="text"><![CDATA[这是我第一次参加周竞赛，只做对了一题。好垃圾。。。 第一题： 这是原题的地址：https://leetcode-cn.com/contest/weekly-contest-121/problems/string-without-aaa-or-bbb/ 我的思路：用一个flaga flagb 判断a b 是否已经到了2个。然后再通过循环遍历将每一个字符输入进去。最后返回string public String strWithout3a3b(int A, int B) { int longa =0; int longb =0; StringBuffer sb = new StringBuffer(); while(A&gt;0||B&gt;0){ if(A&gt;B){ if(longa&lt;2){ longa++; longb=0; sb.append(&apos;a&apos;); A--; }else{ longa=0; sb.append(&apos;b&apos;); B--; } }else if(B&gt;A){ if(longb&lt;2){ longb++; longa=0; sb.append(&apos;b&apos;); B--; }else{ longb=0; sb.append(&apos;a&apos;); A--; } }else if(A==B){ if(longa&lt;2){ sb.append(&apos;a&apos;); sb.append(&apos;b&apos;); }else{ sb.append(&apos;b&apos;); sb.append(&apos;a&apos;); } A--;B--; } } return sb.toString(); } 官方解答：用贪心，先选择当前较多得字母写入字符串中。如果前面两个字符是一样的，下一个写入的字符就不应该相同。地址：https://leetcode-cn.com/articles/string-without-aaa-or-bbb/ 我的反思：官方比我的代码减少了很多代码量，也不用新建对象。so 要向着简洁前进！！！！]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[珠海扬名广场海底捞食记]]></title>
    <url>%2F2019%2F01%2F26%2Fzh-food1%2F</url>
    <content type="text"><![CDATA[hi，这里是何嘉晨的食记，记录一下我每次去吃的餐厅。然后将我的感想在这里抒发出来！ 这次去的是珠海扬名广场的餐厅。因为是一次写所以没有准备拍很多照片。 这是这次去点的菜：牛肉 血旺 下滑 鸭肠 毛肚 娃娃菜 金针菇 两个人吃 一共261元： 我的评价：我觉得这几个菜里 牛肉：火锅点牛肉也是很平常的一件事 ，所以我们就点了一份牛肉其他的都是半份，牛肉很滑煮久了也不会老，听服务员说他们的牛肉是经过腌制的前腿肉和后腿肉。虽然我并不知道前腿肉和后腿肉本来是不是就是这么嫩。。。 虾滑：我就虾滑也很滑很好吃。没什么特别的吧，感觉大部分的虾滑都差不多。 血旺就一般般 可能是我不吃辣，服务员说用辣锅煮好吃些。当然他也会给你一叠干辣椒面。 鸭肠：不用煮很久，吃起来爽爽的，还不错吧。 毛肚：不用煮很久，感觉吃起来就是有点脆脆的，口感很不错。 金针菇和娃娃菜：就很普通。。。 我的总结价格：偏贵 味道：一般 服务：挺好的。 我的觉得海底捞的服务还是很不错的，反正大家都说他们是卖服务的。可能是这次一起吃的人少，所以没有点很多菜色。但是如果你问我是否会有很强烈的意愿再来一次的话：没有。]]></content>
      <categories>
        <category>食记</category>
      </categories>
      <tags>
        <tag>food</tag>
        <tag>珠海</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[addTwoNumbers_2(java)]]></title>
    <url>%2F2019%2F01%2F26%2FaddTwoNumbers-2%2F</url>
    <content type="text"><![CDATA[这是该题的地址：https://leetcode-cn.com/problems/add-two-numbers/ 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以 0 开头。示例： 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 我的思路： 链表是倒序的 所以我们可以从个位开始相加。 然后用一个int flag 来代表进位+1。 有一个firstnode 和一个 endnode 用于判断链表的第一个和最后一个节点。 当一条链为空时，将它与另一条链相等。 这样循环就不用很快跳出了。最后判断最后一位是否有进位，来新增一个节点。最后返回first节点的next。 public ListNode addTwoNumbers(ListNode l1, ListNode l2) { int flag =0; ListNode firstNo = new ListNode(0); firstNo.next = l1; ListNode EndNode = new ListNode(0); while(l1!=null||l2!=null){ int sum; if(l1==null){ l1=l2; }else if(l2==null){ l2=l1; } if(l1==l2){ sum = l1.val +flag; }else{ sum = l1.val + l2.val +flag; } flag=0; if(sum&gt;=10){ sum-=10; flag++; } l1.val = sum; l2.val = sum; EndNode.next = l1; EndNode = l1; l1 = l1.next; l2 = l2.next; } if(flag!=0){ EndNode.next = new ListNode(1); } return firstNo.next; } 我的结果： 官方解答： 官方题解地址：https://leetcode-cn.com/problems/add-two-numbers/solution/ 我的反思：看了官方题解之后，我觉得我的和他的思路差不多。不过他是每次都新增一个，而我则是在原有的节点上进行修改 然后最后再考虑新增。不过不知道为什么他的比我快哈哈~可能是官方的代码更加简洁吧。以后我的代码也要越来越简洁！]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-searchInsert-35(java)]]></title>
    <url>%2F2019%2F01%2F25%2Fleetcode-searchInsert-35%2F</url>
    <content type="text"><![CDATA[这是该题的地址：https://leetcode-cn.com/problems/search-insert-position/ 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。你可以假设数组中无重复元素。 示例 1: 输入: [1,3,5,6], 5输出: 2示例 2: 输入: [1,3,5,6], 2输出: 1示例 3: 输入: [1,3,5,6], 7输出: 4示例 4: 输入: [1,3,5,6], 0输出: 0 我的思路： 从数组第一个数i=0开始遍历。将val和nums[]的值进行比较。假如值超过了或者相等了。那么就将i返回。如果遍历完了都没有返回 就将数组的长度返回 public int searchInsert(int[] nums, int target) { for(int i=0;i&lt;nums.length;i++){ if(target==nums[i] || target&lt;nums[i]){ return i; } } return nums.length; } 最终的速度：]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello-hexo]]></title>
    <url>%2F2019%2F01%2F24%2Fhello-hexo%2F</url>
    <content type="text"><![CDATA[我终于开始了我的hexo博客之旅。非常的开心。希望我能够一直坚持下去！！！！！]]></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode-removeElement-27(java)]]></title>
    <url>%2F2019%2F01%2F24%2Fleetcode-removeElement-27%2F</url>
    <content type="text"><![CDATA[这是该题的地址：https://leetcode-cn.com/problems/remove-element 给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。示例: 给定 nums = [3,2,2,3], val = 3,函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。元素可为任意顺序。 我的思路： 写一个变量flag赋值数组的长度-1。从最后开始遍历数组。当前数=val时。将当前数和flag处的数位置进行调换。然后flag–最终减剩下的flag+1就是我们要返回的数字。数值=val的数也放到了数组的末端。这样就可以得到我们的想要的结果了！ public int removeElement(int[] nums, int val) { if(nums.length==0){ return 0; } int flag = nums.length-1; for(int i=nums.length-1;i&gt;=0;i--){ if(nums[i]==val){ int temp = nums[flag]; nums[flag] = nums[i]; nums[i] = temp; flag--; } } return flag +1; } 最终的速度： 范例代码： 我可改进之处： 不需要判断长度是否位空，也不需要多创建一个temp对象占用空间。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
</search>
